# 1. C 언어 기초

# 1.1 C 언어 개요

C 언어는 1972년 벨 연구소(Bell Labs)의 데니스 리치(Dennis Ritchie)가 UNIX 운영체제 개발을 위해 설계한 고급 프로그래밍 언어이다. 이 언어는 B 언어를 기반으로 개발되었으며, 시스템 프로그래밍에 적합한 구조적 절차형 언어로 설계되었다. C 언어는 하드웨어에 밀접한 저수준 제어를 가능하게 하면서도 고급 언어의 추상화를 일부 제공하여 효율성과 이식성의 균형을 갖춘 것이 가장 큰 특징이다.

C 언어는 다음과 같은 핵심적인 특징을 가진다.
 첫째, 구조적 프로그래밍(Structured Programming) 언어로서 코드의 가독성과 유지보수성을 고려하여 함수, 제어문, 블록 등의 구문을 통해 프로그램을 계층적으로 구성할 수 있다.
 둘째, 포인터(Pointer)를 통해 메모리 주소에 직접 접근이 가능하며, 이는 시스템 자원의 직접 제어가 필요한 운영체제, 드라이버, 임베디드 시스템 등의 프로그래밍에 매우 유리하다.
 셋째, C 언어는 컴파일 언어이며, 소스코드를 목적 파일로 변환하고 링커를 통해 실행 가능한 바이너리로 연결하는 과정을 거친다. 이는 해석형 언어보다 실행 속도가 빠르며, 시스템 수준의 제어와 최적화가 가능하다는 이점을 가진다.
 넷째, 다른 언어(C++, Java 등)와 비교하여 간결하면서도 강력한 문법 구조를 가지고 있으며, 하드웨어와 가까운 저수준 조작이 가능하다는 점에서 성능이 중요한 응용에서 선호된다.

C 언어의 응용 분야는 매우 광범위하다. 운영체제의 핵심 모듈(예: Linux 커널), 임베디드 시스템의 펌웨어, 마이크로컨트롤러 제어, 데이터베이스 시스템, 컴파일러 및 가상머신, 네트워크 장비의 펌웨어 등에서 핵심적인 역할을 담당하고 있다.

C 언어의 컴파일 과정은 총 네 단계로 나뉜다.
 1단계는 전처리(Preprocessing) 단계로, `#include`, `#define`, `#ifdef` 등의 전처리 지시문이 처리된다.
 2단계는 컴파일(Compilation) 단계로, 전처리된 C 코드가 어셈블리 코드로 변환된다.
 3단계는 어셈블(Assembly) 단계로, 어셈블리 코드가 목적 코드(.o 또는 .obj)로 변환된다.
 4단계는 링커(Linking) 단계로, 여러 개의 목적 파일 및 라이브러리를 연결하여 실행 가능한 바이너리(.exe, ELF 등)를 생성한다.

표준화 측면에서 C 언어는 여러 차례의 국제 표준 제정을 거쳤다. ANSI C(1989), ISO C(1990), C99, C11, C17로 이어지는 표준은 각각 새로운 기능을 도입하거나 기존 기능을 명확히 하며 언어의 표현력을 강화해 왔다. 예를 들어 C99에서는 `//` 한 줄 주석, 가변 길이 배열, `inline` 함수, `long long int` 등의 확장된 기능이 도입되었다.

C 언어는 현재까지도 다양한 플랫폼에서 지원되며, 최신 마이크로컨트롤러, RTOS, OS 커널, 시스템 라이브러리 개발에 있어 표준 도구로 간주된다. 특히 이식성과 성능, 하드웨어 직접 제어 능력은 현대에도 유효한 장점으로 남아 있으며, 대부분의 고급 언어(예: Python, Java)의 내부 구현도 상당 부분 C로 작성되어 있다.

따라서 C 언어의 학습은 단순히 언어 자체에 그치지 않고, 하드웨어와 소프트웨어 사이의 연결, 저수준 동작 원리의 이해, 고급 언어 설계 철학의 근간을 이루는 이론과 실습을 모두 포함하는 핵심 기초로 작용한다. 이는 프로그래머가 시스템 전반에 대한 이해를 심화시키는 데 결정적인 기반이 된다.

## 언어의 역사 및 배경

C 언어는 시스템을 제어할 수 있는 능력과 고급 언어의 추상화 기능을 절묘하게 결합한 언어다. 이 언어는 1972년, 미국 AT&T 벨 연구소의 데니스 리치(Dennis Ritchie)가 UNIX 운영체제를 구현하기 위해 고안하였다. 이후 C는 운영체제, 컴파일러, 임베디드 시스템, 드라이버 개발 등 시스템 전반에서 사실상 표준 언어로 자리 잡았다.

C 언어가 등장하게 된 기술적 맥락은 다음과 같다.

#### 🧬 기원과 계보

1960년대 중반, 시스템 소프트웨어 개발을 위한 목적으로 CPL이라는 언어가 제안되었으나, 언어가 지나치게 복잡하고 비대해 실용적으로 사용되지 못했다. 이에 따라 1966년 마틴 리처즈(Martin Richards)는 이를 단순화한 **BCPL**을 개발했고, BCPL은 실제 운영체제 구현에 활용될 만큼 충분히 간결하고 강력했다.

켄 톰슨(Ken Thompson)은 BCPL을 더 간단하게 줄여 **B 언어**를 만들었고, UNIX 초기 버전은 이 B 언어로 작성되었다. 하지만 B는 정수 외의 자료형이 부족하고 구조적 제어가 약했다. UNIX의 확장성과 유지보수성 향상을 위해선 더 강력한 언어가 필요했다.

결국 데니스 리치는 B 언어를 기반으로 새롭게 설계한 언어, **C 언어**를 탄생시킨다. 자료형, 포인터, 배열, 구조체, 연산자 우선순위 등 현대 C의 기초 개념이 이 시점에 정립된다.

📊 **언어 계보 요약**

| 시기  | 언어    | 개발자         | 비고                                           |
| ----- | ------- | -------------- | ---------------------------------------------- |
| 1966  | BCPL    | 마틴 리처즈    | B 언어의 직접적 선행자                         |
| 1969  | B       | 켄 톰슨        | UNIX 초기 구현, 구조 부족                      |
| 1972  | C       | 데니스 리치    | UNIX 커널을 완전히 이식하는 데 성공            |
| 1978  | K&R C   | 커니핸 & 리치  | 《The C Programming Language》 출간            |
| 1989  | ANSI C  | ANSI 표준 제정 | 함수 원형과 표준 라이브러리 체계화             |
| 1999~ | C99~C23 | ISO            | 현대적 기능 추가, 스레드, 원자성, 타입 추론 등 |

#### 🧠 UNIX와 C의 결정적 연결

초기 UNIX는 어셈블리어로 작성되었지만, 이는 유지보수가 어렵고 하드웨어에 종속적이었다. C 언어는 고급 언어로서 **제어 흐름**, **메모리 접근**, **컴파일 성능**을 제공하면서도, **직접적인 하드웨어 제어가 가능했다**. 이는 UNIX를 C로 재작성하게 만든 결정적 이유였다.

C로 다시 작성된 UNIX는 곧바로 다양한 플랫폼으로 이식되었고, 그 과정에서 C는 세계적으로 확산되기 시작한다. 특히 학계와 공공기관에서 UNIX와 함께 C가 채택되며, 프로그래밍 교육의 표준으로 자리 잡는다.

#### 📖 표준화와 발전

1978년, 커니핸과 리치는 《The C Programming Language》라는 책을 출간했다. 이 책은 C 문법의 사실상 표준을 정의하였고, 이를 **K&R C**라고 부른다.

이후 ANSI는 1983년 C 언어 표준화 작업을 시작하여 1989년 **ANSI C(C89)**를 제정한다. ISO는 1990년에 이를 국제 표준(C90)으로 승인하였다. 이후 C는 다음과 같은 주요 확장을 거친다.

🧾 **C 표준의 주요 흐름**

- **C89 / C90**: 함수 원형(prototype), 표준 라이브러리 통일
- **C99**: `//` 주석, `long long`, `inline`, 복합 리터럴, `stdint.h`, `stdbool.h`
- **C11**: `_Atomic`, `_Static_assert`, 멀티스레드 환경 대응
- **C17**: C11의 안정화, 기능 변화 없음
- **C23 (예정)**: 진법 표기 `0b`, 문자열 리터럴 확장, 타입 추론 등 현대적 기능 반영

#### 🌐 다른 언어에 끼친 영향

C는 그 자체로도 위대한 언어지만, 더 큰 영향력은 **다른 언어의 설계 기반이 되었다는 점**이다.

- **C++**는 C를 확장하여 객체지향을 도입
- **Java, C#, Go**는 문법 구조와 메모리 모델에서 C의 철학을 계승
- **Python, Lua** 등은 내부 구현이 C로 작성되어 있으며, 대부분의 인터프리터와 가상머신도 C 기반
- **LLVM**, **GCC**, **리눅스 커널**, **Git** 등도 모두 C로 작성됨

🧩 C 언어는 단순한 프로그래밍 언어가 아니다.
 시스템과 하드웨어, 운영체제, 메모리, 프로세서 구조, 컴파일러 동작 원리에 이르기까지, 현대 컴퓨터 과학의 핵심 메커니즘을 직접 다루는 유일한 고급 언어다.
 이 언어를 학습하는 것은 단순한 코딩 능력이 아니라, **시스템 전체를 통제할 수 있는 기술적 사고**를 기르는 과정이다.

## 구조적 프로그래밍의 개념

구조적 프로그래밍(structured programming)은 프로그램의 흐름을 **논리적 제어 구조**로 나누어 구성하는 프로그래밍 패러다임이다. 이 방식은 1960년대 말, 스파게티 코드로 불리는 무질서한 분기 흐름(goto 남용)의 한계를 극복하기 위해 제안되었으며, **코드의 명확성, 예측 가능성, 유지보수성**을 높이는 데 목적이 있다.

C 언어는 이러한 구조적 프로그래밍 개념을 가장 전형적으로 구현한 대표 언어다.
 다음 세 가지 제어 구조가 구조적 프로그래밍의 핵심이다.

### 🔁 순차(Sequence)

- **모든 명령은 위에서 아래로 차례대로 실행된다.**
- 특별한 흐름 제어 없이 순서대로 동작하는 기본 실행 단위

```
int a = 3;
int b = 5;
int sum = a + b;
```

이 코드에서는 변수 선언 → 덧셈 → 결과 저장이 순차적으로 실행된다.

### 🔀 선택(Selection)

- **조건에 따라 특정 블록을 선택적으로 실행한다.**
- `if`, `if-else`, `switch-case` 등이 이에 해당한다.

```
if (score >= 60) {
    printf("합격\n");
} else {
    printf("불합격\n");
}
```

조건문의 구조를 통해 프로그램의 실행 경로가 분기되며, 특정 상황에서만 코드가 실행되도록 한다.

### 🔁 반복(Iteration)

- **조건을 만족하는 동안 코드를 반복 실행한다.**
- `while`, `for`, `do-while` 등 반복 제어 구조를 사용한다.

```
for (int i = 0; i < 10; i++) {
    printf("%d\n", i);
}
```

반복 구조는 일정한 규칙이나 조건 하에 코드를 반복함으로써 불필요한 중복을 제거하고 효율을 높인다.

### 🔧 특징 및 이점

- **모듈화**
   각 기능을 함수로 나눠 재사용성과 테스트 용이성이 증가한다.
- **읽기 쉬운 코드 구조**
   블록 단위 제어와 중첩 제한을 통해 흐름을 명확하게 파악할 수 있다.
- **디버깅과 유지보수 용이**
   구조화된 흐름은 디버깅 시 프로그램 상태를 예측 가능하게 만든다.
- **수학적 검증 가능성**
   구조적 프로그래밍은 이론적으로 루프 불변 조건과 상태 전이를 통해 수학적으로 검증 가능하다.

📌 참고: 1968년, 에츠허르 다이크스트라(Edsger Dijkstra)는 "Go To Statement Considered Harmful"이라는 에세이를 통해 구조적 프로그래밍을 옹호하며 `goto` 남용에 반대했고, 이는 이후 현대 언어 설계에 지대한 영향을 주었다. C 언어에서도 `goto`는 존재하지만 구조적 흐름 제어를 우선시하도록 권장된다.

🧩 구조적 프로그래밍은 단지 코드 작성을 "깔끔하게" 하는 방법이 아니라, **프로그램을 논리적으로 설계하고 예측 가능하게 만드는 사고방식**이다.
 C 언어는 이를 실제 문법으로 실현한 첫 주류 언어이며, 이후 파생된 수많은 언어들의 흐름 제어 구조는 이 개념을 그대로 계승하고 있다.

## 절차지향과 C 언어의 특징

C 언어는 대표적인 **절차지향 프로그래밍(procedural programming)** 언어다. 절차지향은 구조적 프로그래밍과 깊은 연관을 가지며, 프로그램을 하나의 흐름(sequence)으로 보고 이를 **단계적 절차**로 구성하여 문제를 해결하는 방식이다. 모든 연산은 순서에 따라 이루어지며, 각 기능은 **명령(문)**들의 **집합인 함수(function)**로 구성된다.

### ⚙️ 절차지향 프로그래밍의 핵심 개념

- 프로그램을 **입력 → 처리 → 출력**의 흐름으로 보고, 문제 해결 과정을 순서대로 나눈다
- 데이터를 중심으로 하지 않고, **작업(절차) 중심**으로 프로그램을 구성한다
- 기능별로 **모듈화된 함수**를 만들어 호출하며, 전체 프로그램은 이 함수들의 호출 흐름으로 구성된다
- 상태(state)는 주로 전역 변수와 함수 간 매개변수 전달을 통해 공유된다

### 💡 C 언어가 절차지향 언어인 이유

1. **모든 코드의 기본 단위는 함수다**
    `main()` 함수는 필수이며, 그 외의 로직도 함수 단위로 정의하고 호출한다.
    재귀 호출, 값 전달, 포인터를 통한 참조 전달 등을 통해 함수 간 제어 흐름을 설계한다.
2. **함수는 명확한 절차의 흐름을 나타낸다**
    예를 들어 `입력 → 계산 → 출력`과 같은 3단계 처리를 각각 `input()`, `process()`, `output()`이라는 함수로 나누는 방식은 절차지향 구조의 전형이다.
3. **데이터와 함수를 분리한다**
    객체지향 언어에서는 데이터와 메서드가 하나의 객체로 묶이지만, C에서는 구조체(`struct`)가 데이터만 담고, 함수는 별도로 존재한다.
    구조체는 데이터 그 자체일 뿐, 그 안에 기능이 포함되지 않는다.

### 🧩 C 언어의 절차지향적 특징 요약

| 특징                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 함수 기반 구조         | 프로그램은 main()을 중심으로 함수의 절차적 호출로 구성된다   |
| 순차적 실행 흐름       | 코드 실행은 위에서 아래로 흐르고, 조건문과 반복문으로 분기된다 |
| 데이터와 기능의 분리   | 데이터 구조와 연산 로직이 명확히 분리되어 있다               |
| 전역/지역 변수 사용    | 함수 간 데이터 전달은 주로 매개변수 또는 전역 변수를 통해 이루어진다 |
| 구조적 프로그래밍 수용 | if, for, while, switch 등 구조적 제어문 제공                 |

### 🚫 한계점도 존재한다

절차지향 언어는 프로그램이 커질수록 **데이터 관리가 어렵고**, **상태 공유가 불안정해지며**, **코드 재사용성과 유지보수성이 떨어질 수 있다**. 이러한 문제점은 C++이나 Java 등 **객체지향 언어(Object-Oriented Programming)**가 등장한 배경이 되었다.

하지만 C는 여전히 절차지향의 장점을 극대화하여

- 성능 중심의 시스템 프로그래밍
- 명확한 실행 흐름이 필요한 임베디드/펌웨어 코드
- 리소스 제약이 있는 환경에서의 정밀 제어
   와 같은 분야에서 뛰어난 적합성을 가진다.

🧠 결론적으로 C는 절차지향 프로그래밍의 철학을 완전히 구현한 언어이자,
 동시에 구조적 제어와 저수준 시스템 제어를 모두 가능하게 하는 **정교한 절차지향 시스템 언어**다.
 이 특성은 이후 등장하는 수많은 언어(C++, Java, Python 등)의 설계 기초가 되었으며,
 현대 컴퓨팅의 근간을 형성하는 데 결정적인 역할을 수행했다.

## 컴파일 및 실행 과정 (전처리, 컴파일, 어셈블, 링킹)

C 언어는 **컴파일러 기반 정적 언어**이며, 프로그램이 실행되기까지 여러 단계를 거쳐 **소스 코드 → 실행 파일**로 변환된다. 이 과정은 내부적으로 다음 네 단계로 구성된다:

> 전처리 → 컴파일 → 어셈블 → 링킹

각 단계를 이해하는 것은 C 언어의 구조와 동작 원리를 정확히 파악하는 데 필수적이다.

### 🧩 1. 전처리 (Preprocessing)

- 확장자: `.c` → `.i`
- 수행 명령: `gcc -E source.c -o source.i`
- 역할: **전처리 지시문을 처리하고 소스 코드 확장**

전처리기는 `#include`, `#define`, `#ifdef` 등으로 시작하는 전처리 지시문을 처리한다.
 헤더 파일의 내용을 삽입하고, 매크로를 치환하며, 조건부 컴파일 구문을 해석한다.

```
#include <stdio.h>   // stdio.h 전체 내용이 삽입됨
#define PI 3.14      // 이후 PI는 모두 3.14로 치환됨
```

이 단계의 결과는 **순수한 C 코드로 확장된 파일**이다.
 이제 컴파일러가 이 코드를 해석할 수 있다.

### ⚙️ 2. 컴파일 (Compilation)

- 확장자: `.i` → `.s`
- 수행 명령: `gcc -S source.i -o source.s`
- 역할: **전처리된 C 코드 → 어셈블리 코드 변환**

컴파일러는 전처리 결과를 받아서 **어셈블리어(Assembly Language)** 코드로 변환한다.
 이 단계에서 **문법 오류가 검출되며**, **C의 고급 문법이 저수준 명령으로 변환된다**.

예를 들어 `int a = 3 + 5;`는 다음과 같은 어셈블리 코드로 변환된다 (플랫폼에 따라 다름).

```
movl $8, -4(%rbp)   ; 변수 a에 8 저장
```

### 🧱 3. 어셈블 (Assembly)

- 확장자: `.s` → `.o` 또는 `.obj`
- 수행 명령: `gcc -c source.s -o source.o`
- 역할: **어셈블리 코드 → 기계어(바이너리)로 변환**

어셈블러는 어셈블리 코드를 해석하여 CPU가 직접 실행할 수 있는 **목적 코드(Object Code)**로 바꾼다.
 이 목적 파일은 아직 **단일 파일 단위**이며, 실행은 불가능하다. 외부 심볼, 라이브러리 등은 연결되지 않은 상태다.

### 🔗 4. 링킹 (Linking)

- 확장자: `.o` + 기타 → 실행 파일 (`.out`, `.exe`, ELF 등)
- 수행 명령: `gcc source.o -o executable`
- 역할: **여러 목적 파일 + 라이브러리 → 단일 실행 가능한 바이너리 생성**

링커는 다음 작업을 수행한다:

- `main()` 등 사용자 정의 함수의 위치 연결
- `printf()`, `malloc()` 등 외부 함수의 실제 구현 주소 연결
- 전역 변수 참조 연결
- 필요 시 표준 라이브러리 링크 (예: `libc`)

링킹 결과로 생성되는 실행 파일은 운영체제에서 로드 가능한 최종 결과물이다.
 UNIX 계열에선 일반적으로 `a.out`, `실행파일`, 또는 ELF(Executable and Linkable Format) 형식으로 생성된다.

### 🧠 요약: 전체 흐름

| 단계   | 입력     | 출력     | 핵심 역할                        |
| ------ | -------- | -------- | -------------------------------- |
| 전처리 | source.c | source.i | 매크로 확장, 헤더 삽입           |
| 컴파일 | source.i | source.s | 고급 C 코드 → 어셈블리 코드 변환 |
| 어셈블 | source.s | source.o | 어셈블리 코드 → 목적 파일        |
| 링킹   | source.o | 실행파일 | 목적 파일과 라이브러리 연결      |

### 🛠️ 실습 예시 (GCC 기준)

```
gcc -E hello.c -o hello.i      # 전처리
gcc -S hello.i -o hello.s      # 컴파일
gcc -c hello.s -o hello.o      # 어셈블
gcc hello.o -o hello           # 링킹
```

📌 보통 `gcc hello.c -o hello` 한 줄 명령어로 위의 모든 단계를 자동 수행한다.
 하지만 각 단계를 수동으로 실행하면 **빌드의 내부 구조와 오류의 위치를 명확히 파악**할 수 있다.

이 과정을 정확히 이해하는 것은 단순히 컴파일러 사용법을 넘어서,
 **시스템이 소스 코드를 어떻게 해석하고 실행 파일로 변환하는지**에 대한 본질적인 통찰로 이어진다.
 이는 디버깅, 최적화, 리버스 엔지니어링, 컴파일러 설계까지도 포괄하는 핵심 지식이다.

## C 언어와 C++ 및 Java의 구조 비교

C, C++, Java는 모두 구조적 문법을 공유하지만, **언어의 철학**, **메모리 모델**, **실행 환경**, **추상화 계층**에서 근본적인 차이를 가진다. 이 비교는 C 언어를 학습하는 데 있어 현대 언어의 관점에서 C가 어떤 위치에 있으며, 어떤 역할을 수행하는지 이해하는 데 도움이 된다.

### 🔧 기본 성격

| 항목        | C                                    | C++                                   | Java                            |
| ----------- | ------------------------------------ | ------------------------------------- | ------------------------------- |
| 분류        | 절차지향 (Procedural)                | 다중 패러다임 (객체지향 + 절차지향)   | 객체지향 (Object-Oriented)      |
| 설계 철학   | 시스템 프로그래밍을 위한 저수준 제어 | C의 확장 + 고급 언어 기능             | 플랫폼 독립성, 안전한 실행 환경 |
| 실행 대상   | 기계어 (native)                      | 기계어 (native)                       | 바이트코드 (JVM에서 실행)       |
| 메모리 제어 | 수동 (포인터, malloc/free)           | 수동 + 자동화 가능 (new/delete, RAII) | 자동 (Garbage Collection)       |

### 🔩 메모리 관리

C는 **명시적인 메모리 관리**를 전제로 한다.
 포인터, malloc/free 등의 수동 제어가 핵심이다.

```
int *ptr = (int*) malloc(sizeof(int));
*ptr = 42;
free(ptr);
```

C++는 포인터와 new/delete 외에 **스택 기반 객체 관리**, **RAII(Resource Acquisition Is Initialization)** 등의 자동화 기법도 제공한다.

```
std::vector<int> vec = {1, 2, 3}; // 소멸자 자동 호출
```

Java는 완전한 **가비지 컬렉션(GC)** 기반이다. 객체는 `new`로 생성하며, 명시적인 해제가 불가능하다.

```
String name = new String("hello");
```

### 🧠 언어 구조 및 특징 요약

| 요소          | C                         | C++                              | Java                                |
| ------------- | ------------------------- | -------------------------------- | ----------------------------------- |
| 함수 중심     | ✅ 모든 기능은 함수로 구성 | ✅ 함수 + 클래스/객체 기반        | ❌ 함수는 클래스 내부에서만 정의     |
| 포인터 지원   | ✅ 완전한 포인터 연산 허용 | ✅ 포인터 있음, 제한적 사용       | ❌ 포인터 개념 없음 (참조만 존재)    |
| 구조체의 기능 | 단순 데이터 집합          | 클래스, 접근제어자, 상속 등 지원 | 클래스 중심, 모든 것이 객체         |
| 예외 처리     | 없음                      | try-catch, throw 지원            | try-catch, throws, 예외 계층 구조   |
| 템플릿/제네릭 | 없음                      | 템플릿 (Compile-time)            | 제네릭 (Runtime Type Erasure)       |
| 다형성/상속   | 없음                      | 클래스 상속, 다형성, 가상 함수   | 클래스 상속, 인터페이스, 오버라이딩 |

### ☕ 실행 환경 비교

C와 C++은 **시스템 종속적인 기계어로 컴파일**된다. 실행 파일은 OS 및 아키텍처에 직접 종속된다.
 Java는 바이트코드로 컴파일되어 **JVM(Java Virtual Machine)**이라는 추상화 계층 위에서 실행되며, 플랫폼 독립성을 보장한다.

| 항목        | C / C++ 실행         | Java 실행                     |
| ----------- | -------------------- | ----------------------------- |
| 컴파일 대상 | 기계어               | 바이트코드                    |
| 실행 방식   | OS에서 직접 실행     | JVM이 해석하거나 JIT 컴파일   |
| 이식성      | 낮음 (재컴파일 필요) | 높음 (JVM만 있으면 실행 가능) |

### 📌 정리

- **C**는 가장 단순하고 강력한 언어 중 하나로, 시스템 레벨 제어에 최적화되어 있다.
- **C++**는 C를 기반으로 객체지향과 고급 추상화를 지원하며, 성능과 구조화의 균형을 추구한다.
- **Java**는 완전한 객체지향 언어로서, 안전성과 이식성을 중심으로 설계되었고, GC 기반의 고수준 런타임을 제공한다.

🧩 C 언어는 하드웨어 제어와 메모리 관리를 직접 다룰 수 있는 **가장 얇은 추상화 계층의 고급 언어**다.
 C++와 Java는 C의 기초 위에 **추상화와 편의성, 안정성**을 덧붙인 언어이며, 구조의 복잡성이 증가할수록 C의 핵심 철학은 더 또렷하게 드러난다.

# 1.2 개발 환경 구축

## 운영체제별 컴파일러 설치 (Windows: MinGW, Linux: GCC, macOS: Clang)

C 언어는 플랫폼 독립적인 언어지만, 실제 실행을 위해선 해당 운영체제와 아키텍처에 맞는 **컴파일러 툴체인**이 필요하다. 운영체제마다 기본적으로 사용하는 컴파일러와 설치 방식이 다르다. 아래는 주요 3대 운영체제에서 C 컴파일러를 설치하고 구성하는 방법을 정리한 것이다.

### 🪟 Windows: MinGW (Minimalist GNU for Windows)

**MinGW**는 Windows에서 사용할 수 있는 GCC(GNU Compiler Collection)의 윈도우 이식 버전이다. POSIX 환경은 아니지만, 기본적인 C/C++ 컴파일과 실행이 가능하다.

📦 설치 방법

1. MinGW 공식 설치 관리자 다운로드

2. 설치 중 `mingw32-gcc-g++`, `mingw32-gcc-objc`, `mingw32-base`, `msys-base` 등을 선택

3. 설치 후 환경변수 설정

   - `C:\MinGW\bin`을 `PATH`에 추가

4. 설치 확인

   ```
   gcc --version
   ```

🧪 예제 빌드

```
gcc hello.c -o hello.exe
./hello.exe
```

💡 대안

- **TDM-GCC**: 보다 안정적인 GCC 배포판
- **WSL + GCC**: Windows Subsystem for Linux에서 Linux 환경 그대로 사용 가능

### 🐧 Linux: GCC (GNU Compiler Collection)

리눅스 대부분의 배포판은 기본적으로 **GCC**를 포함하거나 공식 저장소에서 쉽게 설치할 수 있다.
 GCC는 C/C++뿐 아니라 Fortran, Ada 등도 지원하는 강력한 오픈소스 컴파일러다.

📦 설치 방법 (배포판별 예시)

**Debian / Ubuntu**

```
sudo apt update
sudo apt install build-essential
```

**Fedora / RHEL**

```
sudo dnf install gcc
```

**Arch Linux**

```
sudo pacman -S base-devel
```

설치 후 확인

```
gcc --version
```

🧪 예제 빌드

```
gcc hello.c -o hello
./hello
```

🔧 관련 툴

- `make`: 빌드 자동화 도구
- `gdb`: 디버거
- `valgrind`: 메모리 검사 도구

### 🍎 macOS: Clang (LLVM 기반 컴파일러)

macOS에서는 기본적으로 Apple이 제공하는 **Clang**이 표준 컴파일러로 사용된다.
 이는 GCC와 호환되도록 설계되어 대부분 동일한 명령어로 컴파일이 가능하다.

📦 설치 방법

1. 터미널에서 다음 명령 실행

   ```
   xcode-select --install
   ```

2. Xcode Command Line Tools가 설치되며 `clang` 사용 가능

설치 확인

```
clang --version
```

🧪 예제 빌드

```
clang hello.c -o hello
./hello
```

💡 LLVM/Clang은 GCC보다 컴파일 속도가 빠르고, 다양한 정적 분석 기능을 내장하고 있어 macOS뿐 아니라 현대적인 개발 환경에서 널리 사용된다.

### 🧠 요약 비교

| 항목        | Windows                        | Linux                       | macOS                    |
| ----------- | ------------------------------ | --------------------------- | ------------------------ |
| 주요 툴체인 | MinGW / TDM-GCC / WSL          | GCC (기본)                  | Clang (Xcode CLI)        |
| 설치 방식   | 설치 관리자 / 패키지 수동 설정 | 패키지 관리자 (apt, dnf 등) | `xcode-select --install` |
| 컴파일 명령 | `gcc hello.c -o hello.exe`     | `gcc hello.c -o hello`      | `clang hello.c -o hello` |
| 실행 방식   | `hello.exe`                    | `./hello`                   | `./hello`                |

C 언어는 다양한 플랫폼에서 거의 동일한 문법으로 작동하지만,
 **컴파일러와 운영체제 레벨의 차이**는 실행 파일의 형식, 라이브러리 링크 방식, 디버깅 도구에서 큰 차이를 만든다.
 각 운영체제에 적합한 컴파일 환경을 이해하고 직접 구축해보는 것은 시스템 수준 프로그래밍 역량의 기초가 된다.

## 통합 개발 환경 (IDE) 구성 (Code::Blocks, Visual Studio, CLion 등)

C 언어는 명령줄에서 컴파일러(gcc, clang 등)를 직접 사용해도 충분하지만, 복잡한 프로젝트에서는 **통합 개발 환경(IDE, Integrated Development Environment)**이 코드 작성, 컴파일, 디버깅, 프로젝트 관리까지 한 곳에서 가능하도록 해준다. 특히 대규모 소스 코드나 디버깅, 빌드 설정이 반복되는 작업에서는 IDE의 이점이 분명하다.

### 🧱 Code::Blocks

- 💡 **특징**: 가볍고 빠르며 C/C++에 특화된 무료 IDE
- ⚙️ **운영체제**: Windows, Linux, macOS
- 🔧 **컴파일러**: 기본적으로 MinGW나 GCC와 연동됨

📦 설치

1. 공식 다운로드 페이지에서 “with MinGW” 버전 선택
2. 설치 후 첫 실행 시 자동으로 컴파일러 탐색
3. 프로젝트 생성 시 C 콘솔 응용프로그램 선택 → 코드 작성 가능

🛠️ 기능

- 자동 완성, 프로젝트 빌더, 디버거 통합
- makefile 없이도 GUI로 빌드 설정 가능
- 외부 툴 연동(gdb, gprof 등)

### 🧠 Visual Studio (Windows 전용)

- 💡 **특징**: Microsoft에서 제공하는 강력한 Windows 기반 IDE
- ⚙️ **운영체제**: Windows
- 🔧 **컴파일러**: MSVC (Microsoft Visual C/C++ Compiler)

📦 설치

1. [Visual Studio 설치 페이지](https://visualstudio.microsoft.com/)에서 Community Edition 다운로드
2. 설치 시 "C++ 데스크톱 개발" 워크로드 선택
3. 설치 완료 후 `.c` 파일 새 프로젝트로 작성

🛠️ 기능

- 강력한 디버깅 UI (Watch, Call Stack, Memory View)
- 코드 리팩토링, 정적 분석, 빌드 프로파일링 등 지원
- MSVC 컴파일러 기반으로 Windows API 개발에 유리함

⚠️ 참고
 Visual Studio는 C를 C++ 프로젝트 내부에서 작성하게 하므로, `.c` 파일을 만들 경우 명시적으로 C 컴파일로 설정해야 한다.

### 💼 CLion (JetBrains)

- 💡 **특징**: JetBrains가 만든 프리미엄 C/C++ IDE. 코드 인텔리전스와 디버깅에 강함
- ⚙️ **운영체제**: Windows, Linux, macOS
- 🔧 **컴파일러**: GCC, Clang, MSVC 중 선택 가능
- 📁 **빌드 시스템**: CMake 필수 (기본 빌드 시스템)

📦 설치

1. [CLion 공식 홈페이지](https://www.jetbrains.com/clion/)에서 다운로드
2. 설치 후 GCC, Clang, MSVC 등 시스템에 설치된 컴파일러 자동 인식
3. CMake 기반으로 프로젝트 구성

🛠️ 기능

- 매우 정교한 코드 자동 완성, 네비게이션
- 중단점 설정, 변수 실시간 추적 등 고급 디버깅
- Remote Toolchain, WSL, Docker 연동 가능
- VCS(Git 등) 완전 통합

💰 라이선스

- 유료(학생, 오픈소스 개발자 무료 플랜 존재)

### 🧪 그 외 IDE들

| IDE 이름          | 특징                                                 | 비고                                 |
| ----------------- | ---------------------------------------------------- | ------------------------------------ |
| Eclipse CDT       | Eclipse 기반. 플러그인 구조로 유연.                  | 다소 무거움                          |
| Dev-C++ (TDM-GCC) | 오래된 구조지만 단순하고 입문자에게 적합             | 유지보수 중단됨에 주의               |
| VS Code           | 가벼운 편집기 + 확장 플러그인으로 IDE 수준 구성 가능 | `C/C++ Extension`, `Tasks.json` 필요 |
| Xcode             | macOS 전용. Clang 기반 GUI 개발 포함                 | Apple 플랫폼 개발에 최적화           |

### 📌 IDE 선택 기준 요약

| 상황                               | 추천 IDE            |
| ---------------------------------- | ------------------- |
| 입문자, 단순 콘솔 실행             | Code::Blocks        |
| Windows 전용, WinAPI, DirectX 개발 | Visual Studio       |
| 고급 기능, 멀티플랫폼, 디버깅 강화 | CLion               |
| 무료 경량 환경, CLI 친화           | VS Code + GCC/Clang |

🧠 통합 개발 환경은 단순한 편집기 그 이상이다.
 빌드 구성, 컴파일러 플래그, 헤더 탐색, 의존성 해석, 디버깅, 버전 관리 연동 등
 **실제 개발자의 전체 워크플로우를 조직화하는 핵심 도구**다.
 언어 자체와 함께 IDE의 메커니즘을 파악하는 것은 개발 효율성뿐 아니라 **대규모 프로젝트의 유지보수 능력**을 기르는 데 결정적이다.

## 명령행 기반 컴파일 및 실행

C 언어는 가장 기본적인 형태로 **텍스트 편집기 + 명령행 컴파일러**만으로도 전 과정이 수행 가능하다. GUI 없이 **터미널(명령 프롬프트, 쉘)**에서 코드를 작성하고 직접 컴파일하고 실행하는 방식은 **언어의 구조와 빌드 과정을 체계적으로 이해하는 데 필수적**이다.

### 📝 1. 소스 코드 작성

아래는 가장 단순한 C 프로그램 예시이다.

```
// 파일명: hello.c
#include <stdio.h>

int main() {
    printf("Hello, world!\n");
    return 0;
}
```

이 파일을 일반 텍스트 편집기(예: Notepad, nano, vim, VSCode 등)로 작성한 후 저장한다.

### 🧰 2. 컴파일 명령 (GCC 기준)

터미널 또는 명령 프롬프트를 열고 아래와 같이 입력한다.

```
gcc hello.c -o hello
```

🧩 구성 요소 해석

- `gcc`: GNU Compiler Collection
- `hello.c`: 입력 파일 (소스 코드)
- `-o hello`: 출력 파일 이름을 `hello`로 지정

📦 결과

- `hello` (Linux/macOS) 또는 `hello.exe` (Windows) 실행 파일 생성

### ▶️ 3. 실행 명령

운영체제에 따라 실행 방법이 다르다.

**Linux / macOS**

```
./hello
```

**Windows**

```
hello.exe
```

실행 결과:

```
Hello, world!
```

### 🧪 컴파일 옵션 활용 예시

**디버깅 정보 포함**

```
gcc -g hello.c -o hello
```

**모든 경고 출력**

```
gcc -Wall hello.c -o hello
```

**C 표준 명시 (예: C99)**

```
gcc -std=c99 hello.c -o hello
```

**전처리 결과만 출력**

```
gcc -E hello.c
```

**어셈블리 코드 생성**

```
gcc -S hello.c
```

**목적 파일만 생성**

```
gcc -c hello.c
```

### 🧠 권장 학습 흐름

1. `.c` 파일 작성
2. `gcc` 명령으로 컴파일
3. `./파일명`으로 직접 실행
4. `-Wall`, `-g`, `-std=` 등의 옵션을 순차적으로 적용
5. 에러 발생 시 컴파일러 메시지를 정확히 해석하고 수정
6. 다중 소스 파일을 `gcc file1.c file2.c -o app`처럼 직접 링크하여 구조 이해

🧩 명령행 컴파일은 단순한 실행 방법 이상의 의미를 가진다.
 이는 C 언어의 **빌드 시스템 구조, 링커의 작동 방식, 컴파일러 최적화 플래그** 등의 기초를 실전으로 익히는 절차이며, IDE 환경에서도 근본적으로는 동일한 과정을 자동화할 뿐이다.
 직접 컴파일하고 실행하는 습관은 디버깅, 퍼포먼스 분석, 크로스 컴파일 등 심화 영역으로 진입할 수 있는 발판이 된다.

# 1.3 기본 문법 구성

## main 함수 구조와 반환형

C 프로그램의 실행은 반드시 **`main()` 함수에서 시작된다.** 이 함수는 운영체제가 프로그램을 시작할 때 호출하는 진입점(entry point)이며, 종료 시에는 결과 값을 운영체제에 반환한다. 따라서 `main()` 함수는 **C 언어 프로그램의 필수 구성 요소**이며, 문법적으로나 실행적으로 가장 중요한 함수다.

### 🔧 기본 구조

```
#include <stdio.h>

int main() {
    // 프로그램의 본문
    return 0;
}
```

#### 🧩 구성 요소 설명

- `int`: main 함수의 반환형. 실행 종료 상태를 의미하며 반드시 **정수형**이어야 한다.
- `main`: 함수 이름. 운영체제가 이 이름을 통해 시작점을 찾는다.
- `()` : 매개변수 없이 시작. 또는 `int argc, char *argv[]`로 인자 처리 가능.
- `{ ... }`: 함수 본문. 실제 실행될 코드가 여기에 위치한다.
- `return 0;`: 프로그램이 정상 종료되었음을 운영체제에 알림. 다른 값은 오류 코드로 간주된다.

### 📥 매개변수 버전 (명령행 인자 처리)

```
int main(int argc, char *argv[]) {
    // argc: 전달된 인자의 개수
    // argv: 각 인자의 문자열 배열
    return 0;
}
```

예를 들어, 실행 시 다음과 같이 입력하면

```
./program hello world
```

값은 다음과 같이 전달된다:

- `argc == 3`
- `argv[0] == "./program"`
- `argv[1] == "hello"`
- `argv[2] == "world"`

🧠 이 구조는 CLI 프로그램에서 사용자 입력을 받아 처리할 때 매우 유용하다.

### 🛠️ 반환값 의미

- `return 0;` → **정상 종료 (success)**
- `return 1;`, `return -1;` 등 → **비정상 종료 (failure)**

운영체제 또는 쉘 스크립트는 종료 코드를 확인하여 **프로세스 성공 여부**를 판단한다.

```
./myprogram
echo $?  # 종료 코드 출력
```

이는 시스템 자동화, 배치 처리, 조건 분기 등에 사용된다.

### 🔍 확장 예제: 인자 출력 프로그램

```
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("인자 개수: %d\n", argc);
    for (int i = 0; i < argc; i++) {
        printf("argv[%d]: %s\n", i, argv[i]);
    }
    return 0;
}
```

실행 결과:

```
$ ./a.out input.txt config.json
인자 개수: 3
argv[0]: ./a.out
argv[1]: input.txt
argv[2]: config.json
```

### ✅ 정리

| 항목             | 설명                                                 |
| ---------------- | ---------------------------------------------------- |
| 함수 이름        | `main` (필수)                                        |
| 반환형           | `int` (필수)                                         |
| 매개변수         | 없음 또는 `(int argc, char *argv[])` 사용 가능       |
| 종료 시 `return` | 종료 상태 반환. `0`은 정상, 비0은 오류 코드로 해석됨 |

📌 C에서는 `main()`이 유일하게 자동으로 호출되는 함수이며,
 운영체제는 프로그램 종료 후 이 함수의 반환 값을 기준으로 성공 또는 실패를 판단한다.
 반환형, 매개변수, 종료 코드의 의미를 정확히 이해하는 것은 **운영체제와 프로그램 간의 인터페이스를 이해하는 핵심 지식**이다.

## 주석 처리 방식 (`//`, `/* */`)

C 언어에서 주석(comment)은 **프로그램 실행에는 영향을 주지 않지만, 코드의 의도나 설명을 기록하는 데 사용된다.** 주석은 컴파일러에 의해 무시되며, 코드의 가독성과 유지보수성을 높이는 데 중요한 역할을 한다.

C 언어는 두 가지 주석 문법을 제공한다.

### 🔹 한 줄 주석 (`//`)

C99 표준부터 도입된 방식으로, **한 줄 전체를 주석 처리**할 때 사용한다.

```
int x = 5;  // 변수 x를 5로 초기화
```

- `//` 이후부터 해당 줄 끝까지가 주석으로 간주됨
- 가독성이 뛰어나고, 코드 옆에 간단한 설명을 붙이기에 적합
- 다중 줄 주석에는 부적합

### 🔸 다중 줄 주석 (`/* ... */`)

C 초창기부터 존재한 전통적인 주석 방식으로, **여러 줄에 걸친 블록 주석**을 처리할 수 있다.

```
/* 
  이 프로그램은
  사용자로부터 입력을 받아
  값을 출력하는 기능을 수행한다.
*/
```

- `/*`로 시작하여 `*/`로 종료되며, 그 사이 모든 내용이 주석 처리됨
- 줄 수에 관계없이 사용 가능
- 중첩은 불가능 (다중 줄 주석 내부에 다시 `/* */`를 사용할 수 없음)

```
/* 
  오류 발생 예:
  /* 중첩된 주석은 허용되지 않음 */
*/
```

### 🧠 사용 예시

#### 변수 정의에 간단한 주석

```
int temperature = 25; // 섭씨 단위
```

#### 함수 블록 설명

```
/*
 * calculate_area 함수
 * 매개변수: width, height
 * 반환값: 직사각형의 넓이
 */
int calculate_area(int width, int height) {
    return width * height;
}
```

### ⚠️ 주의 사항

- `/* */` 주석 내부에 다시 `/* */`를 넣으면 컴파일 에러 발생
- `//`는 C99부터 지원되므로, 오래된 컴파일러에서는 오류가 날 수 있음
- 실수로 `*/`를 빠뜨릴 경우, 이후 전체 코드가 주석 처리되어 컴파일러 오류 발생 가능

### ✅ 요약

| 구문    | 사용 목적               | 장점                              | 단점                                     |
| ------- | ----------------------- | --------------------------------- | ---------------------------------------- |
| `//`    | 한 줄 설명              | 간단하고 읽기 쉬움                | 여러 줄에 사용 시 반복 필요              |
| `/* */` | 여러 줄 설명, 블록 주석 | 긴 설명, 함수/모듈 단위 주석 가능 | 중첩 불가, 실수 시 전체 코드 무력화 위험 |

🧩 주석은 단지 설명이 아니다.
 코드에 **맥락(context)**을 부여하고, **협업과 유지보수**, **자기 자신과의 대화**를 가능하게 하는 중요한 요소다.
 특히 C처럼 추상화가 적은 언어에서는 주석이 **설계 의도**를 보존하는 거의 유일한 도구가 될 수 있다.

## 입출력 함수 (printf, scanf, puts, gets)

C 언어는 표준 라이브러리 `<stdio.h>`를 통해 기본적인 입출력 기능을 제공한다. 콘솔 기반 입출력에서 가장 많이 사용되는 함수는 `printf`, `scanf`, `puts`, `gets`이며, 이들은 모두 **표준 입력(stdin)** 또는 **표준 출력(stdout)**을 사용한다.

### 🖨️ `printf`: 포맷 문자열 기반 출력 함수

```
#include <stdio.h>

printf("Hello, world!\n");
```

- 형식 문자열(format string)을 기반으로 다양한 자료형을 출력할 수 있다.
- 문자열 내에 **서식 지정자(format specifier)**를 포함하고, 그 순서에 따라 인자를 전달한다.

🧩 주요 서식 지정자

| 서식 | 설명             | 예시 결과                        |
| ---- | ---------------- | -------------------------------- |
| `%d` | 10진수 정수      | `printf("%d", 42);` → `42`       |
| `%f` | 실수             | `printf("%.2f", 3.14);` → `3.14` |
| `%c` | 문자             | `printf("%c", 'A');` → `A`       |
| `%s` | 문자열           | `printf("%s", "Hi");` → `Hi`     |
| `%x` | 16진수 출력      | `printf("%x", 255);` → `ff`      |
| `%%` | 퍼센트 문자 출력 | `printf("%%");` → `%`            |

🧠 줄바꿈은 반드시 `\n`을 사용해야 한다. 자동으로 줄바꿈되지 않음.

### 🎮 `scanf`: 포맷 기반 입력 함수

```
int age;
scanf("%d", &age);
```

- 사용자로부터 값을 입력받고, 지정된 형식에 따라 해당 변수에 저장한다.
- 변수 **주소(&)** 를 반드시 전달해야 값을 저장할 수 있다.
- **공백 문자**를 기준으로 입력을 분리한다.

📌 기본 사용 시 주의

- 실수 입력: `scanf("%f", &x);`는 `float`에 저장, `double`은 `%lf` 사용
- 문자열 입력: `scanf("%s", str);`은 공백 이전까지만 입력 받음
- 입력 버퍼 문제로 `scanf()` 다음 `gets()` 또는 `fgets()` 사용 시 주의 필요

### 📢 `puts`: 줄바꿈 포함 문자열 출력

```
puts("Hello, C language!");
```

- 문자열을 출력하고 자동으로 줄바꿈 `\n`을 추가함
- 문자열 끝에 줄바꿈을 직접 넣을 필요 없음
- 문자열 외 다른 타입은 출력할 수 없음 (`%d`, `%f` 등 사용 불가)

🧠 내부적으로 `fputs(str, stdout); putchar('\n');`처럼 동작

### ⚠️ `gets`: **사용 금지 함수**

```
char name[100];
gets(name);  // 위험한 방식
```

- 한 줄 전체를 입력받을 수 있으나 **버퍼 오버플로우 위험이 크다**
- `gets()`는 입력 길이에 제한이 없어, 과도한 입력 시 메모리 침범이 발생할 수 있음
- C11 표준부터는 완전히 제거되었으며, **실무에서 절대 사용하지 않는다**

✅ 대체: `fgets()`

```
fgets(name, sizeof(name), stdin);
```

- 안전하게 최대 길이를 지정하여 문자열을 읽는다
- 줄바꿈 문자까지 함께 읽으므로 후처리 필요할 수 있음

### 📌 비교 요약

| 함수     | 용도               | 줄바꿈 자동 추가 | 형식 지정자 사용 | 버퍼 길이 지정 | 위험성          |
| -------- | ------------------ | ---------------- | ---------------- | -------------- | --------------- |
| `printf` | 형식화된 출력      | ❌                | ✅                | N/A            | 안전            |
| `scanf`  | 형식화된 입력      | ❌                | ✅                | ❌              | 중간 위험       |
| `puts`   | 문자열 출력        | ✅                | ❌                | ❌              | 안전            |
| `gets`   | 문자열 입력        | ❌                | ❌                | ❌              | ❌ **사용 금지** |
| `fgets`  | 안전한 문자열 입력 | ❌                | ❌                | ✅              | 권장 방식       |

🧠 입출력 함수는 단순히 콘솔과의 통신 수단이 아니라, **버퍼링, 포맷 해석, 타입 안전성** 등 언어 내부 구조와 밀접한 관련이 있다.
 초기에는 `printf`, `scanf`만으로 충분하지만, 실전에서는 `fgets`, `sscanf`, `snprintf` 등 더 안전하고 세밀한 함수로 확장하는 것이 바람직하다.

# 1.4 자료형과 메모리

## 정수형: char, short, int, long, long long

C 언어는 정수 데이터를 표현하기 위해 여러 가지 크기의 정수형 자료형을 제공한다. 각 자료형은 **저장할 수 있는 정수의 크기**와 **메모리 공간 크기**, **부호 여부**에 따라 구분된다. 정수형은 모든 시스템 프로그래밍에서 핵심이 되며, 하드웨어와 직접 맞닿는 저수준 처리에도 반드시 사용된다.

### 🔧 정수형 기본 목록

| 자료형      | 크기(바이트) | 표현 범위 (signed 기준)           | 비고                         |
| ----------- | ------------ | --------------------------------- | ---------------------------- |
| `char`      | 1 byte       | -128 ~ 127                        | 문자형이지만 정수로도 사용됨 |
| `short`     | 2 bytes      | -32,768 ~ 32,767                  | 작은 정수용                  |
| `int`       | 4 bytes      | -2,147,483,648 ~ 2,147,483,647    | 일반적인 정수 연산용         |
| `long`      | 4 or 8 bytes | 시스템에 따라 다름 (대개 8바이트) | 대용량 정수 연산에 사용      |
| `long long` | 8 bytes      | -9,223,372,036,854,775,808 ~ ...  | 아주 큰 정수 연산용          |

🧩 `char`, `short`, `int`, `long`, `long long`은 모두 내부적으로 정수(integer) 타입이다. 다만 저장 공간과 표현 가능한 범위가 다르기 때문에 용도에 맞게 선택해야 한다.

📌 참고: 크기와 범위는 **플랫폼, 컴파일러, 운영체제**에 따라 달라질 수 있다. 정확한 크기를 확인하려면 `sizeof()`를 사용할 것.

### ✳️ 부호(Sign)와 `unsigned`

모든 정수형은 기본적으로 **부호가 있는(signed)** 타입이다.
 하지만 `unsigned`를 명시하면 **음수 없이 양수 범위만 사용**하며, 그 대신 표현 가능한 최대값이 2배가 된다.

```
unsigned int x = 4294967295; // 4바이트에서 가능한 최대값
```

| 자료형      | 부호 있는 타입 예         | 부호 없는 타입 예    |
| ----------- | ------------------------- | -------------------- |
| 1 byte 정수 | `signed char` 또는 `char` | `unsigned char`      |
| 2 byte 정수 | `short`                   | `unsigned short`     |
| 4 byte 정수 | `int`                     | `unsigned int`       |
| 8 byte 정수 | `long long`               | `unsigned long long` |

### 🧪 크기 확인 코드

```
#include <stdio.h>

int main() {
    printf("char:       %lu bytes\n", sizeof(char));
    printf("short:      %lu bytes\n", sizeof(short));
    printf("int:        %lu bytes\n", sizeof(int));
    printf("long:       %lu bytes\n", sizeof(long));
    printf("long long:  %lu bytes\n", sizeof(long long));
    return 0;
}
```

📌 이 결과는 사용하는 플랫폼과 컴파일러에 따라 다를 수 있다.
 일반적으로는 32비트 vs 64비트 아키텍처에서 `long`의 크기가 달라짐.

### 📏 정수 리터럴 접미사

C에서는 정수 리터럴에 **형을 명시하는 접미사**를 사용할 수 있다.

| 접미사 | 의미               | 예시                      |
| ------ | ------------------ | ------------------------- |
| `U`    | unsigned           | `100U`                    |
| `L`    | long               | `100000L`                 |
| `LL`   | long long          | `10000000000LL`           |
| `UL`   | unsigned long      | `4294967295UL`            |
| `ULL`  | unsigned long long | `18446744073709551615ULL` |

### 📌 정리 요약

| 타입        | 크기 (대략) | 범위 (signed)               | 용도                                |
| ----------- | ----------- | --------------------------- | ----------------------------------- |
| `char`      | 1 byte      | -128 ~ 127                  | 문자, 바이너리 처리                 |
| `short`     | 2 bytes     | 약 ±3만                     | 메모리 제한된 환경                  |
| `int`       | 4 bytes     | 약 ±21억                    | 일반적 정수 연산                    |
| `long`      | 4~8 bytes   | 플랫폼 의존                 | 대형 수 처리, 타이머 등             |
| `long long` | 8 bytes     | ±9경 이상                   | 초고정밀 정수 연산                  |
| `unsigned`  | 동일 크기   | 0부터 시작, 최대값 2배 증가 | 음수 불필요한 경우 (비트 마스크 등) |

🧠 C의 정수형은 하드웨어 구조와 직접적으로 연결되어 있으며, **자료형의 정확한 크기를 예측하고 제어하는 능력**은 시스템 프로그래밍, 임베디드, 파일 I/O, 통신 프로토콜 설계에서 핵심이다.
 특히 `uint8_t`, `int32_t`와 같은 명확한 크기의 타입은 `<stdint.h>` 헤더에서 제공되며, 이식성 있는 코드에서 권장된다.

## 부호 유무: signed, unsigned

C 언어에서 모든 정수형 자료형은 **부호(signedness)**를 가질 수 있다.
 기본적으로 `int`, `short`, `long`, `char` 등은 **부호가 있는(signed)** 정수형이며,
 필요에 따라 **부호 없는(unsigned)** 정수형으로 선언하여 음수 없이 양의 정수만을 표현하도록 할 수 있다.

이 차이는 **저장 가능한 값의 범위, 메모리 해석 방식, 이진 연산 처리 방식** 등에 직접 영향을 미친다.

### ⚙️ 기본 구조

```
signed int a = -10;
unsigned int b = 250;
```

- `signed`: 정수형이 **음수와 양수를 모두 표현**할 수 있도록 설정
- `unsigned`: **음수 없이 0 이상 양의 정수만 표현**, 대신 **표현 가능한 최대값이 2배**로 증가
- `int`, `short`, `char`, `long`, `long long` 등 대부분의 정수형에 적용 가능

💡 참고: `int`는 기본적으로 `signed int`와 동일하므로 생략 가능

```
int x = -1;          // signed int x
unsigned int y = 1;  // unsigned int y
```

### 🧮 표현 범위 비교

정수형은 이진수 기반으로 저장되며, **부호가 있는 경우 최상위 비트(MSB)가 부호 비트**로 사용된다.
 이 때문에 동일한 크기에서도 `unsigned`는 약 2배 더 큰 양의 값을 표현할 수 있다.

| 타입        | 비트 수 | signed 범위                    | unsigned 범위     |
| ----------- | ------- | ------------------------------ | ----------------- |
| `char`      | 8 bits  | -128 ~ 127                     | 0 ~ 255           |
| `short`     | 16 bits | -32,768 ~ 32,767               | 0 ~ 65,535        |
| `int`       | 32 bits | -2,147,483,648 ~ 2,147,483,647 | 0 ~ 4,294,967,295 |
| `long long` | 64 bits | 약 ±9경                        | 0 ~ 약 18경       |

### 🧪 예제

```
#include <stdio.h>

int main() {
    signed int a = -1;
    unsigned int b = -1;  // 의도적 오류 없이 가능하지만 의미 다름

    printf("signed a: %d\n", a);
    printf("unsigned b: %u\n", b);  // b는 4294967295로 출력됨
    return 0;
}
```

📌 위 예제에서 `unsigned int b = -1;`은 **오버플로우를 발생시키지 않지만**,
 실제로는 `-1`이 2의 보수로 저장되어 `4294967295`로 해석된다.

### 🧠 사용 시 고려사항

#### 1. 비교 연산 주의

`signed`와 `unsigned`를 함께 비교하면 **암묵적 형 변환**으로 인해 예상치 못한 결과 발생 가능

```
int x = -10;
unsigned int y = 1;

if (x < y)  // ❗실제로는 x가 unsigned로 변환되어 매우 큰 수가 됨
    printf("x < y\n");
```

#### 2. 반복문에서 overflow 방지

`unsigned int`를 사용할 경우 음수로 떨어지는 일이 없기 때문에 **루프 조건에 안전성 증가**

```
for (unsigned int i = n; i-- > 0;) {
    // 역방향 반복
}
```

#### 3. 비트 연산에 적합

`unsigned`는 **2의 보수 표현에서 음수 해석 문제를 피할 수 있어**, 마스킹, 쉬프트, CRC 연산 등에 주로 사용됨

### ✅ 요약

| 키워드     | 의미                   | 특징                        | 용도 예시                           |
| ---------- | ---------------------- | --------------------------- | ----------------------------------- |
| `signed`   | 음수 및 양수 표현 가능 | 부호 비트 포함, 기본값      | 일반적인 수치 계산                  |
| `unsigned` | 0 이상의 양수만 표현   | 최대치 증가, 음수 표현 불가 | 비트 연산, 배열 인덱스, 바이트 처리 |

🧩 `signed`와 `unsigned`는 단순한 수 표현 범위를 넘어서, **하드웨어 레벨의 이진 해석 방식**, **포인터 연산**, **시스템 API와의 정합성**에까지 영향을 준다.
 즉, 명확한 선택은 **정확하고 안전한 시스템 수준 프로그래밍**의 핵심이다.
 표현 가능한 값의 범위를 정확히 설계하고, 암묵적 형 변환에 주의하는 것이 안정성과 이식성을 높이는 관건이다.

## 실수형: float, double, long double

C 언어에서 실수형(floating-point type)은 **소수점 이하를 포함한 수**를 표현하기 위해 사용된다.
 이들은 IEEE 754 부동소수점 표준에 기반하여 메모리에 저장되며, **정수형과 달리 근사값**으로 표현되므로
 **정밀도, 오차, 표현 가능한 범위**를 정확히 이해하는 것이 중요하다.

### 🧩 기본 실수형 목록

| 자료형        | 크기 (일반적인 기준) | 정밀도              | 사용 예                       |
| ------------- | -------------------- | ------------------- | ----------------------------- |
| `float`       | 4 bytes (32비트)     | 약 6~7자리          | 메모리 절약, 임베디드 연산    |
| `double`      | 8 bytes (64비트)     | 약 15~16자리        | 표준 실수형, 가장 일반적 사용 |
| `long double` | 8~16 bytes           | 최대 19~21자리 이상 | 고정밀 계산, 플랫폼 의존      |

📌 참고: `long double`의 정확한 크기와 정밀도는 플랫폼 및 컴파일러 설정에 따라 다를 수 있다.
 예: x86에서는 80비트 (10바이트), x86-64 Linux에서는 16바이트(128비트)로 구현되기도 함.

### 🔍 저장 방식: IEEE 754

부동소수점은 다음과 같은 3개 필드로 나뉘어 저장된다.

- 부호(sign): 1비트
- 지수(exponent): 표현 가능한 범위 결정
- 가수(mantissa, fraction): 실제 값의 정밀도 결정

```
32비트 float 구조 (IEEE 754)
[1비트 부호][8비트 지수][23비트 가수]
```

이 방식은 실수 값의 정밀도보다는 표현 가능한 **넓은 범위**를 우선시한다.
 그러나 유한 비트로 인해 **정확한 값 저장이 불가능한 경우도 존재하며**, 오차는 피할 수 없다.

### ✍️ 선언 및 초기화 예시

```
float pi = 3.14f;
double e = 2.718281828;
long double g = 6.67430e-11L;
```

- `f` 접미사: float 리터럴
- `L` 또는 `l` 접미사: long double 리터럴
- 접미사가 없으면 기본적으로 `double`로 해석된다

### 📐 비교 예제

```
#include <stdio.h>

int main() {
    float a = 1.0 / 3.0;
    double b = 1.0 / 3.0;
    long double c = 1.0 / 3.0;

    printf("float:       %.20f\n", a);
    printf("double:      %.20lf\n", b);
    printf("long double: %.20Lf\n", c);
    return 0;
}
```

실행 결과 (플랫폼마다 다름):

```
float:       0.33333334326744079590
double:      0.33333333333333331483
long double: 0.33333333333333333334
```

`float`는 정밀도 부족으로 끝자리가 잘리거나 근사된다.
 `double`은 보다 정밀한 표현이 가능하지만, 여전히 유한한 오차를 가진다.
 `long double`은 가능하면 더 높은 정확도를 제공한다.

### ✅ 요약

| 자료형        | 메모리 | 정밀도       | 표기 접미사 | 주 용도                              |
| ------------- | ------ | ------------ | ----------- | ------------------------------------ |
| `float`       | 4B     | ~7자리       | `f`         | 속도 및 메모리 절약, 임베디드 시스템 |
| `double`      | 8B     | ~15자리      | (없음)      | 기본 실수형, 대부분 상황에 적합      |
| `long double` | 8~16B  | ~19자리 이상 | `L`         | 고정밀 수치 계산, 과학적 시뮬레이션  |

### ⚠️ 주의 사항

- `==` 비교 금지: 실수는 오차를 포함하므로 `if (a == b)`는 위험함. 대신 **허용 오차 범위**를 두고 비교해야 한다.

  ```
  if (fabs(a - b) < 0.000001) { ... }
  ```

- 부동소수점 연산은 **비결합적**이며, 연산 순서에 따라 결과가 달라질 수 있음

- 정수 → 실수 변환은 손실 없지만, 실수 → 정수 변환 시 **내림(truncation)** 발생

🧠 실수형은 단순히 소수점을 저장하는 자료형이 아니라, **컴퓨터가 수학적 실수를 근사하는 방법**이다.
 정밀도, 표현 범위, 오차 누적 등을 이해하는 것은 수치 해석, 물리 시뮬레이션, 금융 계산, 그래픽 렌더링 등 실수 기반 프로그래밍의 필수 조건이다.

## sizeof 연산자

`sizeof`는 C 언어에서 **데이터형 또는 변수, 표현식의 메모리 크기(바이트 단위)를 계산**하는 데 사용하는 **컴파일 타임 연산자**다.
 이는 프로그램의 실행 중이 아니라 컴파일 시점에 평가되므로, **메모리 구조, 타입 정의, 이식성 있는 코드 작성**에 있어 매우 중요한 도구다.

### 🧩 기본 문법

```
sizeof(자료형)
sizeof 변수명
sizeof(표현식)
```

- 자료형일 경우 괄호가 필수 → `sizeof(int)`
- 변수일 경우 괄호 생략 가능 → `sizeof x`
- 표현식은 괄호 필요 → `sizeof(x + y)`

### 🧪 예제

```
#include <stdio.h>

int main() {
    int x = 42;
    double y = 3.14;
    
    printf("int: %lu bytes\n", sizeof(int));
    printf("x: %lu bytes\n", sizeof x);
    printf("double: %lu bytes\n", sizeof(y));
    printf("x + y: %lu bytes\n", sizeof(x + y));  // 결과: double 크기
    return 0;
}
```

🧠 주의: `sizeof(x + y)`는 `x`와 `y`의 **자료형이 자동 변환된 후의 타입(double)**을 기준으로 계산된다.

### 🔬 자료형별 sizeof 결과 예시 (일반적 시스템 기준)

| 자료형          | 크기 (`sizeof`) |
| --------------- | --------------- |
| `char`          | 1 byte          |
| `short`         | 2 bytes         |
| `int`           | 4 bytes         |
| `long`          | 4 or 8 bytes    |
| `long long`     | 8 bytes         |
| `float`         | 4 bytes         |
| `double`        | 8 bytes         |
| `long double`   | 8 ~ 16 bytes    |
| 포인터(`int *`) | 4 or 8 bytes    |

📌 크기는 시스템 아키텍처(32bit vs 64bit), 운영체제, 컴파일러 설정에 따라 달라질 수 있음.

### 🔄 배열 vs 포인터의 차이

```
int arr[10];
int *ptr = arr;

printf("%lu\n", sizeof(arr));   // 결과: 40 (4 * 10)
printf("%lu\n", sizeof(ptr));   // 결과: 8 (64bit에서 포인터 크기)
```

- `sizeof(arr)`는 전체 배열 크기를 계산
- `sizeof(ptr)`는 포인터 하나의 크기만 계산
- 배열은 포인터로 decay되지만 `sizeof`에서는 **원래 배열의 정보를 유지**함

### 📐 구조체와 sizeof

구조체는 내부 필드 외에도 **패딩(padding)**에 의해 실제 크기가 더 커질 수 있다.

```
struct example {
    char a;   // 1 byte
    int b;    // 4 bytes
};

printf("%lu\n", sizeof(struct example));  // 결과: 보통 8 bytes
```

🧠 구조체 내부 정렬(alignment)에 따라 필드 사이에 여유 공간이 추가될 수 있음

### ⚠️ 주의할 점

- `sizeof(char)`는 항상 1이다. **단위 기준이 바이트이므로 변하지 않는다**
- `sizeof`는 컴파일 시점에 평가된다. **런타임이 아닌 정적 정보 기반**
- 타입 크기를 하드코딩하지 말고 항상 `sizeof()`를 사용할 것 → 이식성 증가
- 포인터를 통해 할당된 배열에는 `sizeof(ptr)`을 사용해도 배열 크기를 알 수 없다

```
int *dynamic = malloc(10 * sizeof(int));
sizeof(dynamic); // 포인터 크기만 나옴 (보통 8), 실제 배열 크기는 모름
```

### ✅ 요약

| 용도                           | 예시                         | 설명                           |
| ------------------------------ | ---------------------------- | ------------------------------ |
| 자료형 크기 확인               | `sizeof(int)`                | int형이 몇 바이트인지 확인     |
| 변수 크기 확인                 | `sizeof x`                   | 변수 타입을 기준으로 크기 계산 |
| 표현식의 결과 타입 크기 확인   | `sizeof(x + y)`              | 암묵적 타입 변환 후 크기 기준  |
| 배열 전체 크기 확인            | `sizeof(arr)`                | 요소 수 × 요소 크기            |
| 요소 수 구하기 (`배열일 경우`) | `sizeof(arr)/sizeof(arr[0])` | 배열의 길이 계산               |

🧠 `sizeof`는 단순한 유틸리티가 아니라,
 **타입의 메모리 모델과 자료구조 설계**,
 **동적 메모리 할당**,
 **이식 가능한 라이브러리 작성**을 위한 핵심 도구다.
 정확하게 이해하고 능숙하게 활용하는 것은 고급 C 프로그래밍의 출발점이다.

# 1.5 변수와 상수

## 변수 선언 및 초기화

C 언어에서 **변수(variable)**는 값을 저장할 수 있는 **메모리 공간의 이름**이다.
 모든 변수는 사용 전에 반드시 **선언(declaration)**되어야 하며, 필요하다면 동시에 **초기화(initialization)**할 수 있다.
 변수는 메모리의 특정 위치를 점유하며, 그 위치는 자료형에 따라 크기와 정렬 방식이 결정된다.

### 📐 기본 문법

```
자료형 변수이름;             // 선언만
자료형 변수이름 = 값;        // 선언과 동시에 초기화
```

예시:

```
int count;                   // 정수형 변수 선언
float pi = 3.14f;            // 실수형 변수 초기화
char grade = 'A';            // 문자형 변수 초기화
```

변수를 선언하면 **컴파일러는 해당 자료형에 맞는 크기의 메모리를 예약**한다.
 초기화를 생략하면 **기본값은 할당되지 않는다.** (지역 변수는 초기값 불확정)

### 🔁 여러 변수 동시 선언

```
int x, y, z;                  // 같은 타입 여러 변수
int a = 1, b = 2, c = 3;      // 동시에 초기화
```

📌 여러 변수 선언 시 **각 변수마다 초기값을 반드시 명시해야 하며**,
 `int a = b = c = 0;`처럼 **대입 연결은 허용되지 않는다.**

### 🧠 선언 위치와 초기값

| 구분          | 예시                     | 초기값                    |
| ------------- | ------------------------ | ------------------------- |
| **지역 변수** | 함수 내에서 선언됨       | 쓰레기값(초기화되지 않음) |
| **전역 변수** | 함수 외부에서 선언됨     | 0으로 자동 초기화         |
| **정적 변수** | `static` 키워드로 선언됨 | 0으로 자동 초기화         |

예시:

```
int global_var;           // 전역 → 0으로 초기화됨

void func() {
    int local_var;        // 지역 → 초기화되지 않음
    static int counter;   // 정적 → 0으로 자동 초기화
}
```

### 💡 C99 이후: **변수 선언 위치 자유로움**

C89 표준에서는 **함수 블록 시작 지점에서만 변수 선언이 가능했지만**,
 C99부터는 **필요한 위치에서 바로 선언 가능**하다.

```
int main() {
    for (int i = 0; i < 10; i++) {  // C99 이후 허용
        int square = i * i;
        printf("%d\n", square);
    }
    return 0;
}
```

### 🧪 다양한 초기화 예제

#### 정수형

```
int a = 10;
unsigned int b = 100;
short s = -20;
```

#### 실수형

```
float f = 3.14f;
double d = 2.718281828;
long double ld = 1.6180339887L;
```

#### 문자 및 문자열

```
char ch = 'A';
char name[] = "Alice";    // 자동 널 종료 ('\0')
```

#### 배열 초기화

```
int arr[5] = {1, 2, 3};    // 나머지는 0으로 채워짐
char str[10] = "Hi";       // ['H', 'i', '\0', 0, ..., 0]
```

#### 구조체 초기화

```
struct Point { int x, y; };
struct Point p = {1, 2};
```

### ⚠️ 주의 사항

- 지역 변수는 **반드시 수동 초기화**해야 함. 사용 전 값이 불확정
- 같은 이름의 변수는 **블록 범위(scope)**에 따라 구분되며, **이름 충돌**에 유의
- 초기값의 타입은 반드시 변수의 타입과 **호환 가능해야 함**
   (예: `int x = 3.14;`는 허용되지만 소수점은 버려짐)

### ✅ 요약

| 항목               | 설명                                          |
| ------------------ | --------------------------------------------- |
| 선언만             | 메모리 공간 확보, 초기값은 불확정 (지역 변수) |
| 선언 + 초기화      | 변수 생성과 동시에 값 지정                    |
| 여러 개 동시 선언  | 가능하나 각 변수마다 초기화 따로 지정 필요    |
| 초기화 시기        | 전역/정적 변수: 자동 0, 지역 변수: 수동 필요  |
| C99 선언 위치 확장 | 블록 어디서든 변수 선언 가능                  |

🧠 변수 선언과 초기화는 C 언어에서 가장 단순하면서도 가장 중요한 기본 개념이다.
 변수의 **범위(scope)**, **수명(lifetime)**, **저장 클래스(storage class)**를 함께 고려하여
 어디에 어떤 방식으로 변수를 선언하고 초기화할지 결정하는 것은 **코드의 안정성, 성능, 유지보수성**에 직접적인 영향을 준다.

## 상수 지정 방식: const, #define

C 언어에서 **값이 변하지 않는 데이터(상수)**를 표현하는 방법은 크게 두 가지가 있다:

- **`const` 키워드**: 타입을 가진 컴파일 타임 상수
- **`#define` 전처리기 매크로**: 이름 치환 방식의 전처리 상수

이 두 방식은 결과적으로 "값을 고정한다"는 점에서는 유사하지만, **구현 방식, 타입 안정성, 디버깅 특성** 등에서 매우 다르다.

### 🔒 `const`: 타입을 가진 상수 선언

```
const int MAX_USERS = 100;
```

- 메모리에 **변수처럼 공간을 할당**하지만, 값은 **변경 불가**
- 타입이 명확하여 **형 검사(type checking)**가 가능
- **포인터, 배열, 함수 인자** 등 다양한 맥락에서 사용할 수 있음
- **디버거에서도 변수처럼 추적 가능**

🧩 예제

```
const double PI = 3.141592;
const char newline = '\n';
```

📌 내부적으로는 읽기 전용 메모리에 저장되며, `const`를 무시하고 변경 시 **정의되지 않은 동작(UB)** 발생 가능성 있음

### 🧱 `#define`: 매크로 기반 상수 정의

```
#define MAX_USERS 100
```

- **전처리기(Preprocessor)**가 컴파일 전에 **텍스트 치환**
- 메모리를 사용하지 않음 (실제로는 코드에서 숫자 100으로 치환됨)
- **자료형이 없음** → 형 검사 불가
- 디버깅 시 이름 추적 불가 → 단순한 리터럴로 보임
- 함수형 매크로도 정의 가능 → 부작용 주의 필요

🧩 예제

```
#define PI 3.141592
#define SQUARE(x) ((x) * (x))
```

📌 괄호 누락, 다중 평가 등 **매크로 함수는 위험성 존재**

### ⚖️ 차이점 요약 비교

| 항목             | `const`                   | `#define`                      |
| ---------------- | ------------------------- | ------------------------------ |
| 평가 시점        | 컴파일 타임               | 전처리 타임                    |
| 메모리 사용      | 사용 (변수처럼 공간 존재) | 사용하지 않음                  |
| 자료형 존재      | ✅ 있음                    | ❌ 없음                         |
| 형 검사          | ✅ 컴파일러가 검사함       | ❌ 전처리기 치환이므로 불가     |
| 디버깅 추적 가능 | ✅ 가능                    | ❌ 불가                         |
| 범위(Scope)      | 블록 또는 파일 단위       | 파일 전체(전처리 수준 전역)    |
| 함수 사용 가능   | ❌ (상수만 정의)           | ✅ (함수형 매크로 정의 가능)    |
| 위험 요소        | 낮음                      | 높음 (괄호 누락, 중복 평가 등) |

### 🧪 예제 비교

#### `const` 상수 예시

```
const int buffer_size = 512;

void read_data(char *buffer) {
    for (int i = 0; i < buffer_size; i++) {
        buffer[i] = 0;
    }
}
```

#### `#define` 상수 예시

```
#define BUFFER_SIZE 512

void read_data(char *buffer) {
    for (int i = 0; i < BUFFER_SIZE; i++) {
        buffer[i] = 0;
    }
}
```

🔍 두 코드 모두 동일하게 작동하지만,

- `const`는 타입이 명확하고 디버깅이 쉬움
- `#define`은 컴파일러 수준에서는 **그저 숫자 512로 치환되어 이름조차 사라짐**

### 🧠 결론

- **간단한 상수**에는 `const` 사용이 더 **안전하고 유지보수성이 높다**
- **복잡한 조건부 치환**이나 **매크로 함수**가 필요하다면 `#define`을 사용할 수 있다
- 실제 프로젝트에서는 **헤더 파일에 `#define`, 구현부에는 `const`**를 병행하기도 한다
- C++에서는 `constexpr`이 등장하면서 `#define` 사용은 더욱 제한적이 되었다

🧩 `const`는 **타입 안정성 있고 디버거 친화적인 정적 상수**이고,
 `#define`은 **전처리기 수준의 단순 텍스트 치환**이다.
 둘의 선택은 단순 문법 문제가 아니라 **코드의 안정성, 이식성, 디버깅 효율성**과 직결된다.
 가능하면 `const`를 기본으로 사용하고, `#define`은 **정의 시점 이전의 치환이 필요한 경우**로 제한하는 것이 현대적인 C 프로그래밍 방식이다.

## 지역 변수, 전역 변수, 정적 변수

C 언어에서 변수는 **선언 위치와 저장 영역에 따라** 그 **범위(scope)**, **수명(lifetime)**, **링크(linkage)**가 달라진다.
 이 중 대표적인 세 가지는 **지역 변수(local variable)**, **전역 변수(global variable)**, **정적 변수(static variable)**다.
 이 개념은 프로그램이 메모리를 어떻게 할당하고, 언제 해제하며, 어디서 접근 가능한지를 결정짓는다.

### 🟢 지역 변수 (Local Variable)

지역 변수는 **함수 내부에서 선언되는 변수**다.
 함수가 호출될 때 생성되고, **함수 종료 시 소멸**된다.
 이 변수는 선언된 **블록 내부에서만 유효**하며, **초기화하지 않으면 쓰레기 값**을 가진다.

```
void func() {
    int x = 10;  // 지역 변수
    printf("%d\n", x);
}
```

📌 특징

- **스택(stack)** 영역에 저장
- **자동 변수(auto)**로 간주되며, `auto` 키워드 생략 가능
- **동일한 이름을 전역 변수보다 우선**함
- **매 호출마다 새로 생성됨**

### 🔵 전역 변수 (Global Variable)

전역 변수는 **모든 함수 외부**에서 선언되는 변수이며, **프로그램 전체에서 접근 가능**하다.
 파일의 시작 부분이나 전역 영역에 위치하며, **초기화하지 않으면 0으로 자동 초기화**된다.

```
int count = 0;  // 전역 변수

void increment() {
    count++;
}
```

📌 특징

- **데이터(data)** 또는 **BSS** 영역에 저장
- 초기화 여부에 따라 `.data`(초기화됨) 또는 `.bss`(0으로 자동 초기화)
- **모든 함수에서 접근 가능**하므로 사용에 주의
- **디버깅, 테스트, 유지보수 어려움 증가 요인**

### 🟡 정적 변수 (Static Variable)

정적 변수는 `static` 키워드로 선언되며, 선언 위치에 따라 의미가 달라진다.

#### 함수 내 정적 변수 (정적 지역 변수)

```
void counter() {
    static int count = 0;  // 정적 지역 변수
    count++;
    printf("count = %d\n", count);
}
```

📌 특징

- **지역 변수처럼 함수 내에 선언되지만**, **수명은 프로그램 전체 동안 유지됨**
- **초기화는 단 한 번만** 이루어짐
- **스택이 아닌 데이터 영역**에 저장
- 함수가 여러 번 호출되어도 이전 값을 유지할 수 있다 → **상태 기억**

#### 함수 외부 정적 변수 (정적 전역 변수)

```
static int global_var = 100;
```

📌 특징

- **외부 파일에서 접근 불가** (링크 범위 제한)
- **파일 내부 전용 전역 변수**를 만들고 싶을 때 사용

### 🧠 메모리 및 특성 비교 요약

| 구분           | 선언 위치          | 저장 영역     | 생존 시점               | 접근 가능 범위                 | 기본 초기화    |
| -------------- | ------------------ | ------------- | ----------------------- | ------------------------------ | -------------- |
| 지역 변수      | 함수 내부          | 스택(stack)   | 함수 호출 중            | 해당 함수 내부                 | ❌ 불확정       |
| 전역 변수      | 함수 외부          | 데이터 or BSS | 프로그램 시작~종료      | 모든 함수에서 접근 가능        | ✅ 0으로 초기화 |
| 정적 지역 변수 | 함수 내부 (static) | 데이터        | 프로그램 전체 동안 유지 | 선언된 함수 내부에서만 유효    | ✅ 0으로 초기화 |
| 정적 전역 변수 | 함수 외부 (static) | 데이터        | 프로그램 전체 동안 유지 | 동일 소스 파일 내부에서만 유효 | ✅ 0으로 초기화 |

### 🔍 예제: 전역 vs 지역 vs 정적

```
#include <stdio.h>

int global_count = 0;           // 전역 변수

void test() {
    int local_var = 0;          // 지역 변수
    static int static_var = 0;  // 정적 지역 변수

    local_var++;
    static_var++;
    global_count++;

    printf("local = %d, static = %d, global = %d\n",
           local_var, static_var, global_count);
}

int main() {
    test();
    test();
    test();
    return 0;
}
```

📌 실행 결과:

```
local = 1, static = 1, global = 1
local = 1, static = 2, global = 2
local = 1, static = 3, global = 3
```

- `local_var`는 매 호출 시 새로 생성됨
- `static_var`는 이전 값을 유지함
- `global_count`는 외부에서도 값이 공유됨

🧩 변수의 생존 기간과 접근 범위를 정확히 제어하는 것은
 **버그 방지**, **메모리 최적화**, **캡슐화**, **스레드 안정성 확보**의 핵심이다.
 특히 전역 변수 남용은 코드 결합도 상승, 디버깅 난이도 증가, 예측 불가능한 동작을 초래할 수 있으므로
 **정적 변수와 지역 변수의 의도를 명확히 구분하여 사용하는 습관**이 중요하다.

# 1.6 연산자

## 산술 연산자: +, -, *, /, %

C 언어의 **산술 연산자(arithmetic operators)**는 기본적인 수학 연산을 수행하는 데 사용된다.
 이 연산자들은 **피연산자(operand)**가 정수형이든 실수형이든 사용할 수 있으며, 결과의 자료형은 피연산자의 조합에 따라 달라진다.
 특히 `/`, `%` 연산자는 피연산자의 **정수/실수 여부**에 따라 **전혀 다른 결과**를 낸다.

### ➕ 덧셈 연산자 (`+`)

```
int a = 10 + 5;      // 15
float b = 3.2 + 1.1; // 4.3
```

- 정수 또는 실수 덧셈
- 문자형(char)도 내부적으로 정수로 처리 가능 → `'A' + 1` → `'B'`

### ➖ 뺄셈 연산자 (`-`)

```
int a = 10 - 5;        // 5
float b = 2.5 - 3.1;   // -0.6
```

- 음수 표현에도 사용 → `int x = -7;`
- 포인터 차이 연산으로도 활용 가능 (고급 주제)

### ✖️ 곱셈 연산자 (`*`)

```
int a = 4 * 5;       // 20
float b = 2.5 * 3.0; // 7.5
```

- 정수, 실수, 부동소수점 모두 사용 가능
- **우선순위가 높음** → 괄호 생략 시 연산 순서 유의

### ➗ 나눗셈 연산자 (`/`)

```
int a = 7 / 2;       // 결과: 3 (정수 나눗셈)
float b = 7.0 / 2.0; // 결과: 3.5 (실수 나눗셈)
```

📌 **정수형끼리 나누면 결과는 정수**이다. 소수점 이하는 **버려진다(truncate)**.
 소수점 결과가 필요하면 반드시 **실수형 피연산자**를 포함시켜야 한다.

```
float x = (float)7 / 2; // 3.5
```

### 🔢 나머지 연산자 (`%`)

```
int a = 10 % 3;   // 결과: 1
int b = -10 % 3;  // 결과: -1 (부호는 왼쪽 피연산자 기준)
```

- **정수형에만 사용 가능** → `float % float` 은 컴파일 오류
- `a % b`는 `a`를 `b`로 나눈 **나머지**
- 부호 규칙: 대부분의 시스템에서 `a % b`의 부호는 `a`와 같다

### 🧠 우선순위 요약

| 연산자 | 설명   | 우선순위 (낮음 → 높음) |
| ------ | ------ | ---------------------- |
| `+`    | 덧셈   | 중간                   |
| `-`    | 뺄셈   | 중간                   |
| `*`    | 곱셈   | 높음                   |
| `/`    | 나눗셈 | 높음                   |
| `%`    | 나머지 | 높음                   |

📌 산술 연산자의 연산 순서가 헷갈릴 경우 **반드시 괄호를 사용**하여 명확하게 표현해야 한다.

### 🧪 예제: 산술 연산자 동작 확인

```
#include <stdio.h>

int main() {
    int a = 10, b = 3;
    float x = 10.0, y = 3.0;

    printf("a + b = %d\n", a + b);
    printf("a - b = %d\n", a - b);
    printf("a * b = %d\n", a * b);
    printf("a / b = %d\n", a / b);  // 결과: 3
    printf("a %% b = %d\n", a % b); // 결과: 1

    printf("x / y = %.2f\n", x / y); // 결과: 3.33...
    return 0;
}
```

### ✅ 요약

| 연산자 | 이름   | 피연산자 타입   | 결과 타입                | 예외 / 특징                      |
| ------ | ------ | --------------- | ------------------------ | -------------------------------- |
| `+`    | 덧셈   | 정수, 실수      | 피연산자에 따라 다름     | 문자와 정수 연산도 가능          |
| `-`    | 뺄셈   | 정수, 실수      | 피연산자에 따라 다름     | 음수 표현도 가능                 |
| `*`    | 곱셈   | 정수, 실수      | 피연산자에 따라 다름     | 우선순위 높음                    |
| `/`    | 나눗셈 | 정수, 실수      | 정수는 정수, 실수는 실수 | 정수 나눗셈은 소수점 버림        |
| `%`    | 나머지 | **정수만 가능** | 정수                     | 실수에는 사용 불가 (컴파일 에러) |

🧩 C 언어의 산술 연산은 단순한 계산을 넘어, **자료형, 정밀도, 연산 순서, 부호 처리, 표현 범위** 등 컴퓨터 내부의 수 체계를 이해하는 데 기반이 된다.
 특히 `/`, `%` 연산자의 정수/실수 차이는 초보자의 오류 발생률이 높으므로 명확히 구분해서 사용하는 것이 중요하다.

## 관계 연산자: ==, !=, <, >, <=, >=

관계 연산자는 **두 개의 피연산자 사이의 관계를 비교**하여, 그 결과를 **논리값(boolean)**으로 반환한다.
 C 언어에서는 결과가 **참이면 1, 거짓이면 0**으로 평가된다.
 이들은 조건문(`if`, `while`, `for`)에서 주로 사용되며, 프로그램의 흐름을 제어하는 데 핵심적인 역할을 한다.

### 🔹 `==` : 같음 (equal to)

```
if (a == b)
    printf("같다\n");
```

- 두 값이 **같으면 참(1)**, 다르면 거짓(0)

- 비교 연산자이지, 할당 연산자 `=`와 혼동하지 말 것

  ```
  if (a = 5)  // ❌ a에 5를 할당하고, 조건은 항상 참
  if (a == 5) // ✅ 올바른 비교
  ```

### 🔸 `!=` : 같지 않음 (not equal to)

```
if (score != 100)
    printf("만점이 아님\n");
```

- 두 값이 **다르면 참**, 같으면 거짓

### 🔼 `<` : 작다 (less than)

```
if (x < 0)
    printf("음수입니다\n");
```

- 왼쪽 값이 오른쪽 값보다 **작을 때 참**

### 🔽 `>` : 크다 (greater than)

```
if (age > 18)
    printf("성인입니다\n");
```

- 왼쪽 값이 오른쪽 값보다 **클 때 참**

### 🔼 `<=` : 작거나 같다 (less than or equal to)

```
if (score <= 60)
    printf("불합격\n");
```

- 왼쪽 값이 오른쪽 값보다 **작거나 같을 때 참**

### 🔽 `>=` : 크거나 같다 (greater than or equal to)

```
if (temp >= 100)
    printf("끓는점 이상\n");
```

- 왼쪽 값이 오른쪽 값보다 **크거나 같을 때 참**

### 🧪 예제 코드

```
#include <stdio.h>

int main() {
    int a = 5, b = 10;

    printf("a == b: %d\n", a == b);   // 0
    printf("a != b: %d\n", a != b);   // 1
    printf("a < b : %d\n", a < b);    // 1
    printf("a > b : %d\n", a > b);    // 0
    printf("a <= b: %d\n", a <= b);   // 1
    printf("a >= b: %d\n", a >= b);   // 0

    return 0;
}
```

출력 결과:

```
a == b: 0  
a != b: 1  
a < b : 1  
a > b : 0  
a <= b: 1  
a >= b: 0  
```

### ⚠️ 주의 사항

- 관계 연산의 결과는 항상 **0(거짓), 1(참)**으로 해석됨

- 실수형끼리 비교할 때는 **부동소수점 오차**로 인해 `==` 사용이 위험할 수 있음

  ```
  if (fabs(a - b) < 1e-6)  // float 비교는 오차 범위로
  ```

- 복합 비교 불가 → `0 < x < 10`은 C에서 의미 없음

  ```
  if (x > 0 && x < 10)  // 올바른 표현
  ```

### ✅ 요약

| 연산자 | 의미        | 참일 조건 예시 | 결과값   |
| ------ | ----------- | -------------- | -------- |
| `==`   | 같다        | `5 == 5`       | `1` (참) |
| `!=`   | 같지 않다   | `5 != 3`       | `1` (참) |
| `<`    | 작다        | `3 < 4`        | `1` (참) |
| `>`    | 크다        | `7 > 2`        | `1` (참) |
| `<=`   | 작거나 같다 | `2 <= 2`       | `1` (참) |
| `>=`   | 크거나 같다 | `9 >= 8`       | `1` (참) |

🧠 관계 연산자는 단순한 비교 그 이상이다.
 조건 분기, 반복 제어, 상태 판단, 논리 조합 등 **모든 프로그램 흐름의 논리적 기반**이 되며,
 정확한 비교 구조와 연산 순서를 이해하는 것은 **정확하고 예측 가능한 코드 작성의 핵심**이다.

## 논리 연산자: &&, ||, !

논리 연산자는 **조건문과 불리언 논리 연산**에 사용되는 연산자들로,
 **논리값(참: 1, 거짓: 0)**을 기반으로 복합 조건을 구성하거나 조건을 반전시킬 수 있다.
 이들은 `if`, `while`, `for` 같은 조건 제어 구문에서 가장 자주 사용된다.

### 🔹 `&&` : 논리 AND (그리고)

```
if (a > 0 && b > 0)
    printf("두 수 모두 양수입니다\n");
```

- 양쪽 조건이 **모두 참**일 때만 결과가 참
- 하나라도 거짓이면 전체 결과는 거짓
- **단축 평가(short-circuit evaluation)** 발생:
   왼쪽 조건이 거짓이면 오른쪽은 아예 평가하지 않음

| 좌측 | 우측 | 결과 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 0    |
| 1    | 0    | 0    |
| 1    | 1    | 1    |

### 🔸 `||` : 논리 OR (또는)

```
if (x == 0 || y == 0)
    printf("둘 중 하나는 0입니다\n");
```

- 양쪽 조건 중 **하나라도 참**이면 결과가 참
- 둘 다 거짓이어야 전체 결과가 거짓
- **단축 평가** 발생: 왼쪽이 참이면 오른쪽은 평가 생략

| 좌측 | 우측 | 결과 |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 1    |

### ❗ `!` : 논리 NOT (부정)

```
if (!is_valid)
    printf("유효하지 않습니다\n");
```

- 피연산자가 참이면 거짓으로, 거짓이면 참으로 반전
- 단항 연산자이며, 괄호와 함께 쓰는 것이 가독성에 좋음

| 입력 | 결과 |
| ---- | ---- |
| 0    | 1    |
| 1    | 0    |

### 🧪 예제

```
#include <stdio.h>

int main() {
    int a = 5, b = 0;

    if (a > 0 && b > 0)
        printf("AND 조건 만족\n");
    else
        printf("AND 조건 실패\n");

    if (a > 0 || b > 0)
        printf("OR 조건 만족\n");

    if (!(a == 5))
        printf("NOT 조건 만족\n");
    else
        printf("NOT 조건 실패\n");

    return 0;
}
```

출력:

```
AND 조건 실패  
OR 조건 만족  
NOT 조건 실패
```

### 📌 단축 평가의 활용

```
if (ptr != NULL && ptr->value == 10) { ... }
```

- `ptr`이 `NULL`일 경우 `ptr->value`를 평가하지 않아 **세그멘테이션 오류 방지**
- 조건 순서를 바꾸면 위험해질 수 있음

### ✅ 요약

| 연산자 | 이름     | 의미                          | 평가 조건             | 단축 평가                |
| ------ | -------- | ----------------------------- | --------------------- | ------------------------ |
| `&&`   | 논리 AND | 둘 다 참일 때만 참            | `if (x > 0 && y > 0)` | O                        |
| `      |          | `                             | 논리 OR               | 둘 중 하나라도 참이면 참 |
| `!`    | 논리 NOT | 참 → 거짓, 거짓 → 참으로 반전 | `if (!flag)`          | N/A                      |

🧠 논리 연산자는 프로그램의 **분기 흐름**, **조건 필터링**, **에러 처리**, **단축 조건 검사** 등 모든 조건 기반 로직에서 핵심적으로 사용된다.
 특히 `&&`, `||`의 단축 평가(short-circuit)는 **효율성과 안정성 확보**에 매우 중요한 개념이며,
 조건문의 순서를 바꿔도 동작이 동일하지 않을 수 있으므로 **의도와 순서에 민감한 설계**가 요구된다.

## 대입 연산자: =, +=, -=, *=, /=

C 언어에서 **대입 연산자**는 **우변의 값을 좌변의 변수에 저장**하는 데 사용된다.
 가장 기본적인 연산자 `=` 외에도, 산술 연산과 결합된 **복합 대입 연산자(compound assignment operator)**들이 존재하여
 코드를 간결하게 만들고 가독성을 높이는 데 도움을 준다.

### ➡️ `=` : 단순 대입

```
int x;
x = 10;
```

- 우측 값을 좌측 변수에 복사
- 자료형이 다를 경우 암묵적 형 변환이 발생할 수 있음 (주의)

예:

```
float f = 3;    // int 3 → float 3.0 자동 변환
int i = 2.5;    // float 2.5 → int 2 (소수점 제거)
```

### ➕ `+=` : 덧셈 후 대입

```
x += 5;   // x = x + 5;
```

- 좌변 변수에 우변 값을 더한 후, 그 결과를 다시 좌변에 저장
- 누적 합, 반복 누적 처리 등에 자주 사용

### ➖ `-=` : 뺄셈 후 대입

```
x -= 2;   // x = x - 2;
```

- 좌변 변수에서 우변 값을 뺀 후, 그 결과를 다시 좌변에 저장

### ✖️ `*=` : 곱셈 후 대입

```
x *= 3;   // x = x * 3;
```

- 좌변 변수에 우변 값을 곱한 후 저장

### ➗ `/=` : 나눗셈 후 대입

```
x /= 2;   // x = x / 2;
```

- 좌변 변수에 우변 값으로 나눈 결과를 저장
- 정수 나눗셈일 경우 소수점 이하가 버려짐

### 🧪 예제 코드

```
#include <stdio.h>

int main() {
    int x = 10;

    x += 5;     // 15
    x -= 2;     // 13
    x *= 3;     // 39
    x /= 3;     // 13

    printf("x = %d\n", x);
    return 0;
}
```

### 📌 비교 요약

| 연산자 | 의미           | 예시     | 동등한 표현 |
| ------ | -------------- | -------- | ----------- |
| `=`    | 값 대입        | `x = 5`  | 그대로 대입 |
| `+=`   | 덧셈 후 대입   | `x += 2` | `x = x + 2` |
| `-=`   | 뺄셈 후 대입   | `x -= 4` | `x = x - 4` |
| `*=`   | 곱셈 후 대입   | `x *= 3` | `x = x * 3` |
| `/=`   | 나눗셈 후 대입 | `x /= 2` | `x = x / 2` |

### ⚠️ 주의 사항

- `x += y`는 **x = x + y**와 동일하지만,
   **x가 포인터일 경우 의미가 달라질 수 있음** (고급 주제: 포인터 산술)
- `a = b = c = 5;` → 오른쪽부터 왼쪽으로 평가됨
   즉, `c = 5` → `b = 5` → `a = 5` 순서
- 실수형에서 `/=` 사용 시, **소수점 오차** 주의

🧠 대입 연산자는 단순한 할당 기능을 넘어서,
 **누적 계산**, **루프 내 반복 처리**, **형 변환을 수반한 계산**, **구조체 멤버 초기화**, **포인터 간 복사** 등
 C 언어 전체 동작 구조를 지탱하는 **핵심 기초 연산자**다.
 복합 대입 연산자는 기능은 단순하지만, **코드의 간결성과 의미 전달력**을 동시에 높일 수 있는 중요한 문법이다.

## 비트 연산자: &, |, ^, ~, <<, >>

비트 연산자는 **정수형 데이터의 각 비트를 직접 조작**하는 연산자다.
 이들은 논리 연산자와 유사해 보이지만, **논리값(0 또는 1)이 아닌 비트 단위에서 작동**하며,
 **저수준 하드웨어 제어, 마스크 연산, 암호화, 통신 프로토콜, 최적화 루틴** 등에서 널리 사용된다.

### 🧩 1. `&` (비트 AND)

```
int result = a & b;
```

- 두 비트가 **모두 1**일 때만 결과 1
- 그 외에는 0

| a (bit) | b (bit) | a & b |
| ------- | ------- | ----- |
| 0       | 0       | 0     |
| 1       | 0       | 0     |
| 0       | 1       | 0     |
| 1       | 1       | 1     |

📌 **비트 마스킹(masking)**에 자주 사용

```
if ((flags & 0x04) != 0) // 3번째 비트가 켜져 있는지 검사
```

### 🧩 2. `|` (비트 OR)

```
int result = a | b;
```

- 두 비트 중 **하나라도 1**이면 결과 1
- 둘 다 0이면 0

| a    | b    | a \| b |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 1    | 0    | 1      |
| 0    | 1    | 1      |
| 1    | 1    | 1      |

📌 **비트 켜기(set)** 연산에 사용

```
flags |= 0x02; // 2번째 비트 ON
```

### 🧩 3. `^` (비트 XOR)

```
int result = a ^ b;
```

- 두 비트가 **서로 다르면 1**, 같으면 0

| a    | b    | a ^ b |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 1    | 0    | 1     |
| 0    | 1    | 1     |
| 1    | 1    | 0     |

📌 **비트 토글(toggle)**, **암호화(양방향성)**, **두 수 스왑** 등에 활용

```
a ^= b;
b ^= a;
a ^= b;
```

### 🧩 4. `~` (비트 NOT)

```
int result = ~a;
```

- 모든 비트를 **반전** (0 → 1, 1 → 0)
- **단항 연산자**

예:

```
a = 0b00001111;
~a = 0b11110000;
```

📌 2의 보수 표현에서 `~x + 1`은 `-x`와 동일하다

### 🧩 5. `<<` (왼쪽 시프트)

```
int result = a << n;
```

- 비트를 **왼쪽으로 n비트 이동**
- 오른쪽에는 0이 채워짐
- **값을 2ⁿ배**로 곱한 효과

```
int x = 3;         // 00000011
x = x << 2;        // 00001100 → 3 × 2² = 12
```

### 🧩 6. `>>` (오른쪽 시프트)

```
int result = a >> n;
```

- 비트를 **오른쪽으로 n비트 이동**
- 왼쪽 채움은 시스템에 따라 다름 (0 또는 부호 유지)
- **값을 2ⁿ으로 나눈 효과**

```
int x = 12;        // 00001100
x = x >> 2;        // 00000011 → 12 ÷ 4 = 3
```

### 🧪 전체 예제

```
#include <stdio.h>

int main() {
    unsigned char a = 0b10101010;
    unsigned char b = 0b11001100;

    printf("a & b = %02X\n", a & b); // 0x88
    printf("a | b = %02X\n", a | b); // 0xEE
    printf("a ^ b = %02X\n", a ^ b); // 0x66
    printf("~a    = %02X\n", (unsigned char)(~a)); // 0x55
    printf("a << 1 = %02X\n", a << 1); // 0x54
    printf("b >> 2 = %02X\n", b >> 2); // 0x33
    return 0;
}
```

### ✅ 요약

| 연산자 | 이름          | 기능 설명                              | 활용 예                  |
| ------ | ------------- | -------------------------------------- | ------------------------ |
| `&`    | AND           | 두 비트가 모두 1일 때만 1              | 비트 마스킹 (`x & mask`) |
| `      | `             | OR                                     | 하나라도 1이면 1         |
| `^`    | XOR           | 다르면 1, 같으면 0                     | 비트 토글, 스왑          |
| `~`    | NOT           | 모든 비트 반전                         | 음수 계산, 보수 연산     |
| `<<`   | 왼쪽 시프트   | 비트를 왼쪽으로 밀고 0 삽입 → ×2ⁿ      | 곱셈 최적화 (`x << n`)   |
| `>>`   | 오른쪽 시프트 | 비트를 오른쪽으로 밀고 MSB 유지/0 삽입 | 나눗셈 최적화 (`x >> n`) |

🧠 비트 연산자는 단순한 계산 이상의 의미를 가진다.
 **하드웨어 직접 제어, 디바이스 레지스터 접근, 압축 알고리즘, 해싱, 최적화 루틴** 등
 성능과 공간이 중요한 분야에서 핵심적인 역할을 수행하며,
 C 언어의 **시스템 프로그래밍 언어로서의 정체성**을 가장 잘 보여주는 연산자 군이다.

## 조건 연산자: ? :

C 언어에서 **조건 연산자**는 유일한 **삼항 연산자(ternary operator)**로,
 `if-else` 문을 한 줄로 간결하게 표현할 수 있게 해준다.
 구문은 다음과 같으며, **조건에 따라 두 값 중 하나를 선택**하는 방식이다.

### 🔧 기본 문법

```
condition ? value_if_true : value_if_false;
```

- `condition`: 조건식 (0은 거짓, 그 외는 참)
- `value_if_true`: 조건이 참일 경우 평가되는 표현식
- `value_if_false`: 조건이 거짓일 경우 평가되는 표현식
- 전체 표현식은 **값을 가지며**, **대입, 출력, 반환 등 다양한 맥락에서 사용 가능**

### 🧪 예제 1: 출력

```
int age = 20;
printf("%s\n", age >= 18 ? "성인" : "미성년자");
```

조건: `age >= 18`
 참이면 `"성인"`, 거짓이면 `"미성년자"`가 출력됨

### 🧪 예제 2: 변수 초기화

```
int a = 10, b = 20;
int max = (a > b) ? a : b;
a > b`가 참이면 `max = a`, 아니면 `max = b
```

### 🧪 예제 3: 중첩 조건 (주의)

```
int score = 85;
const char* grade = (score >= 90) ? "A" :
                    (score >= 80) ? "B" :
                    (score >= 70) ? "C" : "F";
```

이 구조는 간결하지만, 가독성이 떨어질 수 있으므로
 **단순 조건에만 사용하는 것이 바람직하다.**

### ⚠️ 조건 연산자 vs if 문

| 조건 연산자 (`? :`)            | if 문                            |
| ------------------------------ | -------------------------------- |
| 값 반환 가능 (`x = a ? b : c`) | 단순한 표현이 아님 (`if`는 문장) |
| 한 줄 표현 가능                | 블록 구조 필요                   |
| 간단한 조건 분기 적합          | 복잡한 제어문, 여러 줄은 부적합  |

```
// 조건 연산자
result = (x > 0) ? x : -x;

// if 문 버전
if (x > 0)
    result = x;
else
    result = -x;
```

### ✅ 요약

| 요소        | 설명                                           |
| ----------- | ---------------------------------------------- |
| 연산자 기호 | `? :`                                          |
| 피연산자 수 | 3개 (조건식 ? 참일 때 값 : 거짓일 때 값)       |
| 반환값      | 참 또는 거짓일 때의 식 결과                    |
| 사용 목적   | 간단한 조건 분기를 값으로 표현할 때            |
| 적합한 용도 | 대입, 출력, 반환식 등 **표현식이 필요한 경우** |

🧠 조건 연산자 `? :`는 단순히 `if`를 줄인 문법이 아니다.
 **"조건식도 하나의 값처럼 사용할 수 있는 언어 구조"**로,
 함수형 프로그래밍이나 표현식 기반 제어 흐름을 만들 때 매우 유용하다.
 단, 남용하면 코드 가독성이 떨어질 수 있으므로 **간결성과 명확성의 균형**이 중요하다.

## 연산자 우선순위 및 결합 방향

C 언어에서 **여러 연산자가 한 표현식에 섞여 있을 때**, 어떤 연산을 먼저 수행할지는 **연산자의 우선순위(priority)**와 **결합 방향(associativity)**에 따라 결정된다.
 이 규칙을 정확히 이해하지 않으면, 코드가 **오작동하거나 예기치 않은 결과**를 초래할 수 있다.

### 🧭 핵심 개념

| 용어          | 의미                                                         |
| ------------- | ------------------------------------------------------------ |
| **우선순위**  | 연산자들 간 **선행 순서**를 결정. 우선순위가 높은 연산자가 먼저 수행됨 |
| **결합 방향** | **우선순위가 동일한 연산자**들 간에 어떤 방향으로 평가할지를 정의함 |
|               | 대부분은 **왼쪽→오른쪽**, 일부(`=`, `?:`)는 **오른쪽→왼쪽**  |

### 🧱 대표적인 연산자 우선순위 테이블

| 우선순위 | 연산자 종류        | 예시                                               | 결합 방향         |
| -------- | ------------------ | -------------------------------------------------- | ----------------- |
| 1        | 괄호               | `( )`                                              | ―                 |
| 2        | 단항 연산자        | `+`, `-`, `!`, `~`, `++`, `--`, `sizeof`, `(type)` | 오른쪽 → 왼쪽     |
| 3        | 곱셈/나눗셈/나머지 | `*`, `/`, `%`                                      | 왼쪽 → 오른쪽     |
| 4        | 덧셈/뺄셈          | `+`, `-`                                           | 왼쪽 → 오른쪽     |
| 5        | 관계(비교)         | `<`, `<=`, `>`, `>=`                               | 왼쪽 → 오른쪽     |
| 6        | 동등 비교          | `==`, `!=`                                         | 왼쪽 → 오른쪽     |
| 7        | 비트 AND           | `&`                                                | 왼쪽 → 오른쪽     |
| 8        | 비트 XOR           | `^`                                                | 왼쪽 → 오른쪽     |
| 9        | 비트 OR            | `                                                  | `                 |
| 10       | 논리 AND           | `&&`                                               | 왼쪽 → 오른쪽     |
| 11       | 논리 OR            | `                                                  |                   |
| 12       | 조건 연산자        | `? :`                                              | **오른쪽 → 왼쪽** |
| 13       | 대입 연산자        | `=`, `+=`, `-=`, `*=`, 등                          | **오른쪽 → 왼쪽** |
| 14       | 쉼표 연산자        | `,`                                                | 왼쪽 → 오른쪽     |

📌 괄호 `( )`를 사용하면 항상 **우선순위를 재정의**할 수 있다. → **모호할 땐 괄호로 명시하라**

### 🧪 예제 1: 기본 산술 연산

```
int x = 2 + 3 * 4;  // 곱셈 먼저: 3*4=12 → 2+12 = 14
```

### 🧪 예제 2: 논리와 대입

```
int a = 5, b = 0;
int result = a > 0 && b++;  // a > 0 → true(1), b++ 실행
```

- `&&`는 왼쪽 먼저 평가, `a > 0`이 참이면 `b++` 실행됨

### 🧪 예제 3: 조건 연산자와 대입

```
int x = 5;
int y = (x > 0) ? 1 : 2;   // 조건문 결과가 y에 대입
```

- `? :`는 대입보다 우선순위가 높으므로 괄호 없이도 작동

### ⚠️ 예제 4: 위험한 혼동

```
int x = 1;
if (x = 0)  // ❌ 의도는 비교(==), 실제는 대입(=)
    printf("참\n");
```

- `=`는 `==`보다 우선순위가 낮지만, `if` 문은 내부 값이 0인지 1인지만 보기 때문에
   대입 결과가 조건으로 사용됨 → 오류 발생 가능

### ✅ 안전한 사용 팁

- 📌 연산자 우선순위가 **헷갈릴 때는 항상 괄호로 명확히 표현하라.**
- 복잡한 표현식은 **여러 줄로 나누는 것이 오히려 안전하다.**
- 조건 연산자 `? :`와 대입 연산자는 반드시 우선순위 확인 (둘 다 우측 결합)

### 🧠 결론

C 언어의 연산자 우선순위와 결합 방향은
 단순한 문법 암기가 아니라, **표현식이 어떻게 실행되는지 결정하는 실행 모델**이다.
 잘못 이해하면 컴파일은 되지만 **의도와 다른 결과**를 낳는 버그가 발생한다.
 **괄호로 명시하고**, **결합 방향을 의식하며**, **우선순위 테이블을 참고로 삼아야 한다.**