# 11. C 표준 및 구현 차이

# 11.1 ANSI C, C89, C99, C11, C17 표준 비교

## 주요 기능 추가 사항

### 📌 C 표준 버전별 주요 기능 추가 사항 (C89 ~ C23)

#### 📊 요약 비교표

| 표준          | 발표 연도 | 주요 기능                                                 |
| ------------- | --------- | --------------------------------------------------------- |
| **C89 / C90** | 1989/1990 | ANSI C, 함수 선언 형식 확립, `stdio.h` 등 표준화          |
| **C99**       | 1999      | `inline`, `long long`, 가변 길이 배열, 복합 리터럴        |
| **C11**       | 2011      | `_Generic`, `_Alignas`, `_Static_assert`, 멀티스레딩      |
| **C17**       | 2017      | 버그 수정 위주 (사양 변화 없음)                           |
| **C23**       | 2023      | `typeof`, `nullptr`, `u8/u16/u32` 리터럴, UTF-8 지원 강화 |

### 📚 각 표준의 주요 기능 정리

#### 🟩 **C89 / C90 (ANSI C)**

✅ 발표: 1989 (ANSI), 1990 (ISO)

**주요 특징**

- 함수 프로토타입 도입 (`int func(int a);`)
- 표준 라이브러리 통합 (`stdio.h`, `stdlib.h`, `string.h`)
- `void` 타입 도입
- `const`, `volatile` 키워드
- 구조체, 공용체 확립

#### 🟨 **C99**

✅ 발표: 1999

**주요 추가 기능**

| 기능                 | 설명                                      |
| -------------------- | ----------------------------------------- |
| `long long int`      | 64비트 정수형 지원                        |
| `inline`             | 인라인 함수 지원                          |
| 복합 리터럴          | `(int[]){1, 2, 3}` 식의 배열 리터럴       |
| 가변 길이 배열 (VLA) | `int arr[n];` 형태의 동적 배열            |
| `//` 한 줄 주석 지원 | C 스타일 주석 추가                        |
| `stdint.h`           | 고정 크기 정수형: `int32_t`, `uint8_t` 등 |
| `stdbool.h`          | `bool`, `true`, `false` 도입              |
| `restrict` 키워드    | 포인터 최적화 힌트                        |
| `__func__`           | 함수 이름 문자열 내장 식별자              |

#### 🟦 **C11**

✅ 발표: 2011

**주요 추가 기능**

| 기능                       | 설명                                           |
| -------------------------- | ---------------------------------------------- |
| `_Atomic`, `<stdatomic.h>` | 원자 연산 지원                                 |
| `_Static_assert`           | 컴파일 타임 상수 조건 검사                     |
| `_Generic`                 | 간단한 **타입 기반 오버로딩**                  |
| `_Alignas`, `_Alignof`     | 정렬 지정 및 조회                              |
| `threads.h`                | `thrd_create`, `mtx_lock` 등 C 표준 스레딩 API |
| `noreturn` 함수 속성       | `[[noreturn]] void exit();` 형식               |

#### 🟪 **C17**

✅ 발표: 2017

- **기능적 추가 사항 없음**
- 일부 undefined behavior 정의 개선
- 표준 라이브러리 버그 수정

> 💡 사실상 **C11의 유지보수 버전**이며, 대부분의 컴파일러에서 C11과 동일하게 취급됨

#### 🟥 **C23 (최신)**

✅ 발표: 2023 (정식 승인 완료)

**주요 추가 기능**

| 기능                      | 설명                                            |
| ------------------------- | ----------------------------------------------- |
| `nullptr`                 | C++ 스타일 null 리터럴 도입                     |
| `typeof`, `typeof_unqual` | GCC 확장을 표준으로 채택                        |
| `u8`, `u16`, `u32` 리터럴 | UTF-8/16/32 문자열 리터럴                       |
| `_BitInt(N)`              | 사용자 지정 비트 정수 타입 도입 (`_BitInt(12)`) |
| `static_assert`           | `assert.h`에 정식 도입 (C++과 호환)             |
| 기본 타입 개선            | `char8_t` 등 문자 처리 개선                     |
| 표준 라이브러리 개선      | 더 명확한 NULL 검사 및 오류 처리 함수 강화      |

### ✅ 결론 요약

| 표준    | 성격                                       |
| ------- | ------------------------------------------ |
| C89/C90 | 전통적 C의 기초 확립                       |
| C99     | 표현력과 타입 안정성 강화                  |
| C11     | 멀티스레딩, 제너릭, 정렬 등 고급 기능 도입 |
| C17     | 유지보수 및 안정성 강화                    |
| C23     | 현대화 및 C++과의 일부 호환 강화           |

## 복합 리터럴, 변수 선언 위치, for 루프의 범위 등

### 📌 C99 주요 문법 기능 세 가지

### 🧱 1. 복합 리터럴 (Compound Literal)

#### 🧾 개요

**복합 리터럴**은 배열이나 구조체, 공용체 등의 값을 **즉시 생성해서 사용할 수 있는 문법**이다.

> 일반적으로 값이 필요한 자리에서 **임시 객체를 만드는 데 사용**된다.

#### ✨ 문법 예시

```
(int[]){1, 2, 3}         // 임시 배열
(struct Point){1, 2}     // 구조체 리터럴
```

#### 📚 실전 예

```
#include <stdio.h>

void print_array(int *arr, int len) {
    for (int i = 0; i < len; i++)
        printf("%d ", arr[i]);
}

int main() {
    print_array((int[]){10, 20, 30, 40}, 4);
    return 0;
}
```

> 임시 배열이 생성되어 함수에 전달된다. 복사 없이 포인터로 전달됨.

#### 💡 장점

| 항목             | 설명                                           |
| ---------------- | ---------------------------------------------- |
| 코드 간결화      | 구조체나 배열을 한 줄로 생성 가능              |
| 함수 전달 최적화 | 리터럴 값을 직접 함수 인자로 전달 가능         |
| 메모리 절약      | 필요한 시점에만 스택에 생성됨 (정적 할당 아님) |

#### ⚠️ 주의사항

| 항목           | 설명                                                     |
| -------------- | -------------------------------------------------------- |
| 수명 제한      | 복합 리터럴은 **스택에 생성되므로** 범위를 벗어나면 무효 |
| 주소 참조 가능 | `&(int[]){1, 2}[0]` → 주소 취득도 가능함                 |

### 🧾 2. 변수 선언 위치 자유화

#### 🔄 C89에서는?

```
void func() {
    int i;          // 함수 블록 시작 부분에만 선언 가능
    // ...
}
```

#### ✅ C99 이후

이제 **아무 위치에서든 변수를 선언**할 수 있음:

```
void func() {
    int x = 5;
    if (x > 0) {
        int y = x + 1;  // ✅ 조건문 안에서 선언 가능
        printf("%d\n", y);
    }
}
```

#### 💡 장점

| 항목          | 설명                                         |
| ------------- | -------------------------------------------- |
| 가독성 향상   | 필요한 위치에서 변수를 바로 선언/초기화 가능 |
| 유지보수 용이 | 블록 범위에 따라 더 명확한 변수 사용 가능    |
| 안전성 증가   | 지역화된 변수는 다른 코드에 영향 미치지 않음 |

### 🧾 3. for 루프 안 변수의 범위 제한

#### 🔄 C89 스타일

```
int i;
for (i = 0; i < 10; i++) {
    // ...
}
```

#### ✅ C99 스타일

```
for (int i = 0; i < 10; i++) {
    // i는 이 블록 내부에서만 유효
}
```

> 블록을 벗어나면 `i`는 **존재하지 않음** → 안전한 스코프 관리 가능

#### 📚 장점

| 항목           | 설명                                    |
| -------------- | --------------------------------------- |
| 스코프 축소    | 루프 종료 후 변수 접근 방지 (오류 감소) |
| 변수 오염 방지 | 다른 코드와의 변수 충돌 가능성 낮음     |
| 캡슐화         | 루프 전용 변수처럼 사용 가능            |

### ✅ 요약 비교표

| 기능                 | C89                  | C99 이후                       |
| -------------------- | -------------------- | ------------------------------ |
| 복합 리터럴          | ❌ 미지원             | ✅ `(int[]){...}` 지원          |
| 변수 선언 위치       | ❌ 블록 시작부만 가능 | ✅ 모든 코드 위치에서 선언 가능 |
| for 루프 변수 스코프 | ❌ 외부에 선언 필요   | ✅ 루프 내부 한정 스코프 지원   |

# 11.2 표준 라이브러리 헤더

## stdio.h, stdlib.h, string.h, math.h, stdbool.h, stdint.h 등

### 📌 주요 C 표준 라이브러리 헤더 정리

### 🟦 1. `<stdio.h>` — 표준 입출력

#### 🧾 개요

**Standard Input/Output Header**
 입력, 출력, 파일 스트림 처리 관련 함수를 제공한다.

#### 📚 주요 함수

| 함수                               | 설명                    |
| ---------------------------------- | ----------------------- |
| `printf`, `scanf`                  | 표준 출력/입력 함수     |
| `fprintf`, `fscanf`                | 파일 입출력             |
| `fopen`, `fclose`                  | 파일 열기/닫기          |
| `fgetc`, `fputc`, `fgets`, `fputs` | 문자/문자열 단위 입출력 |
| `feof`, `ferror`                   | 파일 상태 확인          |

#### 💡 예시

```
#include <stdio.h>
printf("Hello %s\n", name);
```

### 🟩 2. `<stdlib.h>` — 일반 유틸리티 함수

#### 🧾 개요

**Standard Library Header**
 메모리 관리, 형 변환, 난수, 프로세스 종료, 정렬 등의 함수 제공

#### 📚 주요 함수/매크로

| 항목                                  | 설명                 |
| ------------------------------------- | -------------------- |
| `malloc`, `calloc`, `realloc`, `free` | 동적 메모리 관리     |
| `atoi`, `atof`, `strtol`, `strtod`    | 문자열 → 숫자 변환   |
| `exit`, `abort`, `atexit`             | 프로그램 종료/후처리 |
| `rand`, `srand`                       | 난수 생성            |
| `qsort`, `bsearch`                    | 정렬/탐색            |

#### 💡 예시

```
#include <stdlib.h>
int *arr = malloc(sizeof(int) * 10);
qsort(arr, 10, sizeof(int), compare);
```

### 🟥 3. `<string.h>` — 문자열 및 메모리 조작

#### 🧾 개요

**String and Memory Header**
 문자열 및 메모리 복사, 비교, 검색 관련 함수 제공

#### 📚 주요 함수

| 함수                                   | 설명                              |
| -------------------------------------- | --------------------------------- |
| `strlen`, `strcmp`, `strcpy`, `strcat` | 문자열 길이, 비교, 복사, 덧붙이기 |
| `strncpy`, `strncat`                   | 안전한 버전 (길이 지정)           |
| `memcpy`, `memmove`, `memset`          | 메모리 블록 복사, 이동, 초기화    |
| `strchr`, `strstr`                     | 문자/문자열 검색                  |

#### 💡 예시

```
#include <string.h>
if (strcmp(id, "admin") == 0) { ... }
```

### 🟨 4. `<math.h>` — 수학 함수

#### 🧾 개요

**Mathematics Header**
 산술 계산, 삼각 함수, 로그, 거듭제곱 등 고급 수학 함수 제공

#### 📚 주요 함수

| 함수                            | 설명                       |
| ------------------------------- | -------------------------- |
| `sqrt`, `pow`                   | 제곱근, 거듭제곱           |
| `sin`, `cos`, `tan`             | 삼각 함수                  |
| `log`, `exp`                    | 자연로그, 지수             |
| `fabs`, `floor`, `ceil`, `fmod` | 절댓값, 내림, 올림, 나머지 |

> ⚠️ `-lm` 옵션 필요 (GCC 사용 시)

#### 💡 예시

```
#include <math.h>
double r = sqrt(2.0);
```

### 🟧 5. `<stdbool.h>` — 불리언 타입 지원 (C99)

#### 🧾 개요

C99부터 도입된 **Boolean 타입 지원 헤더**

#### 📚 제공 요소

| 요소    | 설명              |
| ------- | ----------------- |
| `bool`  | `_Bool`의 typedef |
| `true`  | 1로 정의됨        |
| `false` | 0으로 정의됨      |

#### 💡 예시

```
#include <stdbool.h>
bool is_valid = true;
```

### 🟪 6. `<stdint.h>` — 고정 크기 정수 타입 (C99)

#### 🧾 개요

플랫폼에 관계없이 **정확한 크기의 정수형 타입 제공**

#### 📚 주요 타입

| 타입                    | 비트 수                   | 설명 |
| ----------------------- | ------------------------- | ---- |
| `int8_t`, `uint8_t`     | 8비트 정수                |      |
| `int16_t`, `uint16_t`   | 16비트 정수               |      |
| `int32_t`, `uint32_t`   | 32비트 정수               |      |
| `int64_t`, `uint64_t`   | 64비트 정수               |      |
| `intptr_t`, `uintptr_t` | 포인터 저장 가능한 정수형 |      |

#### 💡 예시

```
#include <stdint.h>
int32_t counter = 100;
```

### 📊 헤더 기능 요약 비교

| 헤더          | 주요 기능                          | 도입 시기 |
| ------------- | ---------------------------------- | --------- |
| `<stdio.h>`   | 입력/출력, 파일 처리               | C89       |
| `<stdlib.h>`  | 메모리, 정렬, 변환, 종료           | C89       |
| `<string.h>`  | 문자열/메모리 조작                 | C89       |
| `<math.h>`    | 수학 계산 함수                     | C89       |
| `<stdbool.h>` | 불리언 타입 (`bool`) 지원          | C99       |
| `<stdint.h>`  | 고정 크기 정수 타입 (`int32_t` 등) | C99       |

### ✅ 마무리 요약

- `stdio.h`: 표준 입출력, 파일 입출력
- `stdlib.h`: 동적 메모리, 숫자 변환, 정렬
- `string.h`: 문자열 및 메모리 조작
- `math.h`: 고급 수학 함수 (로그, 삼각, 거듭제곱 등)
- `stdbool.h`: `bool`, `true`, `false` 지원 (C99)
- `stdint.h`: `int32_t`, `uint64_t` 등 고정 크기 정수 지원 (C99)

# 11.3 구현 차이와 정의되지 않은 동작

## Undefined Behavior

### 🧾 개요

**Undefined Behavior**란 C 표준에서 **특정 코드의 결과를 정의하지 않기로 명시한 경우**를 말한다.
 즉, 코드가 컴파일되더라도 실행 시 **어떤 결과가 발생할지 보장되지 않으며**,
 컴파일러, 플랫폼, 최적화 레벨에 따라 **예상치 못한 동작**, 심지어 **시스템 오류**까지 일어날 수 있다.

> ⚠️ UB는 **프로그램의 논리 오류 중 가장 위험한 종류**다.
>  디버깅이 매우 어렵고, 잘못된 결과를 "조용히" 낼 수 있기 때문이다.

### 📊 대표적인 Undefined Behavior 목록

| 유형                                  | 예시 코드                      | 설명                             |
| ------------------------------------- | ------------------------------ | -------------------------------- |
| **0으로 나누기**                      | `int x = 10 / 0;`              | 산술 예외 (런타임 충돌 가능)     |
| **초과 배열 접근**                    | `arr[10] = 5;` (배열 크기: 10) | 유효 범위 벗어남                 |
| **사용 전 미초기화 변수**             | `int x; printf("%d", x);`      | 초기값 미정                      |
| **해제된 메모리 접근**                | `free(ptr); *ptr = 5;`         | 해제 후 접근 (Use-After-Free)    |
| **이중 해제**                         | `free(ptr); free(ptr);`        | 포인터 상태 불분명               |
| **NULL 포인터 역참조**                | `int *p = NULL; *p = 5;`       | 세그멘테이션 오류 가능           |
| **signed 오버플로우**                 | `int x = INT_MAX + 1;`         | 부호 있는 정수 오버플로우는 UB   |
| **한 표현식에서 동일 객체 다중 수정** | `i = i++ + 1;`                 | 평가 순서가 정의되지 않음        |
| **비정렬 포인터 접근**                | `int *p = (int *)malloc(3);`   | 정렬되지 않은 주소에 접근        |
| **변수 수명 초과 접근**               | `return &local_var;`           | 함수 종료 후 지역 변수 주소 사용 |

### 🧠 컴파일러와 Undefined Behavior

컴파일러는 UB를 활용해 다음과 같은 **공격적인 최적화**를 수행한다:

```
if (x != 0)
    y = 10 / x;
else
    y = 0;
```

→ 컴파일러는 `x != 0` 조건을 보고 **전체 프로그램에서 x가 0이 아니라고 가정**할 수 있음
 → 따라서 이후 코드에서 `1 / x`로 컴파일될 수도 있다.

💥 만약 `x == 0`이 실제로 들어오면 → 분명한 UB → **예측 불가능한 결과** 발생 가능

### ⚠️ 실전에서 자주 발생하는 UB

| 상황                                      | 설명                                          |
| ----------------------------------------- | --------------------------------------------- |
| 최적화 시 증상이 사라졌다가 다시 생김     | UB가 컴파일러 내부 동작에 영향을 줌           |
| 테스트 환경에서는 OK, 릴리즈에서 충돌     | 릴리즈 빌드는 최적화가 더 강함 (`-O2`, `-O3`) |
| 한 줄 코드는 맞는 것 같은데 결과가 엉뚱함 | 표현식 평가 순서가 정의되지 않았을 수 있음    |

### 💡 Undefined Behavior vs 기타 동작

| 분류                       | 정의                                                | 예                  |
| -------------------------- | --------------------------------------------------- | ------------------- |
| **Undefined Behavior**     | 결과가 전혀 정의되지 않음                           | `x = x++`           |
| **Implementation-defined** | 결과가 컴파일러에 따라 다름 (명세화됨)              | `sizeof(char)`      |
| **Unspecified Behavior**   | 여러 결과 중 하나 선택, 어느 쪽인지는 명확하지 않음 | 함수 인자 평가 순서 |

### ✅ 예방 방법

| 전략                             | 설명                                                  |
| -------------------------------- | ----------------------------------------------------- |
| 컴파일러 경고 활성화             | `-Wall`, `-Wextra`, `-Wuninitialized` 등              |
| 정적 분석 도구 사용              | `clang-tidy`, `cppcheck`, `PVS-Studio` 등             |
| 런타임 검사 도구 사용            | `Valgrind`, `ASan`, `UBSan`                           |
| 초기화 습관화                    | 모든 변수/포인터는 사용 전 반드시 초기화              |
| 표현식 분리                      | `x = x++ + 1;` → 절대 사용 금지. 명확히 분리해서 작성 |
| 테스트 케이스에 릴리즈 빌드 포함 | 릴리즈 최적화(`-O2`)에서 반드시 동작 확인             |

### ✅ 결론 요약

| 항목               | 설명                                             |
| ------------------ | ------------------------------------------------ |
| 정의되지 않은 동작 | C 표준에서 **결과를 정의하지 않는 코드 패턴**    |
| 발생 결과          | 충돌, 쓰레기값, 침묵, 이상 출력 등 **예측 불가** |
| 디버깅 어려움      | 증상이 상황에 따라 달라지므로 추적이 매우 어려움 |
| 방지 전략          | 컴파일러 경고, 분석 도구, 명확한 코드 작성       |

## Implementation-defined Behavior

### 🧾 개요

**Implementation-defined behavior**란 C 표준에서 **동작의 여러 가지 가능성 중 하나를 선택하도록 하고**,
 **컴파일러(또는 플랫폼)가 그 의미를 정의하지만 반드시 문서화해야 하는 동작**을 말한다.

> 📢 즉, "표준은 정하지 않지만, **컴파일러는 반드시 정하고 명시**해야 한다."

### 🧠 정의 계층 비교

| 구분                        | 표준에서의 의미                                              |
| --------------------------- | ------------------------------------------------------------ |
| **Defined behavior**        | 표준이 **정확히 정의한 동작**                                |
| **Implementation-defined**  | 표준이 **컴파일러에게 선택권을 줌**, 선택 내용은 문서화 필요 |
| **Unspecified behavior**    | 어떤 방식이든 가능, 문서화 의무 없음                         |
| **Undefined behavior (UB)** | **결과 없음**, 아무 일이든 일어날 수 있음                    |

### 📚 Implementation-defined Behavior 주요 예시

| 항목                             | 설명                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| `char`가 signed인지 unsigned인지 | `char`는 구현마다 기본 부호 여부가 다름                      |
| `int` overflow 시 결과           | 부호 없는 오버플로우는 정의되어 있으나, 구현별 처리 차이 가능 |
| `printf("%p", void*)` 출력 형식  | 포인터 출력 형식은 구현에 따라 다름                          |
| `right shift` of negative values | 음수를 오른쪽으로 쉬프트할 때의 처리 방식                    |
| `sizeof(char)`의 부호 여부       | `sizeof(char)`는 항상 1이지만, 타입의 부호는 구현 종속       |
| `main()` 함수의 반환형 생략 여부 | `main()`의 정의 형식 (`int main()` vs `void main()`)은 일부 구현에서 허용 |

#### ✨ 예시: `char`의 부호

```
char c = -1;
if (c > 0) {
    printf("positive\n");
}
```

- 어떤 컴파일러에서는 `char`가 **signed** → `c == -1`
- 어떤 컴파일러에서는 `char`가 **unsigned** → `c == 255`

→ ⚠️ **동일 코드, 다른 결과**

#### ✨ 예시: `>>` (right shift) 연산

```
int x = -8;
int result = x >> 2;
```

- 어떤 구현: **산술 쉬프트** → -2
- 어떤 구현: **논리 쉬프트** → 잘못된 양수값

#### ✨ 예시: `printf("%p")` 결과

```
int *ptr = &x;
printf("%p\n", ptr);
```

- 출력 포맷은 구현에 따라 다를 수 있음:
  - GCC: `0x7ffeebc48abc`
  - MSVC: `0012FF6C`
  - 반드시 **문자열 형태와 포맷이 동일할 필요는 없음**

### 📊 구현 정의 vs 정의되지 않은 동작 비교

| 항목           | Implementation-defined     | Undefined Behavior        |
| -------------- | -------------------------- | ------------------------- |
| 동작 선택 여부 | ✅ 컴파일러가 선택함        | ❌ 결과 자체가 없음        |
| 문서화 필요    | ✅ 명시해야 함              | ❌ 없음                    |
| 결과 안정성    | ✅ 동일 컴파일러에선 안정적 | ❌ 환경에 따라 매번 달라짐 |
| 디버깅 가능성  | ✅ 비교적 쉬움              | ❌ 매우 어려움             |

### ⚠️ 주의사항

| 항목           | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| 이식성 문제    | 여러 컴파일러나 플랫폼에서 실행하면 결과가 다를 수 있음      |
| 정의 문서 참고 | `GCC`, `MSVC`, `Clang` 등 컴파일러 문서를 통해 정확한 의미 확인 필요 |
| 테스트 일관성  | 단일 플랫폼에서만 테스트하면 버그가 숨어 있을 수 있음        |
| 코드 명확화    | `char`는 `signed char` 또는 `unsigned char`로 명시하는 습관이 좋음 |

### 💡 이식성 높이는 팁

| 전략                              | 설명                                         |
| --------------------------------- | -------------------------------------------- |
| 명시적 부호 지정                  | `signed char`, `unsigned int` 등 사용        |
| 시프트는 부호 있는 값에 쓰지 않기 | 특히 오른쪽 시프트는 부호 없는 값에만 사용   |
| 정해진 타입 사용                  | `<stdint.h>`의 `int32_t`, `uint8_t` 등 사용  |
| 의존 줄이기                       | `printf("%p")` 대신 자체 형식 함수 사용 고려 |

### ✅ 결론 요약

| 항목           | 설명                                                        |
| -------------- | ----------------------------------------------------------- |
| 정의           | C 표준이 직접 규정하지 않고 컴파일러가 정하도록 위임한 동작 |
| 문서화 여부    | ✅ 반드시 컴파일러/시스템 문서에 정의돼야 함                 |
| 실행 결과      | 컴파일러/플랫폼에 따라 다를 수 있음                         |
| 코드 작성 전략 | 명시적 타입, 명확한 포맷, 의존 줄이기로 이식성 확보         |

