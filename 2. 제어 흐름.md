# 2. 제어 흐름

# 2.1 조건 분기문

## if 문, if-else 문, if-else if 문

C 언어에서 조건문은 **프로그램의 흐름을 조건에 따라 분기**하기 위해 사용된다.
 가장 기본적인 흐름 제어 구문으로, **주어진 조건이 참인지 거짓인지에 따라 특정 블록을 실행하거나 무시**한다.
 조건문은 실제로 코드가 어떤 경로로 실행될지를 결정하므로, 프로그램의 **논리 제어의 중심 축**이라 할 수 있다.

### 🔹 `if` 문: 조건이 참일 때만 실행

```
if (조건식) {
    // 조건이 참일 때 실행될 문장들
}
```

#### 예시:

```
int score = 85;

if (score >= 80) {
    printf("좋은 점수입니다!\n");
}
```

📌 조건식이 **0이 아니면(참이면)** 실행, **0이면(거짓이면)** 실행되지 않음

### 🔸 `if-else` 문: 조건이 거짓일 경우 대안 실행

```
if (조건식) {
    // 조건이 참일 때 실행
} else {
    // 조건이 거짓일 때 실행
}
```

#### 예시:

```
int temp = 15;

if (temp >= 20) {
    printf("따뜻합니다\n");
} else {
    printf("쌀쌀합니다\n");
}
```

📌 `if` 조건이 참일 경우 첫 블록만 실행, 거짓이면 `else` 블록이 실행됨
 두 블록 중 **정확히 하나만 실행된다**

### 🔶 `if-else if-else` 문: 여러 조건 중 하나를 선택

```
if (조건1) {
    // 조건1이 참일 때 실행
} else if (조건2) {
    // 조건2가 참일 때 실행
} else if (조건3) {
    // 조건3이 참일 때 실행
} else {
    // 위 조건이 모두 거짓일 때 실행
}
```

#### 예시:

```
int score = 73;

if (score >= 90) {
    printf("A 학점\n");
} else if (score >= 80) {
    printf("B 학점\n");
} else if (score >= 70) {
    printf("C 학점\n");
} else {
    printf("F 학점\n");
}
```

📌 **위에서 아래로 조건을 평가하며**, **가장 처음 참이 되는 조건만 실행**됨
 모든 조건이 거짓이면 `else` 블록이 실행됨 (없으면 아무 것도 실행되지 않음)

### ⚠️ 주의할 점

1. **중괄호 생략 시 한 줄만 조건에 포함됨**

```
if (x > 0)
    printf("양수입니다\n");
    printf("이 줄은 항상 실행됩니다\n"); // ❗ if와 무관
```

→ **중괄호 `{}`를 항상 사용하는 습관**을 들이는 것이 안전

1. **중첩된 if-else에서 else는 가장 가까운 if에 연결**

```
if (a > 0)
    if (b > 0)
        printf("둘 다 양수\n");
    else
        printf("a가 양수이지만 b는 아님\n");  // else는 바로 앞 if와 연결됨
```

→ 명확히 하려면 `{}` 사용 또는 `else` 위치 조정 필요

### ✅ 요약

| 구문 유형    | 역할                                  | 실행 조건                       |
| ------------ | ------------------------------------- | ------------------------------- |
| `if`         | 조건이 참일 때만 블록 실행            | 조건식이 참 (`!= 0`)일 때       |
| `if-else`    | 조건에 따라 두 블록 중 하나 실행      | 참이면 `if`, 거짓이면 `else`    |
| `if-else if` | 여러 조건 중 첫 번째로 참인 블록 실행 | 위에서 아래로 평가, 하나만 실행 |

🧠 조건문은 C 언어의 **결정 구조(Decision Structure)**를 담당한다.
 조건의 순서, 범위, 중첩 구조를 정확히 파악하고 작성하지 않으면
 프로그램의 흐름이 **비논리적**으로 흘러가거나 **예외 상황이 처리되지 않는** 문제가 발생할 수 있다.
 따라서 항상 **명확한 조건 설계 + 중괄호 습관화 + 예외처리 포함**을 원칙으로 삼는 것이 바람직하다.

## switch 문과 case, default

`switch` 문은 **하나의 변수나 표현식의 값을 기준으로 다수의 분기(branch)를 선택**할 수 있는 조건문이다.
 많은 `if-else if` 문을 깔끔하게 대체할 수 있으며, 각 분기점은 `case` 키워드로 정의되며, 선택되지 않은 경우를 처리하기 위해 `default` 키워드를 사용한다.

### 🧱 기본 문법 구조

```
switch (표현식) {
    case 값1:
        // 표현식 == 값1일 때 실행
        break;
    case 값2:
        // 표현식 == 값2일 때 실행
        break;
    ...
    default:
        // 일치하는 case가 없을 때 실행
}
```

### 📌 핵심 요소 설명

- **`switch (표현식)`**
   반드시 정수형(정수 리터럴, `char`, `int`, `enum`)이어야 하며, `float`, `double` 사용 불가
- **`case 상수:`**
   표현식과 값이 같으면 해당 블록 실행
   `case` 값은 반드시 **정수 상수 또는 상수 표현식**이어야 함
- **`break;`**
   **분기 실행 후 switch 블록을 빠져나가는 명령어**
   break가 없으면 다음 case로 **"떨어진다(fall-through)"**
- **`default:`**
   위의 모든 `case`와 일치하지 않을 때 실행됨 (선택적)

### 🧪 예제

```
#include <stdio.h>

int main() {
    int day = 3;

    switch (day) {
        case 1:
            printf("월요일\n");
            break;
        case 2:
            printf("화요일\n");
            break;
        case 3:
            printf("수요일\n");
            break;
        case 4:
            printf("목요일\n");
            break;
        default:
            printf("해당 없음\n");
    }
    return 0;
}
```

실행 결과:

```
수요일
```

### 🔁 break 생략: fall-through 동작

```
int grade = 2;

switch (grade) {
    case 1:
    case 2:
    case 3:
        printf("합격\n");
        break;
    case 4:
    case 5:
        printf("불합격\n");
        break;
}
```

📌 `case 1`, `case 2`, `case 3`는 모두 `"합격"`을 출력하게 된다.
 → **공통 처리를 위해 break 생략 가능** (단, 의도를 명확히 할 것)

### 🚫 주의사항

- `switch`의 `표현식`은 **실수형(`float`, `double`) 사용 불가**
- `case`의 값은 반드시 **컴파일 타임 상수**여야 한다 (변수는 안 됨)
- `default`는 없어도 되지만 **추가하는 것이 안전** (예외 처리용)

### ✅ 요약

| 키워드    | 설명                                         |
| --------- | -------------------------------------------- |
| `switch`  | 하나의 정수 표현식에 대해 여러 분기 정의     |
| `case`    | 특정 값과 일치할 경우 실행할 코드 정의       |
| `break`   | 실행 후 switch 블록 탈출                     |
| `default` | 어떤 case에도 해당되지 않을 경우 실행할 코드 |

🧠 `switch` 문은 복잡한 분기를 단순화하고,
 **정수 기반 명확한 상태 분류, 메뉴 시스템, 명령 코드 처리, 문자 입력 분기 등**에 특히 적합하다.
 단, break 누락으로 인한 fall-through 오류는 **자주 발생하는 실수 중 하나**이므로 항상 **의도를 명확히 표현하는 코드 스타일**이 중요하다.

# 2.2 반복문

## for 문

`for` 문은 **정해진 횟수만큼 반복 수행**할 때 가장 적합한 반복 제어 구조다.
 반복의 초기값 설정, 조건 검사, 증감 연산을 **하나의 문장 안에 통합**해서 작성할 수 있으므로,
 반복의 구조가 명확하고 간결하게 표현된다.

### 🔧 기본 문법

```
for (초기식; 조건식; 증감식) {
    // 반복할 코드 블록
}
```

| 구성 요소 | 설명                                                |
| --------- | --------------------------------------------------- |
| `초기식`  | 반복 시작 전 한 번만 실행 (보통 카운터 변수 초기화) |
| `조건식`  | 반복을 계속할지 결정 (참이면 반복, 거짓이면 종료)   |
| `증감식`  | 한 번 반복 후 매번 실행 (카운터 증가/감소 등)       |

### 🧪 기본 예제

```
for (int i = 0; i < 5; i++) {
    printf("%d\n", i);
}
```

📌 출력:

```
0  
1  
2  
3  
4
```

### 🔄 실행 흐름

1. `초기식` 실행 (한 번만)
2. `조건식` 평가 → 참이면 반복 시작, 거짓이면 종료
3. 블록 내부 실행
4. `증감식` 실행
5. 다시 조건식 평가로 돌아감 → 반복

### 🔁 무한 루프

```
for (;;) {
    // 조건이 없기 때문에 무한 반복
}
```

또는:

```
c코드 복사for (int i = 0; ; i++) {
    // 조건이 없으므로 종료되지 않음
}
```

### 📌 다양한 활용 예

#### 1. 역방향 반복

```
for (int i = 10; i > 0; i--) {
    printf("%d\n", i);
}
```

#### 2. 짝수만 출력

```
for (int i = 0; i <= 10; i += 2) {
    printf("%d\n", i);
}
```

#### 3. 다중 변수 제어

```
for (int i = 0, j = 10; i < j; i++, j--) {
    printf("i=%d, j=%d\n", i, j);
}
```

### ✴️ 중첩 for 문

```
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        printf("(%d, %d) ", i, j);
    }
    printf("\n");
}
```

📌 2차원 배열, 행렬, 도트 찍기 등에 유용

### ⚠️ 주의 사항

- 조건식이 항상 참이면 **무한 루프** 발생 가능
- 반복 변수는 블록 내부에서만 유효 (`int i = 0;`일 경우 C99 이상부터 가능)
- 조건식이 처음부터 거짓이면 **한 번도 실행되지 않음**
- 무한 루프에서 반드시 `break` 또는 `return`으로 빠져나올 수 있도록 작성해야 함

### ✅ 요약

| 구성 요소 | 역할                   | 예시        |
| --------- | ---------------------- | ----------- |
| 초기식    | 반복 변수 초기화       | `int i = 0` |
| 조건식    | 반복 계속 여부 판단    | `i < 10`    |
| 증감식    | 반복 후 변수 증가/감소 | `i++`       |
| 실행 블록 | 반복할 코드            | `{ ... }`   |

🧠 `for` 문은 **반복 횟수가 명확한 경우**, 특히 **배열 순회, 카운트, 표 출력, 알고리즘 루프**에 가장 효과적이다.
 초기화, 조건, 증감이 한 줄에 정리되어 있으므로, 반복의 전체 구조를 **한눈에 파악할 수 있는 장점**이 있다.
 단순 반복일수록 `for`, 조건 중심 반복일수록 `while`이 더 적합하다.

## while 문

`while` 문은 **조건이 참인 동안 계속해서 반복 수행**하는 반복문이다.
 조건이 **거짓이 되기 전까지 무제한 반복**되며, 조건에 따라 **0번 또는 무한번 실행될 수 있는 구조**를 갖는다.
 `for` 문이 반복 횟수가 명확할 때 주로 사용된다면, `while` 문은 **조건 중심의 반복에 적합**하다.

### 🔧 기본 문법

```
while (조건식) {
    // 반복할 코드 블록
}
```

- `조건식`이 **참(0이 아닌 값)**이면 블록을 실행
- 조건이 처음부터 거짓이면 **한 번도 실행되지 않음**

### 🧪 예제 1: 0부터 4까지 출력

```
int i = 0;

while (i < 5) {
    printf("%d\n", i);
    i++;
}
```

출력:

```
0  
1  
2  
3  
4
```

### 🔁 실행 흐름

1. 조건식 평가
2. 참이면 블록 실행
3. 다시 조건식으로 돌아감
4. 거짓이 되면 종료

📌 조건식 → 실행 → 조건식 → 실행 ...
 (조건이 먼저 평가되므로 "선평가 반복문"이라 부름)

### 🌀 무한 루프

```
while (1) {
    // 계속 반복됨
}
```

또는:

```
while (true) {} // C99 이상에서 _Bool 또는 stdbool.h 사용
```

→ 반드시 `break`, `return` 등으로 탈출 조건 명시해야 함

### 🧪 예제 2: 사용자 입력 받기

```
int num;
while (1) {
    printf("숫자를 입력하세요 (0 입력 시 종료): ");
    scanf("%d", &num);
    if (num == 0)
        break;
    printf("입력한 숫자: %d\n", num);
}
```

### ⚠️ 주의사항

- **조건을 조절하지 않으면 무한 루프 발생**
   (예: 증가식 빠진 반복문)

```
int i = 0;
while (i < 5) {
    printf("i = %d\n", i);
    // i++; ← 빠지면 무한 루프
}
```

- 실수형 조건은 오차로 인해 **무한 루프에 빠질 수 있음**
   → `fabs()` 같은 안전한 비교 필요

### ✅ 요약

| 항목        | 설명                                           |
| ----------- | ---------------------------------------------- |
| 구조        | `while (조건) { 반복 실행문 }`                 |
| 평가 시점   | 반복 전에 조건 평가 (0이면 아예 실행 안 됨)    |
| 적합한 상황 | 종료 조건이 불확실하거나 외부 이벤트 기반 반복 |
| 특징        | 선조건 평가, 무한 반복 가능                    |

🧠 `while` 문은 **조건 중심의 유연한 반복 제어**를 제공하며,
 특히 **사용자 입력, 파일 처리, 센서 감지, 네트워크 대기 등**
 **이벤트 기반 처리**에서 자주 사용된다.
 루프 내부에서 **반드시 상태 변화가 발생**하도록 코드를 작성하지 않으면, 의도치 않은 **무한 루프**에 빠지기 쉽다.
 → 따라서 항상 **조건식과 반복 내용 사이의 관계**를 명확히 설계하는 것이 핵심이다.

## do-while 문

`do-while` 문은 C 언어의 **반복문 중 유일하게 "후조건 검사(post-check loop)"**를 수행하는 구조다.
 즉, **조건과 상관없이 최소 한 번은 실행**되고, 그 다음에 조건을 검사하여 반복 여부를 결정한다.

이는 `while` 문과 유사하지만, **조건 평가 시점이 뒤에 위치**한다는 점에서 차별화된다.

### 🔧 기본 문법

```
do {
    // 반복할 코드 블록
} while (조건식);
```

- 실행 블록을 먼저 실행한 뒤
- `조건식`이 참이면 반복, 거짓이면 종료
- **세미콜론(;)이 문법상 반드시 필요**함 (`while` 뒤에 붙임!)

### 🧪 예제 1: 최소 한 번 실행

```
int i = 0;

do {
    printf("%d\n", i);
    i++;
} while (i < 5);
```

📌 출력 결과:

```
0  
1  
2  
3  
4
```

### 🧪 예제 2: 조건이 처음부터 거짓이어도 1회 실행

```
int i = 10;

do {
    printf("한 번은 실행됩니다: i = %d\n", i);
} while (i < 5);
```

📌 출력 결과:

```
한 번은 실행됩니다: i = 10
```

### 🔁 실행 흐름 요약

1. 코드 블록 실행
2. 조건식 평가
3. 참이면 반복, 거짓이면 종료

이 구조로 인해 **최소 1회 실행 보장**

### ✍️ 실전 활용 예: 사용자 재입력 요청

```
int input;

do {
    printf("양의 정수를 입력하세요: ");
    scanf("%d", &input);
} while (input <= 0);

printf("입력한 값: %d\n", input);
```

🧩 잘못된 입력이 들어와도 **무조건 한 번 입력을 받고**,
 조건이 충족되지 않으면 재입력을 유도함

### ✅ `do-while` vs `while` 비교

| 항목               | `while` 문                  | `do-while` 문                       |
| ------------------ | --------------------------- | ----------------------------------- |
| 조건 평가 시점     | 반복 전에 조건 확인         | 반복 후에 조건 확인                 |
| 최소 실행 횟수     | 0번 가능                    | **무조건 1번 이상 실행**            |
| 세미콜론 필요 여부 | 필요 없음                   | **`while (...);` → 세미콜론 필요**  |
| 대표 사용 상황     | 조건이 명확히 선행되는 경우 | 사용자가 입력, 메뉴 선택, 초기화 등 |

### ⚠️ 주의 사항

- `while` 뒤에 **세미콜론(`;`) 반드시 필요**

  ```
  } while (x < 10);  // ← 이거 필수!
  ```

- 조건이 항상 참이면 **무한 루프** 발생

### ✅ 요약

| 요소      | 설명                                         |
| --------- | -------------------------------------------- |
| 문법 구조 | `do { ... } while (조건);`                   |
| 평가 시점 | 실행 후 조건 평가 (후조건 검사)              |
| 최소 실행 | 반드시 1번 이상                              |
| 대표 용도 | 사용자 입력, 초기화 루틴, 유효성 재확인 루프 |

🧠 `do-while`은 그 자체로 드물게 쓰일 수 있으나,
 **조건을 후에 검사해야 할 때 유일하게 정확한 표현 도구**다.
 사용자의 **첫 행동을 반드시 받아야 할 때**,
 또는 **초기 상태 설정 → 검사 → 반복**이 필요한 상황에서
 `do-while`은 명확하고 의미 있는 선택이 된다.

## break 및 continue의 제어

`break`와 `continue`는 **반복문(`for`, `while`, `do-while`) 내부에서 흐름 제어를 즉시 변경**하는 데 사용되는 키워드다.
 이들은 조건문(`if`)과 함께 사용되어, 반복 루프 내에서 **특정 조건일 때 루프를 조기 종료하거나 다음 반복으로 건너뛰도록** 만든다.

### 🛑 `break`: 반복문 또는 `switch` 블록 **즉시 탈출**

```
for (int i = 0; i < 10; i++) {
    if (i == 5)
        break;
    printf("%d ", i);
}
```

📌 출력: `0 1 2 3 4`

- `i == 5`일 때 `break`가 실행되어 **루프 종료**
- 반복 조건이 남아 있어도 **즉시 루프 블록을 벗어남**

🧩 `break`는 다음 상황에서 사용됨:

- `for`, `while`, `do-while` 루프의 조기 종료
- `switch` 문의 case 블록 종료

### 🔁 `continue`: **이번 반복만 중단하고 다음 반복으로 점프**

```
for (int i = 0; i < 5; i++) {
    if (i == 2)
        continue;
    printf("%d ", i);
}
```

📌 출력: `0 1 3 4`

- `i == 2`일 때 `continue` 실행 → `printf()`는 건너뛰고 증감식으로 바로 이동
- **다음 반복 조건 검사로 점프**

### 🧪 예제: `break`와 `continue` 비교

```
#include <stdio.h>

int main() {
    for (int i = 0; i < 5; i++) {
        if (i == 3)
            break;
        printf("break: i = %d\n", i);
    }

    for (int i = 0; i < 5; i++) {
        if (i == 3)
            continue;
        printf("continue: i = %d\n", i);
    }

    return 0;
}
```

출력:

```
break: i = 0  
break: i = 1  
break: i = 2  
continue: i = 0  
continue: i = 1  
continue: i = 2  
continue: i = 4
```

### ⛓️ 중첩 루프에서의 `break` 제어

```
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == j)
            break; // 내부 루프만 종료
        printf("i=%d j=%d\n", i, j);
    }
}
```

📌 `break`는 **자신이 속한 가장 가까운 반복문만 종료**
 중첩 루프 전체를 빠져나가려면 **플래그 변수**나 **goto** 같은 구조적 방법 필요

### ✅ 요약 비교

| 키워드     | 동작                                   | 영향 범위        | 사용 위치                      |
| ---------- | -------------------------------------- | ---------------- | ------------------------------ |
| `break`    | 현재 반복문(또는 switch) 즉시 종료     | 가장 가까운 루프 | `for`, `while`, `do`, `switch` |
| `continue` | 이번 루프 반복 건너뛰고 다음 반복 진행 | 현재 루프만      | `for`, `while`, `do`           |

### ⚠️ 주의 사항

- `break`와 `continue`의 사용은 **가독성을 떨어뜨릴 수도 있으므로 남용 금지**
- 루프를 탈출해야 하는 명확한 **비상 조건**에서만 `break` 사용
- **조건문 없이 무작정 사용하면** 코드 흐름이 혼란스러워짐

🧠 `break`와 `continue`는 반복문의 흐름을 **정밀하게 제어**하는 도구다.
 단순한 반복을 넘어, **조건 기반 탈출, 입력 유효성 처리, 탐색 최적화, 필터링 로직** 등에 유용하게 사용된다.
 다만, **제어 흐름이 복잡해질수록 코드 이해가 어려워지므로**,
 **명확한 조건과 의도를 갖고 사용할 것**이 고급 C 프로그래밍에서의 핵심 원칙이다.

# 2.3 기타 흐름 제어

## goto 문과 label

`goto` 문은 프로그램의 흐름을 **임의의 지점(label)으로 무조건적으로 이동**시키는 제어문이다.
 특정 조건이나 루프의 중첩과 관계없이 **즉시 코드의 지정된 위치로 점프**하므로,
 **반복문이나 조건문 없이도 흐름을 변경할 수 있다.**

하지만 `goto`는 **구조적 프로그래밍(structured programming)** 원칙을 위배할 수 있기 때문에,
 대부분의 경우 **사용이 권장되지 않으며**, 특별한 상황에서만 제한적으로 사용된다.

### 🔧 기본 문법

```
goto 라벨이름;

// ...

라벨이름:
    문장;
```

- `label:`은 특정 위치를 **이름으로 지정**한 것으로, `goto` 문에서 점프할 수 있는 대상
- `label`은 **중복될 수 없으며**, 반드시 코드 줄의 맨 앞에서 정의해야 한다

### 🧪 예제: 단순 점프

```
#include <stdio.h>

int main() {
    printf("시작\n");
    goto skip;

    printf("이 문장은 실행되지 않음\n");

skip:
    printf("점프 이후 실행됨\n");
    return 0;
}
```

📌 출력:

```
시작  
점프 이후 실행됨
```

- `goto skip;`은 프로그램 흐름을 `skip:`으로 직접 이동시킴
- 중간의 `printf("이 문장...")`는 건너뛰어짐

### 🧪 예제: 중첩 루프 탈출 (일반적인 사용 사례)

```
for (int i = 0; i < 5; i++) {
    for (int j = 0; j < 5; j++) {
        if (i + j > 6)
            goto exit;
    }
}
exit:
printf("중첩 루프 탈출 완료\n");
```

📌 여러 반복문을 한 번에 빠져나가는 목적으로 사용될 수 있음
 → `break`로는 안 되는 **다단계 탈출**을 구현할 수 있음

### ✅ `goto` 사용이 적절한 상황

- 중첩 루프나 조건이 너무 깊어서 코드 가독성이 나쁠 때
- **에러 발생 후 빠르게 정리하고 탈출**해야 할 때 (특히 자원 해제 등)
- C 커널, 시스템 드라이버, 상태 머신 구현 등에서 제한적으로 사용

### ❌ `goto` 남용 시 문제점

- 프로그램의 흐름이 **비직관적, 추적 어려움**
- **디버깅과 유지보수 비용 증가**
- `goto`가 많은 코드는 일명 **"spaghetti code" (스파게티 코드)"**라고 불리며, **구조가 얽히고 설켜 있음**

### ✅ 요약

| 요소      | 설명                                                     |
| --------- | -------------------------------------------------------- |
| `goto`    | 흐름을 지정된 label로 무조건 점프                        |
| `label:`  | 점프 대상 위치를 이름으로 정의                           |
| 적절한 예 | 중첩 루프 탈출, 오류 처리 루틴 정리                      |
| 주의할 점 | 남용 시 가독성 저하, 유지보수 어려움, 프로그램 흐름 왜곡 |

🧠 `goto`는 금기시되는 연산자처럼 여겨지기도 하지만,
 **제한적이고 통제된 환경에서 사용할 경우 매우 강력한 도구**가 될 수 있다.
 **자원 해제, 중단 조건 처리, 다단계 반복 탈출, 저수준 상태 제어** 등
 **다른 제어문으로 표현이 어렵거나 복잡한 경우**, 오히려 코드의 간결성을 높일 수 있다.

그러나 구조적인 흐름으로 표현 가능한 경우엔 `goto` 대신
 **`if`, `switch`, `break`, `continue`, 함수 분리** 등의 방식을 우선 고려해야 한다.

## return 문과 함수 탈출

`return` 문은 C 언어에서 **함수를 즉시 종료하고**,
 **호출한 쪽에 값을 반환**하거나 아무 것도 반환하지 않고 **제어 흐름을 함수 밖으로 돌리는** 명령어다.
 함수의 실행 흐름을 끝내고 결과를 돌려주는 **가장 기본적이고 중요한 수단**이다.

### 🔧 기본 문법

```
return;         // 반환값 없음 (void 함수에서만)
return 값;      // 반환값이 있는 함수에서 사용
```

- `return 값;` 은 함수 선언에 명시된 **반환형(return type)**과 반드시 일치해야 함
- `return;` 은 `void`형 함수에서만 사용 가능

### 🧩 예제 1: 정수 반환 함수

```
int add(int a, int b) {
    return a + b;
}
```

- `add(3, 4)`를 호출하면 **7이 호출 위치로 반환됨**
- 함수 실행은 `return` 시점에서 즉시 종료됨

### 🧩 예제 2: void 함수에서 `return`

```
void print_message() {
    printf("중간 메시지\n");
    return; // 조기 종료 가능
}
```

- `return;`은 **값 없이 함수 종료**
- `void` 함수라도 `return` 없이도 끝날 수 있지만, **명시하면 의도가 분명해짐**

### 🧩 예제 3: 조건에 따른 조기 탈출

```
int divide(int a, int b) {
    if (b == 0) {
        printf("0으로 나눌 수 없습니다!\n");
        return -1;
    }
    return a / b;
}
```

- `b == 0`일 경우, 나눗셈 대신 에러 메시지 출력 후 **함수 탈출**
- **조기 탈출 방식(early return)**은 코드 복잡도를 낮출 수 있음

### 🔁 여러 `return` 존재 가능

```
int classify(int score) {
    if (score >= 90) return 1;
    if (score >= 80) return 2;
    return 3;
}
```

- 여러 `return` 문이 존재해도 가장 먼저 도달하는 하나만 실행됨
- 이후의 코드는 절대 실행되지 않음 (컴파일러가 경고할 수 있음)

### ⚠️ 주의 사항

- `return` 이후의 코드는 **죽은 코드(dead code)**로 간주됨 → 컴파일러 경고
- 함수의 반환형과 반환값의 **자료형이 일치해야 함**

```
float f() {
    return 1;     // OK: int → float 자동 변환
}

int g() {
    return 3.14;  // 경고: float → int → 소수점 손실
}
```

- 반환 없이 끝나는 `non-void` 함수는 **컴파일러 오류 또는 경고**

### ✅ 요약

| 형태              | 설명                           | 사용 예시                      |
| ----------------- | ------------------------------ | ------------------------------ |
| `return;`         | 함수 즉시 종료 (반환 없음)     | `void` 함수에서만              |
| `return 값;`      | 함수 종료 + 호출자에게 값 전달 | `int`, `float`, 포인터 등 반환 |
| 조기 반환(조건문) | 특정 조건에서 함수 조기 종료   | 에러 체크, early-exit 전략     |

🧠 `return`은 단순한 반환 그 이상이다.
 **함수의 제어 흐름, 상태 전달, 에러 처리, 최적화 루틴 구성**의 핵심이며,
 특히 **조기 탈출(early return)**은 복잡한 중첩 제어문을 간결하게 만드는 **현대적 코드 스타일**의 핵심 전략이기도 하다.
 **하나의 함수에는 하나의 `return`만 존재해야 한다**는 고전적인 규칙보다는,
 **의도가 분명하고 명확한 탈출 지점 설계**가 더 중요하다는 것이 현대적 관점이다.