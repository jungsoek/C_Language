# 3. 함수

# 3.1 함수 구조

## 함수 선언과 정의

C 언어에서 함수는 **작업 단위를 모듈화하여 코드의 재사용성, 구조화, 유지보수성**을 향상시키는 핵심 구성 요소다.
 함수를 사용하려면 먼저 **선언(declaration)**과 **정의(definition)**의 개념을 이해해야 한다.

### 🔹 함수 선언 (Function Declaration / Prototype)

함수 선언은 **함수의 존재와 인터페이스를 컴파일러에게 미리 알리는 것**이다.
 함수의 **반환형, 이름, 매개변수 타입**만 명시되며, 본문은 없음.

```
반환형 함수이름(매개변수목록);
```

#### 예시:

```
int add(int a, int b);
void print_message(void);
float compute_area(float radius);
```

📌 함수 선언은 보통 **헤더 파일(header file)** 또는 소스 파일의 상단에 위치함
📌 선언 없이 함수 사용 시 컴파일러는 경고 또는 오류 발생

### 🔸 함수 정의 (Function Definition)

함수 정의는 **실제로 함수가 수행할 작업을 구현하는 부분**이다.
 선언과 달리 함수의 **본문 `{ ... }`**이 포함되어 있음.

```
반환형 함수이름(매개변수목록) {
    // 실행할 코드
    return 반환값;  // (void형은 생략 가능)
}
```

#### 예시:

```
int add(int a, int b) {
    return a + b;
}

void print_message(void) {
    printf("Hello, world!\n");
}
```

### 🧪 선언과 정의를 나눠 사용하는 예

```
#include <stdio.h>

// 함수 선언
int square(int);

// main 함수
int main() {
    int result = square(5);
    printf("제곱: %d\n", result);
    return 0;
}

// 함수 정의
int square(int x) {
    return x * x;
}
```

- 컴파일러는 `main()`에서 `square()`를 사용하기 전에 **해당 함수의 시그니처를 알아야 하므로**,
   **함수 선언(prototype)**이 필요하다
- 실제 구현은 파일 하단에 위치

### ✅ 함수 선언 vs 정의 비교

| 항목           | 함수 선언                     | 함수 정의                       |
| -------------- | ----------------------------- | ------------------------------- |
| 목적           | 컴파일러에게 함수의 정보 전달 | 함수의 실제 동작 구현           |
| 형식           | `반환형 이름(매개변수);`      | `반환형 이름(매개변수) { ... }` |
| 위치           | 보통 헤더 파일(.h), 상단      | 소스 파일(.c) 중간~하단         |
| 중복 여부      | 여러 번 가능                  | 단 한 번만 허용                 |
| 본문 포함 여부 | ❌ 없음                        | ✅ 있음                          |

### 📌 매개변수와 반환형 예시 모음

| 함수 헤더                | 설명                             |
| ------------------------ | -------------------------------- |
| `int sum(int a, int b);` | 두 개의 int 값을 받아 int 반환   |
| `void print_msg(void);`  | 인수 없이 메시지 출력, 반환 없음 |
| `float area(float r);`   | 실수 하나 받아 실수 반환         |
| `int max(int, int);`     | 매개변수 이름 생략 가능          |

### ⚠️ 주의 사항

- **선언과 정의를 혼동하지 말 것**
   선언은 사용 가능하게 하고, 정의는 실제 동작을 지정함
- **반환형과 매개변수의 타입이 일치해야 함**
- 선언 없이 함수 호출 시 오래된 컴파일러는 암묵적으로 `int` 반환으로 추정했으나,
   현대 C에서는 **반드시 선언이 필요**함

🧠 함수 선언과 정의의 분리는
 **코드의 구조화**, **다중 파일 프로젝트**, **인터페이스와 구현 분리**의 기본 개념이다.
 이는 라이브러리 설계, 헤더 파일 구조, API 설계의 근간이 되므로
 **초기부터 명확하게 구분하고, 일관된 함수 스타일**을 유지하는 것이 중요하다.

## 매개변수와 반환값

함수는 **입력(매개변수)**을 받아 처리한 후, **출력(반환값)**을 결과로 제공한다.
 이 두 개념은 함수가 데이터를 주고받는 가장 기본적인 방식으로,
 **함수의 유연성, 재사용성, 모듈화 구조**를 만드는 핵심 요소다.

### 🧩 1. 매개변수 (Parameters)

#### 개념

매개변수는 함수가 **호출될 때 전달받는 입력 값의 변수**다.
 함수 정의나 선언 시 괄호 안에 지정하며, **자료형과 이름을 포함**한다.

```
int add(int a, int b); // a, b는 매개변수
```

#### 동작 방식

C 언어는 기본적으로 **값에 의한 전달(call by value)**을 수행하므로,
 함수 내부에서 매개변수를 변경해도 **원래 인자에는 영향이 없다**.

```
void modify(int x) {
    x = 100;
}

int main() {
    int a = 5;
    modify(a);
    printf("%d\n", a);  // 출력: 5 (a는 변경되지 않음)
}
```

📌 **원래 값을 변경하려면 포인터를 사용해야 함**

```
void modify(int *x) {
    *x = 100;
}
```

### 🧩 2. 반환값 (Return Value)

#### 개념

함수가 **처리 결과를 호출자에게 돌려주는 값**이다.
 `return` 문을 사용하며, 반환값의 **자료형은 함수 선언에 명시된 반환형**과 일치해야 한다.

```
int square(int n) {
    return n * n;
}
```

- 반환값은 함수를 호출한 위치에서 **하나의 값으로 사용 가능**
- `return`이 실행되면 함수는 **즉시 종료**

#### 반환값이 없는 경우 (`void`)

```
void greet() {
    printf("Hello!\n");
}
```

- `return;`만 사용하거나 생략 가능
- 호출한 쪽은 결과를 받지 않음

### 🧪 예제: 매개변수 + 반환값

```
int multiply(int a, int b) {
    return a * b;
}

int main() {
    int result = multiply(4, 5);
    printf("결과: %d\n", result);
    return 0;
}
```

📌 `4`와 `5`가 매개변수로 전달되고, 함수는 `20`을 반환하여 `result`에 저장

### 🧪 예제: 포인터를 이용한 다중 결과 반환

C 언어에서는 함수가 **하나의 값만 반환할 수 있으므로**,
 여러 값을 반환하려면 **포인터를 사용한 간접 전달** 방식으로 처리한다.

```
void divide(int a, int b, int *quotient, int *remainder) {
    *quotient = a / b;
    *remainder = a % b;
}
c코드 복사int q, r;
divide(10, 3, &q, &r);
// q == 3, r == 1
```

### ✅ 요약

| 항목           | 설명                          |
| -------------- | ----------------------------- |
| 매개변수       | 함수가 입력으로 받는 값들     |
| 기본 전달 방식 | 값 복사 (call by value)       |
| 다중 반환      | 포인터로 변수 주소 전달       |
| 반환값         | 함수가 호출자에게 돌려주는 값 |
| 반환형 `void`  | 반환값이 없을 때 사용         |

🧠 매개변수와 반환값은 **함수의 입출력 인터페이스**로서,
 단순한 자료 전달을 넘어 **함수의 계약(contract)과 동작 의미**를 정의하는 핵심 구성이다.
 C는 반환값이 하나지만, 포인터와 구조체, 전역 변수 등을 조합해 **다양한 데이터 흐름을 설계**할 수 있으며,
 **자료형의 명확성과 호출 규칙의 일관성**은 안정적인 프로그램 구조의 기초가 된다.

## 함수 호출 방식

C 언어에서 **함수 호출 방식**이란, 함수를 호출할 때 **인자(argument)**가 **함수의 매개변수(parameter)**로 **어떻게 전달되고 처리되는지**를 의미한다.
 C 언어는 기본적으로 **값에 의한 호출 (Call by Value)**만을 지원하며,
 다른 호출 방식은 **포인터(pointer)**를 통해 **간접적으로 구현**한다.

### 🔹 1. 값에 의한 호출 (Call by Value) ― **기본 방식**

```
int square(int x) {
    x = x * x;
    return x;
}

int main() {
    int a = 5;
    square(a);
    printf("%d\n", a);  // 출력: 5 (a는 그대로)
}
```

📌 설명:

- **실제 값(a의 복사본)**이 `square()` 함수에 전달됨
- 함수 내부에서 `x`가 변경되더라도, **원래 변수 `a`는 전혀 영향을 받지 않음**
- **안전하고 독립적인 처리**가 가능하지만, **결과를 직접 반환하거나 포인터 사용 필요**

### 🔸 2. 참조에 의한 호출 (Call by Reference) ― **포인터로 구현**

```
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

```
int x = 3, y = 7;
swap(&x, &y);
printf("x=%d, y=%d\n", x, y);  // 출력: x=7, y=3
```

📌 설명:

- `&x`, `&y`는 변수의 **주소(address)**를 전달함
- `swap()` 함수는 포인터(`*a`, `*b`)를 통해 **원본 변수의 메모리 위치**를 직접 수정
- **실제 변수 값 자체가 변경됨**

### 🔹 3. 배열 인자의 호출 ― **자동 참조 전달 (배열은 포인터로 decay)**

```
void print_arr(int arr[], int len) {
    for (int i = 0; i < len; i++)
        printf("%d ", arr[i]);
}
```

📌 설명:

- 배열 이름 `arr`은 자동으로 `int*` 포인터로 변환됨
- 배열은 **항상 주소(참조)**를 전달하므로, 함수 내부에서 **내용 변경 가능**

```
void set_zero(int arr[], int len) {
    for (int i = 0; i < len; i++)
        arr[i] = 0;
}
```

→ 호출한 쪽의 배열도 실제로 0으로 초기화됨

### 🔸 4. 다중 값 반환을 위한 포인터 전달

```
void divide(int a, int b, int *q, int *r) {
    *q = a / b;
    *r = a % b;
}
```

📌 함수가 반환할 수 있는 값은 1개뿐이므로, **포인터를 통해 다중 결과를 구현**

### ✅ 요약 비교

| 호출 방식         | 설명                           | 내부 전달 방식          | 원본 변경 가능 여부 |
| ----------------- | ------------------------------ | ----------------------- | ------------------- |
| Call by Value     | 값 복사                        | 값 자체 복사            | ❌ (복사본만 수정됨) |
| Call by Reference | 주소 전달                      | 포인터를 통해 직접 참조 | ✅ (원본 수정됨)     |
| 배열 전달         | 자동 참조로 해석 (`int arr[]`) | 내부적으로 포인터 전달  | ✅ (내용 수정 가능)  |
| 다중 반환 구현    | 여러 개의 포인터 인자 전달     | 포인터 직접 수정        | ✅                   |

🧠 C 언어는 엄격하게는 **Call by Value 언어**이다.
 **Call by Reference는 포인터를 명시적으로 사용**하여 개발자가 직접 구현해야 한다.
 이 점은 **메모리 직접 제어가 가능한 고성능 시스템 프로그래밍**에 매우 적합하며,
 **함수의 설계 목적에 따라 값을 복사할지 참조할지 판단하는 명확한 책임**이 개발자에게 주어진다는 특징이 있다.

# 3.2 함수 인자 전달

## 값에 의한 호출

**값에 의한 호출(Call by Value)**은 C 언어의 기본 함수 호출 방식이다.
 함수를 호출할 때, **인자의 실제 값이 복사되어 함수의 매개변수에 전달**된다.
 이로 인해 **함수 내부에서 매개변수를 변경해도, 원래 변수에는 전혀 영향을 주지 않는다.**

### 🔧 작동 방식

```
int square(int x) {
    x = x * x;
    return x;
}
```

```
int main() {
    int a = 5;
    int result = square(a);
    printf("a = %d, result = %d\n", a, result);
    return 0;
}
```

📌 출력:

```
a = 5, result = 25
```

- `square(a)`를 호출하면 `a`의 값 **5가 복사되어** `x`에 전달됨
- `x`가 바뀌어도 **`a`는 영향을 받지 않음**
- 함수는 내부에서 계산한 값을 반환할 수는 있지만, 외부 변수는 그대로 유지됨

### 🧠 특징 요약

| 항목           | 설명                                                        |
| -------------- | ----------------------------------------------------------- |
| 전달 방식      | 값 복사 (복제본 생성)                                       |
| 원본 변수 영향 | ❌ 없음 (함수 내부에서 변경해도 외부 변수는 그대로)          |
| 메모리 사용    | 원본 외에 매개변수용 **추가 메모리** 사용                   |
| 안전성         | ✅ 외부 상태에 영향을 주지 않으므로 부작용(side effect) 없음 |
| 성능 영향      | ❌ 큰 구조체 전달 시 복사 비용 발생                          |
| 기본 지원 여부 | ✅ C 언어의 기본 호출 방식                                   |

### 🧪 예제: 함수 내부 변경이 외부에 영향 없음

```
void modify(int x) {
    x = 100;
    printf("함수 내부 x = %d\n", x); // 100
}

int main() {
    int num = 5;
    modify(num);
    printf("함수 외부 num = %d\n", num); // 5
}
```

📌 `modify()` 함수 내부에서 `x`는 변경되지만, 외부의 `num`은 변경되지 않음

### ✅ 장점

- 함수 내부에서 **입력 값을 안전하게 수정 가능**
- 외부 변수와 **격리된 연산**이 가능 → 예측 가능한 함수 동작
- 간단한 타입(int, float 등)에선 **복사 비용 작고 효율적**

### ⚠️ 단점

- 원본 값을 변경하고 싶을 때는 **별도로 포인터를 사용해야 함**
- 큰 구조체나 배열을 전달하면 **복사 비용 증가**
- **출력이 2개 이상 필요한 경우**에는 반환값 하나로는 부족 → 포인터 필요

### 📌 실제 활용 예

```
int add(int a, int b) {
    return a + b;
}
```

- `a`와 `b`는 값으로 전달되므로, 함수는 **안전하게 연산 결과만 반환** 가능
- `add(3, 4)` → `a = 3`, `b = 4`는 독립적인 복사본으로 동작함

🧠 **값에 의한 호출**은 함수의 **독립성과 안정성**을 높이며,
 변수의 **의도하지 않은 변경을 방지**할 수 있는 중요한 제어 방식이다.
 다만, 값의 복사 비용과 결과 전달 한계 때문에,
 **필요에 따라 포인터를 통한 참조 전달(call by reference)**을 함께 설계하는 것이
 C 언어에서의 함수 설계의 핵심이다.

## 포인터를 통한 참조 호출

C 언어는 **엄격하게는 '값에 의한 호출(Call by Value)'만 지원**하지만,
 **포인터(pointer)**를 이용하면 **마치 참조에 의한 호출(Call by Reference)**처럼 사용할 수 있다.
 즉, 함수에 **변수의 주소를 전달**하고, 함수 내부에서 **그 주소를 통해 원본 데이터를 직접 수정**하는 방식이다.

### 🔧 기본 개념

```
void change(int *ptr) {
    *ptr = 100;
}
c코드 복사int main() {
    int a = 5;
    change(&a);
    printf("%d\n", a);  // 출력: 100
}
```

- `&a` → 변수 `a`의 주소를 전달
- `int *ptr` → `ptr`은 `a`를 가리킴
- `*ptr = 100;` → `a`의 실제 메모리 값이 변경됨

### 🧩 예제: swap 함수 (값 교환)

```
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}
```

```
int a = 3, b = 7;
swap(&a, &b);
printf("a=%d, b=%d\n", a, b);  // 출력: a=7, b=3
```

📌 `&a`, `&b`는 `a`와 `b`의 주소 → `*x`, `*y`는 실질적으로 `a`, `b`를 직접 수정

### 🧠 왜 사용하는가?

| 목적                   | 설명                                                       |
| ---------------------- | ---------------------------------------------------------- |
| 원본 데이터 직접 수정  | 외부 변수의 값을 함수 안에서 변경해야 할 경우              |
| 다중 값 반환           | 함수가 하나 이상의 출력을 제공해야 할 때 (e.g. 몫, 나머지) |
| 큰 자료 구조 효율 전달 | 구조체/배열 등 복사 비용이 클 경우 주소만 전달             |

### 🧪 예제: 다중 값 반환 (몫과 나머지)

```
void divide(int a, int b, int *quotient, int *remainder) {
    *quotient = a / b;
    *remainder = a % b;
}
```

```
int q, r;
divide(10, 3, &q, &r);
printf("몫 = %d, 나머지 = %d\n", q, r);  // 출력: 몫 = 3, 나머지 = 1
```

### ✅ 요약 비교

| 항목              | 값에 의한 호출 (기본) | 포인터를 통한 참조 호출        |
| ----------------- | --------------------- | ------------------------------ |
| 전달 대상         | 값 자체               | 변수의 메모리 주소             |
| 함수 내 변경 효과 | 원본에 영향 없음      | 원본 데이터 직접 변경 가능     |
| 사용 방법         | 일반 변수 전달        | `&변수` 전달, `*포인터`로 접근 |
| 출력 개수 제한    | 반환값 1개만 가능     | 여러 값을 포인터로 반환 가능   |

### ⚠️ 주의 사항

- **포인터 초기화 없이 접근하면 세그멘테이션 오류 발생**
   항상 `&변수` 형식으로 올바른 주소를 전달해야 함

- 실수로 잘못된 주소를 전달하면 **프로그램이 충돌하거나 예측 불가능한 결과**를 유발함

- `const` 포인터를 통해 **읽기 전용 참조 전달**도 가능함

  ```
  void print(const int *x);  // x를 변경하지 않겠다는 의도 표현
  ```

🧠 C 언어는 `call by reference`를 직접 지원하지 않지만,
 **포인터를 통해 완벽하게 시뮬레이션 가능**하며,
 이는 **C의 유연성과 저수준 제어 능력**을 잘 보여주는 특성이다.

포인터를 이용한 참조 호출은 반드시 **메모리 주소와 참조, 역참조에 대한 정확한 이해**를 전제로 하며,
 함수 간 데이터 흐름을 보다 정교하게 설계할 수 있는 **고급 기법**으로 자리잡는다.

# 3.3 재귀 함수의 정의와 동작

**재귀 함수(recursive function)**란, **자기 자신을 직접 또는 간접적으로 호출하는 함수**를 말한다.
 이 방식은 **큰 문제를 작은 문제로 나누어 해결**하는 데 적합하며, 수학적 귀납법과 유사한 원리로 작동한다.

### 🔧 기본 구조

```
반환형 함수이름(매개변수) {
    if (종료 조건)
        return 값;
    else
        return 함수이름(작은 문제);  // 자기 자신을 호출
}
```

📌 핵심 구성 요소:

1. **기저 조건(base case)**: 재귀를 멈출 조건
2. **재귀 호출(recursive call)**: 자기 자신을 호출하는 부분

### 🧪 예제: 팩토리얼 함수

```
int factorial(int n) {
    if (n == 0)            // 기저 조건
        return 1;
    else
        return n * factorial(n - 1);  // 재귀 호출
}
```

```
int main() {
    printf("%d\n", factorial(5));  // 출력: 120
    return 0;
}
```

실행 순서:

```
factorial(5)
= 5 * factorial(4)
= 5 * 4 * factorial(3)
= 5 * 4 * 3 * factorial(2)
= 5 * 4 * 3 * 2 * factorial(1)
= 5 * 4 * 3 * 2 * 1 * factorial(0)
= 5 * 4 * 3 * 2 * 1 * 1
= 120
```

### 🔄 동작 원리 (스택 기반 실행)

C에서 재귀 함수는 내부적으로 **함수 호출 스택(call stack)**을 이용하여 구현된다:

- 매 재귀 호출 시 **함수 프레임**이 스택에 쌓임
- 기저 조건에 도달하면 반환값을 **스택을 따라 역순으로 계산**
- **모든 재귀 호출이 종료되면 최종 결과가 도출**

### 📌 예제: 피보나치 수열 (재귀형)

```
int fib(int n) {
    if (n <= 1)
        return n;
    return fib(n - 1) + fib(n - 2);
}
```

→ 호출 트리 구조:

```
fib(4)
= fib(3) + fib(2)
= fib(2)+fib(1) + fib(1)+fib(0)
```

❗ 비효율적 (중복 호출 발생) → **메모이제이션 또는 반복 구현 추천**

### ✅ 재귀 vs 반복

| 항목        | 재귀 함수                           | 반복문(`for`, `while`)    |
| ----------- | ----------------------------------- | ------------------------- |
| 제어 구조   | 자기 자신 호출                      | 루프 구조 사용            |
| 종료 조건   | 기저 조건 필요                      | 조건식 명시               |
| 메모리 사용 | 함수 호출 스택 사용                 | 일정한 메모리 사용        |
| 가독성      | 수학적 표현 간결함 (예: 트리, 분할) | 성능과 제어 흐름이 명확함 |
| 속도/성능   | 느릴 수 있음 (함수 호출 비용)       | 일반적으로 더 빠름        |

### ⚠️ 주의 사항

- 재귀 함수는 반드시 **기저 조건을 명확히 지정**해야 한다
   → 기저 조건이 없으면 **무한 재귀 → 스택 오버플로우(segmentation fault)** 발생

```
int foo(int n) {
    return foo(n - 1);  // ❌ 종료 조건 없음 → 무한 재귀
}
```

- **재귀 깊이가 너무 깊으면** 스택 메모리 초과로 프로그램 비정상 종료

### 🧠 결론

재귀는 **복잡한 구조를 간단하게 표현**하는 강력한 도구다.
 특히 트리 탐색, 백트래킹, 분할 정복(Divide & Conquer) 알고리즘에서 유용하다.
 하지만 사용 시 **기저 조건 명시**, **재귀 깊이 제한 인식**, **필요시 반복문으로 대체 고려** 등의
 **실용적이고 방어적인 프로그래밍 전략**이 요구된다.

# 3.4 저장 클래스

## auto

`auto`는 C 언어에서 **자동 저장 클래스(auto storage class)**를 지정하기 위한 키워드다.
 하지만 현실적으로는 **사라진 키워드**에 가깝고, 대부분의 경우 **명시하지 않아도 자동으로 적용**된다.
 즉, C 언어에서 **지역 변수는 기본적으로 `auto` 저장 클래스**를 가지며,
 따로 `auto`를 붙이지 않아도 전혀 문제가 없다.

### 🔧 기본 문법

```
auto int x = 10;  // 실제로는 그냥 int x = 10; 과 동일
```

- 변수 `x`는 **자동 저장(auto storage)** → **스택(stack)** 영역에 저장
- 함수가 호출될 때 생성되고, **함수가 종료되면 자동으로 소멸됨**

### 🧪 실제 예시

```
void example() {
    auto int a = 5;  // auto는 생략 가능 (기본값임)
    int b = 10;      // 동일한 의미
    printf("%d %d\n", a, b);
}
```

📌 위 코드에서 `auto`는 **아무런 효과 없이 의미상 중복**

### 🧠 저장 클래스(storage class)란?

C 언어 변수는 저장 방식과 생명 주기에 따라 4가지 저장 클래스로 구분된다:

| 키워드     | 저장 위치   | 생존 기간     | 링크             |
| ---------- | ----------- | ------------- | ---------------- |
| `auto`     | 스택        | 블록 실행 중  | 없음 (지역 변수) |
| `register` | 레지스터    | 블록 실행 중  | 없음             |
| `static`   | 데이터 영역 | 프로그램 전체 | 내부 링크 가능   |
| `extern`   | 데이터 영역 | 프로그램 전체 | 외부 파일 링크   |

### 📌 C에서 `auto`의 의미

| 특성             | 설명                                     |
| ---------------- | ---------------------------------------- |
| 기본 저장 클래스 | 지역 변수는 기본적으로 `auto`로 지정됨   |
| 생략 가능 여부   | 항상 생략 가능 (대부분 생략함)           |
| 활용도           | **현대 C 코드에서 사실상 사용하지 않음** |

### ❗ 혼동 주의: C++의 `auto`

C++에서는 `auto`가 **완전히 다른 의미**로 사용된다:

```
auto x = 42;     // C++에서: x의 타입을 int로 자동 추론
```

📌 C에서는 **이런 자동 타입 추론 기능 없음**
 → C의 `auto`는 단지 “자동 저장 클래스”로서의 **역사적인 키워드**일 뿐

### ✅ 요약

| 항목      | C에서 `auto`의 의미                |
| --------- | ---------------------------------- |
| 정의      | 지역 변수의 기본 저장 클래스       |
| 저장 위치 | 스택(Stack)                        |
| 생존 범위 | 함수 블록 실행 중                  |
| 필요 여부 | ❌ 생략 가능 (명시하지 않아도 auto) |
| 혼동 주의 | C++의 `auto`는 타입 추론 키워드임  |

🧠 `auto`는 현대 C 프로그래밍에서 **명시적으로 사용할 필요가 거의 없는, 사실상 유물화된 키워드**다.
 지역 변수는 암묵적으로 `auto`이므로, **명시하지 않는 것이 일반적이며, 오히려 명시하면 불필요하게 구식처럼 보일 수 있다.**
 단지 C 언어의 저장 클래스 체계를 이해할 때 **이론적으로 알고 있으면 좋은 수준**이다.

## register

`register`는 C 언어의 저장 클래스 키워드 중 하나로, **변수를 CPU의 레지스터에 저장하도록 힌트를 주는 키워드**다.
 이 키워드를 사용하면 변수 접근 속도가 빨라질 수 있다는 기대를 담고 있으며,
 특히 **자주 사용되는 변수(루프 인덱스 등)**에 적합하다고 여겨진다.

하지만 현실적으로는 현대 컴파일러가 **최적의 변수 할당을 자동으로 수행**하기 때문에,
 `register` 키워드는 **대부분의 경우 무시되며 의미 없는 힌트**에 가까운 존재가 되었다.

### 🔧 기본 문법

```
register int counter = 0;
```

- 변수 `counter`는 **레지스터에 저장될 것을 요청**
- 단, 요청일 뿐이고, **실제로 할당 여부는 컴파일러가 판단**

### 🧪 예제: 루프 변수에 사용

```
void sum_array(int arr[], int size) {
    register int i;
    int sum = 0;
    for (i = 0; i < size; i++) {
        sum += arr[i];
    }
    printf("합계: %d\n", sum);
}
```

📌 `i`는 루프마다 참조되므로 **레지스터에 저장하면 이론적으로 더 빠를 수 있음**
 → 하지만 현대 컴파일러는 `-O2`, `-O3` 최적화 옵션으로 자동으로 그렇게 처리함

### ❗ 제한 사항

| 제한 사항             | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| 주소 연산자 사용 금지 | `register` 변수에는 `&` 연산자 사용 불가 (`&i` → 컴파일 오류) |
| 배열 선언 불가        | `register int arr[10];` 같은 선언은 허용되지 않음            |
| 포인터 사용도 제한적  | 주소 참조 자체가 불가능하므로 포인터 연산에 적합하지 않음    |

#### 예:

```
register int x = 10;
int *ptr = &x;  // ❌ 오류: 레지스터 변수의 주소는 얻을 수 없음
```

### 🧠 실제 의미와 현대적 관점

- 과거에는 성능 향상을 위해 수동으로 `register`를 지정했지만
- **현대 컴파일러는 레지스터 할당을 훨씬 정교하게 자동 최적화**하므로
- **`register` 키워드는 대부분 무시되며, 특별한 의미를 가지지 않음**

GCC, Clang 등 대부분의 컴파일러는 다음과 같이 동작:

- `register`를 무시하거나 경고를 출력함
- 최적화 옵션이 더 우선적으로 레지스터 배치 결정

### ✅ 요약

| 항목             | 설명                                                     |
| ---------------- | -------------------------------------------------------- |
| 목적             | 변수를 CPU 레지스터에 저장하도록 요청                    |
| 효과             | 현대 시스템에서는 대부분 **무시됨**                      |
| 주소 연산자 사용 | ❌ 금지 (`&` 연산자 불가)                                 |
| 선언 가능 위치   | 함수 내부에서만 사용 가능 (전역 변수에 사용 불가)        |
| 현대적 대안      | 컴파일러 최적화 옵션 (`-O2`, `-O3`) 또는 프로파일링 분석 |

🧠 `register`는 C의 역사적 유산이지만,
 현대에서는 **실제로 성능 향상 효과가 거의 없으며**,
 **컴파일러에게 맡기는 것이 더 효율적**이다.
 따라서 `register`는 **이론적으로 이해만 하고, 실전에서는 사용을 지양**하는 것이 현대 C 프로그래밍의 일반적 관행이다.

## static

`static`은 C 언어에서 가장 강력하고 유용한 저장 클래스 키워드 중 하나로,
 **변수 또는 함수의 생존 기간(lifetime)과 접근 범위(scope)를 제어**한다.
 사용 위치에 따라 **완전히 다른 의미와 동작**을 하며, 프로그램의 **캡슐화, 성능, 안정성**에 큰 영향을 미친다.

### 🧩 1. 함수 내부에서의 `static` 변수 → **정적 지역 변수**

```
void counter() {
    static int count = 0;
    count++;
    printf("count = %d\n", count);
}
```

📌 **특징:**

- 함수 안에서 선언되어도 **한 번만 초기화되고, 이후에도 값 유지**
- **지역 변수처럼 블록 내부에서만 접근 가능**
- 하지만 **생존 기간은 프로그램 전체 동안** (전역 변수처럼 지속됨)
- 즉, **"지역 변수 + 전역 생존 기간"의 특수한 형태**

#### 사용 예:

- 함수 호출 횟수 기록
- 연속된 고유 번호 생성기
- 이터레이터 상태 기억 등

### 🧩 2. 함수 외부에서의 `static` 변수 → **정적 전역 변수 (내부 연결)**

```
static int config_value = 42;
```

📌 **특징:**

- 외부 파일에서는 **접근할 수 없음** (링크되지 않음)
- **파일 내부에서만 사용 가능한 전역 변수**
- 변수 이름이 **다른 파일과 충돌하지 않도록 보호**

#### 사용 예:

- 모듈 내부 전용 상태 변수
- 라이브러리 내부 캐시, 버퍼 등 숨기고 싶은 전역 정보

### 🧩 3. 함수 앞의 `static` → **정적 함수 (internal linkage)**

```
static void helper_function() {
    // 외부에서 이 함수에 접근할 수 없음
}
```

📌 **특징:**

- 이 함수는 **선언된 파일 안에서만 호출 가능**
- 외부에서 `extern`으로 접근 불가
- **모듈 간 캡슐화** 구현에 필수

### 🔁 정리: `static` 사용 위치별 의미

| 사용 위치      | 의미                       | 접근 범위   | 생존 기간     |
| -------------- | -------------------------- | ----------- | ------------- |
| 함수 내부 변수 | 정적 지역 변수             | 해당 블록만 | 프로그램 전체 |
| 함수 외부 변수 | 정적 전역 변수 (링크 제한) | 파일 내부   | 프로그램 전체 |
| 함수 선언 앞   | 정적 함수 (링크 제한)      | 파일 내부   | 프로그램 전체 |

### 🔬 예제: `static` 지역 변수 vs 일반 변수 비교

```
void test_static() {
    static int a = 0;
    int b = 0;

    a++;
    b++;
    printf("a=%d, b=%d\n", a, b);
}
```

호출 결과:

```
a=1, b=1  
a=2, b=1  
a=3, b=1
```

📌 `a`는 호출 사이에도 값이 유지되고, `b`는 매번 새로 생성됨

### ⚠️ 주의 사항

- `static` 변수는 메모리상 **데이터 영역**(전역 변수와 동일) 사용
- **스레드 안전성 문제**가 있을 수 있음 → 멀티스레드 환경에서는 `static` 사용 주의
- 초기화는 **최대 한 번만 수행**되며, 이후에는 생략됨

### ✅ 요약

| 용도           | 설명                                            |
| -------------- | ----------------------------------------------- |
| 정적 지역 변수 | 함수 안에서 선언되지만 값이 유지됨              |
| 정적 전역 변수 | 외부 파일에 노출되지 않는 전역 변수             |
| 정적 함수      | 다른 소스 파일에서 호출 불가능한 내부 전용 함수 |
| 생존 기간      | 항상 프로그램 종료 시점까지 유지됨              |
| 저장 위치      | 데이터 영역 (전역 변수와 동일)                  |

🧠 `static`은 단순한 "정적"이라는 의미를 넘어,
 **캡슐화, 상태 기억, 인터페이스 분리, 모듈화 구조**를 설계하는 핵심 키워드다.
 **사용 위치와 목적에 따라 정확하게 활용**하면,
 코드의 **안정성, 유지보수성, 성능**을 모두 향상시킬 수 있는 고급 도구다.

## extern

`extern`은 C 언어에서 **전역 변수 또는 함수가 다른 파일에 정의되어 있음을 선언**할 때 사용하는 키워드다.
 즉, **외부에 정의된 식별자(변수나 함수)를 현재 파일에서 참조 가능하도록 알려주는 역할**을 한다.

`extern`은 **링커 단계에서 외부 심볼을 연결(link)**하기 위한 **인터페이스 선언용**으로 매우 중요하며,
 **다중 파일 프로그램 또는 라이브러리 구성 시 핵심적인 도구**다.

### 🔧 기본 문법

```
extern 자료형 변수이름;
extern 반환형 함수이름(매개변수목록);
```

- 정의는 다른 소스 파일(.c)에 존재
- 현재 파일에서는 **선언만** 하며, **메모리 할당은 하지 않음**

### 🧩 예제: 전역 변수 공유

#### `a.c`

```
int global_count = 100;  // 정의 (Definition)
```

#### `b.c`

```
#include <stdio.h>

extern int global_count;  // 선언 (Declaration)

void print_count() {
    printf("count = %d\n", global_count);
}
```

- `b.c`에서 `extern`으로 선언만 해놓고,
- `global_count`의 실제 메모리는 `a.c`에서 정의된 것을 참조함

📌 이처럼 `extern`은 **다른 파일에서 정의된 전역 변수나 함수**를 사용할 수 있게 해준다

### 🧩 예제: 함수 외부 선언

#### `utils.c`

```
void greet() {
    printf("Hello!\n");
}
```

#### `main.c`

```
extern void greet();  // 함수 선언

int main() {
    greet();  // utils.c에 있는 함수 호출
    return 0;
}
```

📌 `extern` 함수 선언은 보통 **헤더 파일(.h)에 넣고 include**하는 것이 일반적이다.

### 🔁 변수 선언과 정의 차이

| 구분          | 코드 예시       | 메모리 할당 | 중복 선언 가능 | 링크 대상 |
| ------------- | --------------- | ----------- | -------------- | --------- |
| 정의          | `int x = 10;`   | ✅ 있음      | ❌ 안 됨        | O         |
| 선언 (extern) | `extern int x;` | ❌ 없음      | ✅ 가능         | O         |

### ⚠️ 주의 사항

- `extern`은 **선언만 하고 정의하지 않으면 링커 오류 발생**

  ```
  extern int value;  // 선언만 하고
  // 정의가 없으면 → undefined reference 에러
  ```

- 같은 파일 안에서는 `extern`보다는 일반 선언을 권장

- `static`과는 **정반대 개념**: `static`은 파일 내부 제한, `extern`은 외부 접근 허용

### ✅ 요약

| 항목             | 설명                                                 |
| ---------------- | ---------------------------------------------------- |
| 키워드           | `extern`                                             |
| 주요 목적        | 외부 변수/함수를 현재 파일에서 사용할 수 있도록 선언 |
| 메모리 할당 여부 | ❌ (정의는 다른 파일에 있음)                          |
| 적용 대상        | 전역 변수, 전역 함수                                 |
| 사용 위치        | 선언 위치 (보통 헤더 파일)                           |
| 링커 연결        | ✅ (링크 단계에서 외부 심볼 해결)                     |

🧠 `extern`은 C의 **모듈화된 구조와 다중 파일 프로그램의 연결을 가능하게 하는 필수 키워드**다.
 이 개념을 바르게 이해하고 활용할 수 있어야
 **코드 분리, 전역 공유 변수, 공통 인터페이스 설계, 라이브러리 사용** 등 고급 C 프로그래밍이 가능하다.