# 4. 배열과 문자열

# 4.1 배열

## 1차원 배열

C 언어에서 **1차원 배열**은 **동일한 자료형의 값들을 연속된 메모리 공간에 저장**하는 자료구조다.
 배열은 **하나의 이름으로 여러 개의 데이터를 관리**할 수 있으며,
 인덱스를 이용해 개별 요소에 접근할 수 있다.

### 🔧 배열 선언

```
자료형 배열이름[크기];
```

- `자료형`: 배열에 저장할 데이터의 타입 (`int`, `float`, `char` 등)
- `배열이름`: 배열의 식별자
- `크기`: 배열의 요소 수 (정수 상수 또는 상수 표현식)

#### 예시:

```
int numbers[5];       // 정수 5개 저장
float scores[10];     // 실수 10개 저장
char name[20];        // 문자 20개 저장 (문자열 용도)
```

### 🧩 초기화 방법

```
int a[5] = {1, 2, 3, 4, 5};
int b[5] = {10, 20};        // 나머지 요소는 0으로 자동 초기화
int c[] = {7, 8, 9};        // 크기를 생략하면 초기화 값의 수로 결정
```

### 🔁 배열 요소 접근

배열의 각 요소는 **인덱스(index)**를 사용하여 접근하며,
 **인덱스는 0부터 시작**한다.

```
a[0] = 10;            // 첫 번째 요소에 10 저장
printf("%d\n", a[2]); // 세 번째 요소 출력
```

### 🧪 예제: 배열에 값 저장 및 출력

```
#include <stdio.h>

int main() {
    int arr[5];
    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;
    }

    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }

    return 0;
}
```

📌 출력:

```
arr[0] = 0  
arr[1] = 2  
arr[2] = 4  
arr[3] = 6  
arr[4] = 8
```

### 🧠 메모리 구조

```
int a[3] = {10, 20, 30};
```

- 메모리에는 **연속된 공간에 값이 저장됨**:

```
주소    값
a[0] → 10  
a[1] → 20  
a[2] → 30
```

- 배열 이름 `a`는 **배열의 시작 주소(포인터)**로 해석됨
   `a == &a[0]`는 항상 참

### 🔍 배열과 포인터의 관계

```
int a[3] = {1, 2, 3};
printf("%d\n", *(a + 1));   // 2 출력
```

- `a[i]`는 사실상 `*(a + i)`와 같음
- 배열은 포인터처럼 작동하지만, **배열 이름 자체는 상수 포인터**

### ⚠️ 주의 사항

- C에서는 **배열의 크기를 자동으로 체크하지 않음** → 경계 초과 주의

  ```
  int a[3];
  a[3] = 100;   // ❌ 정의되지 않은 동작 (out of bounds)
  ```

- 배열을 함수 인자로 전달하면, **배열 전체가 복사되지 않고 포인터만 전달됨**

  ```
  void print(int arr[], int size);  // 실제로는 int* arr 와 동일
  ```

### ✅ 요약

| 항목              | 설명                                        |
| ----------------- | ------------------------------------------- |
| 선언              | `자료형 배열이름[크기]`                     |
| 인덱스 시작       | 항상 0부터 시작                             |
| 초기화            | `{}` 사용, 생략된 요소는 0으로 채워짐       |
| 접근 방법         | `배열이름[인덱스]`, 또는 `*(배열 + 인덱스)` |
| 메모리 배치       | **연속적**, 스택 또는 전역/정적 영역 사용   |
| 함수 전달 시 의미 | 배열 이름은 포인터로 변환됨                 |

🧠 **1차원 배열은 C 프로그래밍에서 가장 기본적인 데이터 구조**이며,
 포인터와 결합하면 다양한 알고리즘의 기반이 된다.
 **배열 경계 확인, 초기화, 포인터 연산의 정확한 이해**가
 안정적이고 신뢰할 수 있는 C 코드 작성의 핵심이다.

## 2차원 이상 다차원 배열

C 언어에서 다차원 배열은 **배열 안에 또 다른 배열이 있는 구조**를 의미한다.
 일반적으로 가장 많이 사용되는 다차원 배열은 **2차원 배열(행과 열)**이며,
 3차원 이상도 선언은 가능하지만 **복잡성과 가독성 측면에서 주의가 필요**하다.

### 🔶 1. 2차원 배열 (Two-dimensional Array)

#### 📌 선언

```
자료형 배열이름[행][열];
```

#### 예시

```
int matrix[3][4];  // 3행 4열짜리 배열
```

- 메모리에는 총 `3 × 4 = 12`개의 `int` 저장 공간이 **연속적으로** 할당됨
- **row-major order**로 저장됨: 먼저 행이 고정되고 열이 이동

#### 🧪 초기화 예시

```
int a[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

또는:

```
int a[2][3] = {1, 2, 3, 4, 5, 6};  // 내부적으로 위와 동일
```

#### 🔁 접근

```
printf("%d\n", a[1][2]);  // 5 (2번째 행, 3번째 열)
```

#### 🔁 반복문 사용

```
for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 3; j++) {
        printf("a[%d][%d] = %d\n", i, j, a[i][j]);
    }
}
```

### 🔷 2. 3차원 배열 (Three-dimensional Array)

#### 📌 선언

```
자료형 배열이름[면][행][열];
```

#### 예시

```
int cube[2][3][4];  // 2개의 3×4 행렬 (총 24개 요소)
```

- 실제로는 **1차원 배열로 연속 저장**됨
- 접근: `cube[면][행][열]`

### 🧪 다차원 배열 예제

```
int tensor[2][2][2] = {
    {
        {1, 2},
        {3, 4}
    },
    {
        {5, 6},
        {7, 8}
    }
};

printf("%d\n", tensor[1][0][1]);  // 6
```

### 📌 함수에 전달하기

함수에 다차원 배열을 전달할 때는 **모든 차원 중 첫 차원을 제외한 나머지 차원의 크기를 반드시 명시해야 함**

```
void print_matrix(int m[][3], int rows);  // 열의 크기 3은 명시 필요
```

혹은:

```
void print_matrix(int (*m)[3], int rows);
```

> ❗ `void print_matrix(int m[][], int rows);` ← 컴파일 오류

### ⚠️ 주의사항

- 다차원 배열은 **복잡도 급증** → 가능한 경우 구조체, 포인터 배열, 동적 할당 사용 고려
- 함수 전달 시 **크기 생략 불가**, 동적 배열과 포인터 구분 명확히 해야 함
- **C99 이후** 가변 길이 배열(VLA: Variable Length Array) 지원 → 일부 제한적 환경에서 사용 가능

### ✅ 요약

| 차원      | 선언 예시              | 특징                                     |
| --------- | ---------------------- | ---------------------------------------- |
| 1차원     | `int a[10];`           | 선형 데이터, 배열 이름은 포인터처럼 동작 |
| 2차원     | `int b[3][4];`         | 행렬 구조, 행은 바깥 루프에서 사용       |
| 3차원     | `int c[2][3][4];`      | 큐브 또는 텐서 형태, 복잡도 증가         |
| 함수 전달 | `void f(int a[][열]);` | 열 크기 이상은 반드시 명시해야 함        |

🧠 **다차원 배열은 수학적 데이터 처리, 이미지 처리, 테이블 구성** 등에서 강력한 도구다.
 하지만 메모리 구조와 접근 패턴을 이해하지 못한 채 사용하면 **오류 발생과 성능 저하**의 원인이 되므로,
 **행 우선 저장 방식(row-major)**, **배열 크기 명시**, **반복문 인덱싱** 등의 기본 원리를 정확히 이해해야 한다.

## 배열 초기화 및 접근 방식

C 언어에서 배열은 **연속된 메모리 공간에 동일한 자료형의 데이터들을 저장**하는 자료구조다.
 배열의 초기화와 접근은 C 프로그래밍의 기초이자, **메모리 모델, 포인터 연산, 반복문 구조**의 핵심 개념과 깊이 연관된다.

### 🔶 배열 초기화 (Initialization)

#### ✅ 1차원 배열 초기화

```
int a[5] = {1, 2, 3, 4, 5};        // 완전 초기화
int b[5] = {10, 20};               // 나머지 요소는 0으로 초기화됨
int c[]  = {7, 8, 9};              // 크기 생략 가능 → 자동 크기 결정
```

| 선언                  | 설명                               |
| --------------------- | ---------------------------------- |
| `int a[3] = {1,2,3};` | 명시적으로 모두 초기화             |
| `int a[5] = {1};`     | 나머지는 0으로 자동 초기화         |
| `int a[] = {4,5};`    | 크기 생략 가능 (컴파일러가 결정함) |

#### ✅ 2차원 배열 초기화

```
int mat[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

또는:

```
int mat[2][3] = {1, 2, 3, 4, 5, 6};  // 행렬처럼 자동 채워짐 (row-major)
```

> ⚠️ 모든 차원을 생략하는 것은 불가능

```
int arr[][] = {{1,2},{3,4}};  // ❌ 컴파일 오류  
```

#### ✅ 고급: 초기값 생략과 `memset` 활용

```
int a[100] = {0};       // 첫 요소 0 → 나머지 모두 0으로 초기화
#include <string.h>
memset(a, 0, sizeof(a)); // 전 요소 0으로 초기화 (바이트 단위)
```

> ⚠️ `memset`은 **int 배열, float 배열에 안전하나**, 구조체나 포인터 배열에는 주의 요망

### 🔷 배열 접근 방식

#### ✅ 기본 인덱스 접근

```
int a[5] = {10, 20, 30, 40, 50};

printf("%d\n", a[2]);  // 30
a[3] = 100;            // 4번째 요소 값 수정
```

- 인덱스는 **0부터 시작**
- `a[0]` → 첫 번째 요소
- `a[n]`은 `(배열 시작 주소 + n × 자료형 크기)` 위치

#### ✅ 반복문을 활용한 접근

```
for (int i = 0; i < 5; i++) {
    printf("a[%d] = %d\n", i, a[i]);
}
```

#### ✅ 포인터로 접근 (배열 = 포인터)

```
int *p = a;
printf("%d\n", *(p + 2));   // a[2]
```

배열 `a[i]`는 `*(a + i)`와 동일
 이 구조는 포인터 연산과 배열 순회 알고리즘의 핵심

#### ✅ 다차원 배열 접근

```
int m[2][3] = {{1,2,3}, {4,5,6}};
printf("%d\n", m[1][2]);  // 6
```

📌 C는 다차원 배열을 **row-major order**로 저장:

```
m[0][0], m[0][1], m[0][2], m[1][0], m[1][1], m[1][2]
```

### ⚠️ 주의 사항

- 배열은 선언 시 크기를 반드시 정수 상수로 명시해야 함 (C99 이후 VLA 허용)

- **경계 초과(out-of-bounds)** 접근은 정의되지 않은 동작(UB)을 초래

  ```
  int a[5];
  a[5] = 100;  // ❌ 위험한 접근 (인덱스 0~4까지가 유효)
  ```

- 함수에 배열을 인자로 전달할 경우, **배열은 포인터로 decay**됨

  ```
  void f(int arr[]);   // == void f(int *arr);
  ```

### ✅ 요약

| 개념             | 설명                                                    |
| ---------------- | ------------------------------------------------------- |
| 배열 선언        | `자료형 배열명[크기];`                                  |
| 배열 초기화      | `{값1, 값2, ...}` 또는 `memset()` 사용 가능             |
| 인덱스 접근      | `a[i]` 또는 `*(a + i)` 형태                             |
| 포인터와 관계    | 배열 이름은 시작 주소이며, 포인터처럼 작동함            |
| 다차원 접근 방식 | `a[i][j]` → row-major order                             |
| 경계 체크        | **사용자가 직접 주의해야 함 (C는 자동 경계 검사 없음)** |

🧠 배열 초기화와 접근 방식은 단순한 문법 이상으로,
 **메모리 구조, 포인터 연산, 함수 인자 전달 방식**과도 밀접하게 연결된다.
 특히 시스템 프로그래밍, 알고리즘 구현, 하드웨어 버퍼 제어 등에서
 **배열의 정확한 인덱싱과 안전한 초기화**는 성능과 안정성의 핵심이다.

## 배열의 메모리 구조

C 언어에서 배열은 **연속된 메모리 블록에 동일한 자료형의 데이터를 저장**하는 구조다.
 이 연속성은 배열을 고속으로 순회하거나, 포인터 연산으로 요소를 접근하는 데 중요한 기반이 된다.
 배열의 메모리 구조를 이해하면 **포인터, 주소 계산, 성능 최적화**까지 자연스럽게 연결된다.

### 🔹 1차원 배열의 메모리 구조

```
int a[4] = {10, 20, 30, 40};
```

이 배열은 메모리에서 다음과 같이 배치된다 (가정: `int` = 4바이트):

| 인덱스 | 주소 (예시) | 값   |
| ------ | ----------- | ---- |
| a[0]   | `0x1000`    | 10   |
| a[1]   | `0x1004`    | 20   |
| a[2]   | `0x1008`    | 30   |
| a[3]   | `0x100C`    | 40   |

- **배열의 이름 `a`는 `a[0]`의 주소**와 같다
   즉, `a == &a[0]` → 항상 참
- `a[i]`는 `*(a + i)`와 동일하게 동작 (포인터 연산)

### 🔸 포인터 연산과 관계

```
printf("%d\n", *(a + 2));     // 30
```

- 포인터 연산은 자료형 크기만큼 이동함 → `a + 2`는 `a[2]` 위치의 주소

### 🔹 2차원 배열의 메모리 구조 (row-major)

```
int mat[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

📌 C 언어는 **row-major order**를 사용 → 행 우선 저장

| 인덱스    | 값   | 주소 (예시) |
| --------- | ---- | ----------- |
| mat[0][0] | 1    | `0x2000`    |
| mat[0][1] | 2    | `0x2004`    |
| mat[0][2] | 3    | `0x2008`    |
| mat[1][0] | 4    | `0x200C`    |
| mat[1][1] | 5    | `0x2010`    |
| mat[1][2] | 6    | `0x2014`    |

- 내부적으로는 `int mat[2][3]` → `int[6]`처럼 메모리에 연속 저장됨
- `mat[i][j]`는 실제 주소 계산식으로 표현 가능:

```
*( *(mat + i) + j )     // 또는
*(&mat[0][0] + i * 3 + j)
```

### 🔷 배열과 포인터의 차이점

| 표현식   | 의미                                          |
| -------- | --------------------------------------------- |
| `a`      | 배열의 시작 주소 (`&a[0]`)                    |
| `a[i]`   | `*(a + i)`                                    |
| `&a[i]`  | `a + i`                                       |
| `*a`     | `a[0]` (1차원 배열에서만 해당)                |
| `mat[i]` | `int*` 타입, `mat[i][j] == *(*(mat + i) + j)` |

📌 **배열은 포인터처럼 행동하지만, 배열 이름은 상수 포인터이며 재할당 불가**

### 🔸 배열 크기 계산

```
int a[5];
sizeof(a);           // 20 (int가 4바이트일 경우)
sizeof(a[0]);        // 4
sizeof(a) / sizeof(a[0]);  // 5 (요소 개수)
```

### 🧠 메모리 정렬과 패딩

- 배열 요소는 항상 **자료형 크기만큼 정렬**됨
- 구조체 내부의 배열은 **패딩(byte alignment)**이 삽입될 수 있음

### ✅ 요약

| 개념             | 설명                                                   |
| ---------------- | ------------------------------------------------------ |
| 연속 메모리 구조 | 배열은 인접한 주소에 데이터 저장 (row-major)           |
| 이름과 주소      | 배열 이름은 시작 주소를 의미 (`a == &a[0]`)            |
| 주소 연산        | `a[i] == *(a + i)`, `&a[i] == a + i`                   |
| 2차원 주소 계산  | `mat[i][j] == *(*(mat + i) + j)` 또는 오프셋 방식 사용 |
| 포인터와의 차이  | 배열은 상수 포인터처럼 동작하지만 수정은 불가          |

🧠 배열의 메모리 구조를 이해하는 것은
 **포인터 연산, 함수 전달, 버퍼 관리, 최적화**의 기초가 된다.
 특히 **다차원 배열의 주소 계산과 접근 방식**은 고급 C 프로그래밍과
 **시스템 수준 설계, 디바이스 제어, 데이터 처리** 등에서 매우 중요한 기초 개념이다.

# 4.2 문자열

## 문자열 상수와 배열의 차이

C 언어에서 문자열을 다룰 때 자주 사용되는 두 가지 방식은:

1. **문자열 상수(string literal)** – `char *str = "hello";`
2. **문자 배열(character array)** – `char str[] = "hello";`

이 둘은 표면적으로 비슷해 보이지만, **메모리 배치, 수정 가능성, 생명 주기, 저장 위치** 등에서 중요한 차이를 가진다.

### 🔹 문자열 상수 (`char *p = "text";`)

```
char *p = "hello";
```

| 항목              | 설명                                                     |
| ----------------- | -------------------------------------------------------- |
| 메모리 위치       | **읽기 전용 메모리 영역** (보통 텍스트 세그먼트)         |
| 값 수정 가능 여부 | ❌ **수정 불가 (UB: undefined behavior)**                 |
| 문자열 복사 여부  | 문자열 리터럴이 **그대로 가리켜짐**                      |
| 포인터 의미       | `p`는 `"hello"`가 저장된 **상수 문자열의 주소**를 가리킴 |

📌 컴파일러는 `"hello"`를 읽기 전용 메모리에 저장하고, `p`는 그 주소를 가리킴
📌 `"hello"`는 `['h', 'e', 'l', 'l', 'o', '\0']`로 자동 null-terminated

#### ❗ 잘못된 사용 예 (UB)

```
char *p = "hello";
p[0] = 'H';  // ❌ 런타임 오류 또는 세그멘테이션 오류 발생 가능
```

### 🔸 문자 배열 (`char str[] = "text";`)

```
char str[] = "hello";
```

| 항목              | 설명                                   |
| ----------------- | -------------------------------------- |
| 메모리 위치       | **스택(stack)** 또는 **데이터 영역**   |
| 값 수정 가능 여부 | ✅ 수정 가능                            |
| 문자열 복사 여부  | `"hello"`가 **배열에 복사되어 저장됨** |
| 배열 의미         | `str`은 **배열 이름이자 시작 주소**    |

#### ✅ 안전한 사용 예

```
char str[] = "hello";
str[0] = 'H';  // 가능 → str은 읽기/쓰기 가능한 배열
printf("%s\n", str);  // Hello
```

### 🧪 비교 예제

```
char *p = "hello";      // 문자열 상수 (읽기 전용)
char a[] = "hello";     // 문자열 배열 (수정 가능)
```

| 요소      | `p`                     | `a`                            |
| --------- | ----------------------- | ------------------------------ |
| 타입      | `char *`                | `char[6]`                      |
| 저장 위치 | 읽기 전용 메모리 (text) | 스택 메모리 (또는 데이터 영역) |
| 수정 가능 | ❌ (UB)                  | ✅                              |
| 의미      | 주소를 가리키는 포인터  | 문자열 복사본을 포함하는 배열  |

### ✅ 요약 표

| 구분             | 문자열 상수 (`char *p = "abc";`) | 문자 배열 (`char a[] = "abc";`) |
| ---------------- | -------------------------------- | ------------------------------- |
| 저장 위치        | 읽기 전용 메모리 (.rodata)       | 스택 또는 데이터 영역           |
| 값 수정 가능성   | ❌ (수정 시 UB)                   | ✅ (자유롭게 수정 가능)          |
| 메모리 복사 여부 | 안 함 (포인터만 가짐)            | 문자열 전체 복사됨              |
| 길이             | `strlen(p)`                      | `sizeof(a)` → null 포함 길이    |
| 용도             | 상수 참조용, 안전한 출력         | 가변 문자열 저장 및 조작        |

### ⚠️ 실전 팁

- **수정 가능한 문자열**을 사용해야 한다면 → 반드시 `char 배열` 사용
- 라이브러리 함수 `strcpy`, `strcat` 등은 **쓰기 작업이 있으므로 문자열 상수에 사용하면 안 됨**
- C 표준에 따라 문자열 리터럴 수정은 **정의되지 않은 동작(undefined behavior)**이며,
   일부 시스템에서는 세그멘테이션 오류(segfault)가 발생한다

🧠 문자열 상수와 배열의 차이는 단순 문법 문제가 아니라,
 **메모리 구조, 접근 안전성, 런타임 안정성**과 직결되는 중요한 개념이다.
 실수로 문자열 상수를 수정하면 **예측 불가능한 버그와 보안 취약점**이 생길 수 있으므로,
 **읽기 전용 문자열은 포인터로, 수정이 필요한 문자열은 배열로**
 명확하게 의도를 구분해 사용하는 것이 모범적인 C 프로그래밍이다.

## 문자열 관련 표준 함수: strlen, strcpy, strcat, strcmp 등

C 언어는 문자열을 `char` 배열로 표현하며, 문자열 처리를 위한 다양한 표준 라이브러리 함수들을 `<string.h>`에 정의하고 있다.
 이 함수들은 **문자열의 길이 측정, 복사, 연결, 비교, 검색 등**을 수행하며,
 **널 종료 문자('\0')를 기준**으로 동작하는 점이 핵심이다.

### 🔹 주요 문자열 함수 요약

| 함수      | 설명                             | 헤더 파일    |
| --------- | -------------------------------- | ------------ |
| `strlen`  | 문자열의 길이를 반환 (`\0` 제외) | `<string.h>` |
| `strcpy`  | 문자열 복사                      | `<string.h>` |
| `strncpy` | 길이 제한 복사                   | `<string.h>` |
| `strcat`  | 문자열 이어붙이기                | `<string.h>` |
| `strncat` | 길이 제한 이어붙이기             | `<string.h>` |
| `strcmp`  | 문자열 비교                      | `<string.h>` |
| `strncmp` | 길이 제한 문자열 비교            | `<string.h>` |
| `strchr`  | 특정 문자 첫 위치 찾기           | `<string.h>` |
| `strstr`  | 특정 문자열의 위치 찾기          | `<string.h>` |

### 🔸 `strlen()` — 문자열 길이 계산

```
size_t strlen(const char *s);
```

- 문자열의 길이(문자 수)를 반환하되, **널 문자('\0')는 포함하지 않음**
- `size_t`는 `unsigned int` 계열

#### 예제:

```
char str[] = "hello";
printf("%zu\n", strlen(str));  // 출력: 5
```

📌 `strlen()`은 **널 문자를 만날 때까지 반복**하므로
 **널 종료되지 않은 배열에는 절대 사용 금지**

### 🔸 `strcpy()` — 문자열 복사

```
char *strcpy(char *dest, const char *src);
```

- `src`의 문자열을 `dest`에 복사 (널 문자 포함)
- `dest`는 `src`보다 충분히 커야 함

#### 예제:

```
char src[] = "world";
char dest[10];
strcpy(dest, src);
```

📌 버퍼 크기 체크 없이 복사하므로 **버퍼 오버플로우 위험 존재**

### 🔸 `strncpy()` — 문자열 길이 제한 복사

```
char *strncpy(char *dest, const char *src, size_t n);
```

- 최대 `n`개의 문자만 복사
- **널 문자를 포함하지 않을 수 있음** → 후처리 필요

#### 예제:

```
char src[] = "data";
char dest[10];
strncpy(dest, src, sizeof(dest));
dest[sizeof(dest)-1] = '\0';  // 직접 널 종료 보장 필요
```

### 🔸 `strcat()` — 문자열 이어붙이기

```
char *strcat(char *dest, const char *src);
```

- `dest` 끝에 `src` 문자열을 추가 (널 문자 포함)
- `dest`는 두 문자열을 모두 담을 수 있어야 함

#### 예제:

```
char a[20] = "Hello, ";
char b[] = "world!";
strcat(a, b);  // a = "Hello, world!"
```

### 🔸 `strncat()` — 길이 제한 이어붙이기

```
char *strncat(char *dest, const char *src, size_t n);
```

- `src`에서 최대 `n`개 문자만 `dest` 끝에 추가

#### 예제:

```
char dest[20] = "Num: ";
char num[] = "123456";
strncat(dest, num, 3);  // dest = "Num: 123"
```

### 🔸 `strcmp()` — 문자열 비교

```
int strcmp(const char *s1, const char *s2);
```

- 두 문자열을 **사전순으로 비교**
- 결과:
  - `0`: 문자열이 동일
  - `< 0`: s1 < s2
  - `> 0`: s1 > s2

#### 예제:

```
if (strcmp("abc", "abd") < 0)
    printf("abc precedes abd\n");
```

### 🔸 `strncmp()` — 길이 제한 문자열 비교

```
int strncmp(const char *s1, const char *s2, size_t n);
```

- 최대 `n`개의 문자만 비교

#### 예제:

```
strncmp("abcXYZ", "abcDEF", 3);  // 결과: 0 (앞 3글자 동일)
```

### 🔸 `strchr()` — 문자 위치 검색

```
char *strchr(const char *s, int c);
```

- 문자열 `s`에서 문자 `c`가 **처음 나오는 위치의 포인터** 반환
- 없으면 `NULL`

```
char *p = strchr("hello", 'l');  // p → "llo"
```

### 🔸 `strstr()` — 문자열 검색

```
char *strstr(const char *haystack, const char *needle);
```

- 문자열 `haystack`에서 `needle`이 **처음 등장하는 위치의 포인터** 반환

```
char *p = strstr("embedded system", "system");  // p → "system"
```

### ✅ 요약표

| 함수      | 기능                         | 주의 사항                        |
| --------- | ---------------------------- | -------------------------------- |
| `strlen`  | 길이 반환 (널 문자 제외)     | 문자열이 반드시 널 종료되어야 함 |
| `strcpy`  | 복사                         | 버퍼 크기 체크 필요 (위험함)     |
| `strncpy` | 길이 제한 복사               | 널 문자가 자동 보장되지 않음     |
| `strcat`  | 문자열 덧붙이기              | 대상 버퍼 크기 초과 주의         |
| `strcmp`  | 문자열 비교 (정렬/동일 판단) | 대소문자 구분                    |
| `strchr`  | 문자 검색                    | 포인터 반환                      |
| `strstr`  | 문자열 부분 검색             | 첫 등장 위치 반환                |

🧠 문자열 함수들은 모두 **널 문자 `\0`을 기준으로 동작**하며,
 **버퍼 오버플로우, 널 미포함, 포인터 반환 오류** 등이 발생하기 쉬운 위험 구간이다.
 따라서 사용 시 항상 **버퍼 크기 보장**, **복사 길이 명시**, **반환값 검사** 등의 방어적 코딩이 필수이다.
 📌 특히 실무에서는 `strncpy`, `strncat`, `snprintf` 등 **제한 기반 함수 사용을 우선**하는 것이 안전하다.

## 문자열 입력: gets, fgets

C 언어에서 문자열을 입력받는 대표적인 함수는 `gets()`와 `fgets()`이다.
 하지만 이 두 함수는 **보안성과 안정성 측면에서 큰 차이**를 가지며,
 특히 `gets()`는 **C11부터 완전히 제거된 위험한 함수**로 간주된다.

### 🔸 `gets()` — ❌ 사용 금지 (보안상 매우 위험)

```
char str[100];
gets(str);
```

| 항목           | 설명                                                        |
| -------------- | ----------------------------------------------------------- |
| 동작 방식      | 개행 전까지 모든 문자열을 입력 받아 `str`에 저장            |
| 널 문자        | 입력 끝에 자동으로 `\0` 추가                                |
| 버퍼 초과 위험 | ❗ 입력 길이를 제한하지 않음 → **버퍼 오버플로우 발생 가능** |
| 상태 반환      | 실패 시 `NULL` 반환                                         |
| C 표준 상태    | **C11 이후 완전히 제거됨**                                  |

#### 예제 (위험한 사용):

```
char name[10];
gets(name);   // 사용자 입력이 10자 넘으면 메모리 침범 발생!
```

#### 왜 위험한가?

- `gets()`는 입력 길이를 제어할 수 없고, **사용자 입력이 배열보다 길면 프로그램이 뚫린다.**
- 버퍼 오버플로우는 **악성 코드 실행, 시스템 장악**으로 이어질 수 있음

### 🔹 `fgets()` — ✅ 안전한 문자열 입력 함수

```
char *fgets(char *str, int n, FILE *stream);
```

| 항목           | 설명                                                        |
| -------------- | ----------------------------------------------------------- |
| 동작 방식      | `stream`으로부터 최대 `n-1`문자까지 읽고 마지막에 `\0` 추가 |
| 개행 문자 처리 | 개행 문자(`\n`)도 함께 저장됨 (제거하지 않음)               |
| 안전성         | ✅ 입력 길이를 제한하므로 버퍼 초과 없음                     |
| 반환값         | 성공 시 `str`, 실패 시 `NULL`                               |

#### 표준 입력 사용 예:

```
char line[100];
fgets(line, sizeof(line), stdin);
```

### 📌 `fgets()` 사용 후 개행 문자 제거 (권장 처리)

`fgets()`는 개행 문자를 포함하므로, 필요시 직접 제거해야 함:

```
line[strcspn(line, "\n")] = '\0';
```

또는 수동으로 처리:

```
size_t len = strlen(line);
if (len > 0 && line[len - 1] == '\n') {
    line[len - 1] = '\0';
}
```

### ✅ 요약 비교

| 항목           | `gets()`                          | `fgets()`                          |
| -------------- | --------------------------------- | ---------------------------------- |
| 표준 상태      | C11 이후 삭제됨 (위험)            | 안전하게 유지됨                    |
| 입력 제한      | ❌ 없음 → 위험                     | ✅ `n` 인수로 길이 제한 가능        |
| 개행 처리      | 자동 제거                         | **개행 포함됨** (필요시 수동 제거) |
| 사용 추천 여부 | ❌ 절대 사용 금지                  | ✅ 보안에 안전                      |
| 반환값         | 입력 성공 시 포인터, 실패 시 NULL | 동일                               |

### 🧠 실전 팁

- `gets()`는 절대 사용하지 말 것. 모든 보안 검사도구와 컴파일러가 경고 또는 에러를 발생시킴.
- `scanf("%s", str)`도 버퍼 길이 제한이 없으면 유사한 위험이 있으므로,
   항상 **길이 제한 또는 `fgets()` + `sscanf()` 조합 사용**을 추천.
- `fgets()` 사용 시 **개행 문자를 처리**해주지 않으면 문자열 비교 등에서 오류가 발생할 수 있음.

### 📌 요약:

 ✅ 문자열 입력에는 `fgets()`를 사용하되, **입력 길이 제한 + 개행 문자 제거**를 반드시 함께 처리하자.
 ❌ `gets()`는 **"C 언어 최악의 함수"**로 불릴 정도로 위험하므로 **절대 사용하지 말 것**.

## 문자열 출력: puts, printf

C 언어에서 문자열을 출력할 때 가장 자주 사용하는 함수는 `puts()`와 `printf()`이다.
 두 함수는 모두 **표준 출력(stdout)**을 사용하지만,
 **기능과 사용 목적, 개행 처리 방식, 성능**에서 차이가 있다.

### 🔹 `puts()` — 간단한 문자열 출력 + 자동 개행

```
int puts(const char *str);
```

- 문자열을 출력하고 **자동으로 개행 문자('\n')**를 덧붙인다.
- 출력 대상은 **표준 출력(stdout)**
- **형식 지정 불가** (단순 문자열만 출력)
- 성공 시 0 이상, 실패 시 EOF 반환

#### 예제:

```
puts("Hello, world!");
```

📌 출력 결과:

```
Hello, world!
```

(자동 개행 포함)

### 🔸 `printf()` — 형식 지정 출력 (문자열 포함)

```
int printf(const char *format, ...);
```

- **형식 지정자(format specifier)**를 사용하여 **문자열, 숫자, 문자 등 다양한 데이터 출력** 가능
- 개행 문자를 자동으로 추가하지 않음 → **필요시 직접 `\n` 포함**
- 성공 시 출력한 문자의 수, 실패 시 음수 반환

#### 예제:

```
printf("Hello, %s!\n", "world");
```

📌 출력 결과:

```
Hello, world!
```

### ✅ `puts()` vs `printf()` 비교

| 항목        | `puts()`                       | `printf()`                              |
| ----------- | ------------------------------ | --------------------------------------- |
| 출력 대상   | 문자열 하나                    | 문자열 포함 다양한 형식 출력 가능       |
| 개행 처리   | **자동 개행(`\n`) 추가됨**     | 개행 없음 → 수동으로 `\n` 입력 필요     |
| 형식 지정   | ❌ 불가                         | ✅ 가능 (`%s`, `%d`, `%f`, `%c` 등 지원) |
| 사용 편의성 | 매우 간단한 문자열 출력에 적합 | 복합 데이터 출력, 문자열 포맷 지정 가능 |
| 반환값      | 출력 성공 시 양수, 실패 시 EOF | 출력된 문자 수 또는 오류(-1)            |

### 🧪 비교 예제

```
char name[] = "Alice";

puts("Hello");
printf("Hello\n");

puts(name);
printf("%s\n", name);

printf("이름: %s, 길이: %d\n", name, strlen(name));
```

출력:

```
Hello
Hello
Alice
Alice
이름: Alice, 길이: 5
```

### ⚠️ 주의 사항

- `puts()`는 문자열 끝에 자동으로 `\n`을 붙이므로 줄바꿈이 필요하지 않을 때는 **`printf()`를 사용해야 함**
- `puts()`는 내부적으로 `fputs(str, stdout); putchar('\n');`처럼 구현됨
   → `NULL` 포인터를 전달하면 **정의되지 않은 동작(UB)**

### ✅ 실전 팁

- 간단한 문자열 한 줄 출력 → `puts()`
- 변수 포함 포맷 출력, 개행 제어 → `printf()`
- 로깅, 디버깅, 사용자 메시지 등에서는 대부분 `printf()` 사용이 더 일반적

### 🧠 결론

`puts()`는 **정적인 메시지 출력에 빠르고 안전한 도구**이며,
 `printf()`는 **동적 내용 출력, 포맷 지정, 숫자 출력 등**을 모두 아우를 수 있는
 **보다 강력하고 범용적인 출력 도구**다.

실제 개발에서는 **디버깅에는 printf, 간단한 안내 메시지에는 puts**,
 이렇게 **목적에 따라 선택적으로 사용**하는 것이 효율적이다.