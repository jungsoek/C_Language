# 7. 파일 입출력

# 7.1 파일 열기 및 닫기

## fopen, fclose

C 언어에서 `fopen()`과 `fclose()`는 표준 라이브러리 `<stdio.h>`에 정의된 **파일 입출력 함수**이다.
 `fopen()`은 파일을 **열고 연결된 FILE 포인터를 반환**하며,
 `fclose()`는 그 파일 포인터를 닫아 **자원을 해제**한다.

이 함수들은 텍스트 파일, 바이너리 파일을 다룰 수 있으며,
 **파일 디스크립터 수준보다 상위 수준의 스트림 입출력 인터페이스**를 제공한다.

### ✅ `fopen()` – 파일 열기

#### 🔧 함수 원형

```
FILE *fopen(const char *filename, const char *mode);
```

- `filename`: 열 파일 이름 (경로 포함 가능)
- `mode`: 파일 열기 모드 (아래 참조)
- 반환값: 파일 포인터(`FILE *`) 또는 실패 시 `NULL`

#### 📌 주요 모드

| 모드                | 의미                                     |
| ------------------- | ---------------------------------------- |
| `"r"`               | 읽기 전용 (파일 존재해야 함)             |
| `"w"`               | 쓰기 전용 (기존 파일 삭제, 없으면 생성)  |
| `"a"`               | 추가 전용 (파일 끝에 덧붙임)             |
| `"r+"`              | 읽기/쓰기 (파일 존재해야 함)             |
| `"w+"`              | 읽기/쓰기 (기존 삭제 후 새로 생성)       |
| `"a+"`              | 읽기/추가 (기존 유지, 끝에만 쓸 수 있음) |
| `"rb"`, `"wb"`, ... | 바이너리 모드                            |

### 🧪 `fopen()` 예제

```
#include <stdio.h>

int main() {
    FILE *fp = fopen("data.txt", "r");
    if (fp == NULL) {
        perror("파일 열기 실패");
        return 1;
    }

    // 파일 읽기 코드...
    fclose(fp);  // 반드시 닫기

    return 0;
}
```

------

### ✅ `fclose()` – 파일 닫기

#### 🔧 함수 원형

```
int fclose(FILE *stream);
```

- `stream`: 열려 있는 파일 포인터
- 반환값: 성공 시 `0`, 실패 시 `EOF`

📌 `fclose()`는:

- 버퍼에 남은 데이터를 디스크에 플러시
- 파일 디스크립터와 메모리 자원 해제

📌 **열린 모든 파일은 사용 후 반드시 닫아야 함**
 닫지 않으면 **데이터 유실, 메모리 누수, 파일 잠금 미해제** 등의 문제가 발생할 수 있다.

### 🧠 실전 체크리스트

| 항목             | 설명                                             |
| ---------------- | ------------------------------------------------ |
| 반환값 검사      | `fopen()`이 실패할 경우 반드시 `NULL` 체크       |
| 파일 닫기 필수   | `fclose()` 누락 시 버퍼 미쓰기 가능성 있음       |
| 여러 파일 처리   | 각 파일마다 `FILE *` 개별 선언 및 종료 처리 필요 |
| 에러 메시지 출력 | `perror()` 또는 `strerror(errno)` 활용 가능      |

### ✅ 요약

| 함수       | 목적                     | 반환값              |
| ---------- | ------------------------ | ------------------- |
| `fopen()`  | 파일 열기 및 포인터 반환 | `FILE*` 또는 `NULL` |
| `fclose()` | 파일 닫고 자원 해제      | `0` 또는 `EOF`      |

🧠 `fopen()`과 `fclose()`는 C에서 **가장 기초적이면서도 중요한 파일 입출력 인터페이스**다.
 이 두 함수 없이도 로우 레벨 시스템 호출을 사용할 수 있지만,
 **표준 스트림(`stdin`, `stdout`, `stderr`) 기반의 버퍼링된 I/O**를 구현하려면 반드시 사용해야 한다.
 📌 항상 `fopen()` → 처리 → `fclose()`의 **자원 생명주기 관리**를 철저히 하는 것이 C 프로그래밍의 기본이다.

## 파일 모드: "r", "w", "a", "rb", "wb" 등

C 언어에서 `fopen()` 함수는 파일을 열 때 **동작 방식을 문자열 모드**로 지정한다.
 이 모드는 파일을 **읽기/쓰기/추가** 중 어떻게 접근할지, 그리고 **텍스트 모드 또는 바이너리 모드**로 처리할지를 결정한다.

파일 모드는 `<stdio.h>`에 정의된 `fopen(const char *filename, const char *mode)`의 `mode` 인자에 해당한다.

### ✅ 기본 모드 요약

| 모드  | 의미               | 파일 존재 여부             | 내용 손실 여부  |
| ----- | ------------------ | -------------------------- | --------------- |
| `"r"` | 읽기 전용 (read)   | 파일이 반드시 있어야 함    | X               |
| `"w"` | 쓰기 전용 (write)  | 없으면 생성, 있으면 삭제됨 | ✅               |
| `"a"` | 추가 전용 (append) | 없으면 생성됨              | X (끝에 추가됨) |

#### 예:

```
FILE *f = fopen("log.txt", "a");  // 없으면 생성, 있으면 이어쓰기
```

### ✅ 확장 모드 (+)

| 모드   | 의미                             |
| ------ | -------------------------------- |
| `"r+"` | 읽기 + 쓰기 (초기 내용 유지)     |
| `"w+"` | 읽기 + 쓰기 (파일 내용 초기화)   |
| `"a+"` | 읽기 + 추가 (쓰기 시 항상 EOF로) |

#### 예:

```
FILE *f = fopen("data.txt", "r+");  // 기존 파일을 수정할 수 있음
```

### ✅ 바이너리 모드 (Windows 등에서 사용 필수)

| 모드                      | 의미                           | 설명                       |
| ------------------------- | ------------------------------ | -------------------------- |
| `"rb"`                    | 바이너리 읽기                  | 텍스트 변환 없이 원본 읽음 |
| `"wb"`                    | 바이너리 쓰기 (삭제 후 새로)   | 바이너리 파일 저장에 적합  |
| `"ab"`                    | 바이너리 추가 (EOF 뒤에만)     | ex) 이미지 이어붙이기 등   |
| `"rb+"`, `"wb+"`, `"ab+"` | 읽기+쓰기 형태의 바이너리 모드 | 동시 읽기·쓰기 지원        |

📌 리눅스에서는 텍스트/바이너리 차이가 없지만,
 **Windows에서는 텍스트 모드에서 `\n` → `\r\n` 변환**이 일어나므로
 이진 데이터 파일은 반드시 `"rb"`, `"wb"`처럼 **바이너리 모드로 열어야 정확한 저장/읽기**가 된다.

### ✅ 요약 정리표

| 모드   | 읽기 | 쓰기 | 파일 생성 | 파일 삭제 | 추가 위치  |
| ------ | ---- | ---- | --------- | --------- | ---------- |
| `"r"`  | ✅    | ❌    | ❌         | ❌         | -          |
| `"w"`  | ❌    | ✅    | ✅         | ✅         | 처음부터   |
| `"a"`  | ❌    | ✅    | ✅         | ❌         | 끝에서부터 |
| `"r+"` | ✅    | ✅    | ❌         | ❌         | 현재 위치  |
| `"w+"` | ✅    | ✅    | ✅         | ✅         | 처음부터   |
| `"a+"` | ✅    | ✅    | ✅         | ❌         | 끝에서부터 |
| `"rb"` | ✅    | ❌    | ❌         | ❌         | -          |
| `"wb"` | ❌    | ✅    | ✅         | ✅         | 처음부터   |
| `"ab"` | ❌    | ✅    | ✅         | ❌         | 끝에서부터 |

### ✅ 실전 팁

- 텍스트 파일은 `"r"`, `"w"`, `"a"`를 사용
- 바이너리 파일 (이미지, 이진 로그 등)은 `"rb"`, `"wb"`로 반드시 열 것
- 기존 내용을 보존하면서 수정하려면 `"r+"`
- 로그를 쌓을 때는 `"a"` 또는 `"a+"`

### 🧠 결론

 **파일 모드는 "파일을 어떻게 열 것인가"를 완벽히 결정짓는 핵심 파라미터**다.
 잘못된 모드를 사용하면 **파일 데이터 손실**, **쓰기 오류**, 또는 **바이너리 훼손**이 발생할 수 있으므로,
 사용 목적에 맞게 **텍스트/바이너리 여부 + 읽기/쓰기/추가 여부**를 정확히 판단하고 모드를 지정해야 한다.

# 7.2 텍스트 파일 입출력

## fprintf, fscanf

`fprintf()`와 `fscanf()`는 C 표준 라이브러리 `<stdio.h>`에 정의된 함수로,
 **파일에 형식을 지정해 출력하거나**, **파일에서 형식을 지정해 입력**하는 데 사용된다.
 이 함수들은 `printf()`, `scanf()`와 유사하지만, **파일 스트림(`FILE\*`)을 대상으로 동작**한다.

### ✅ `fprintf()` – 파일로 출력

#### 🔧 함수 원형

```
int fprintf(FILE *stream, const char *format, ...);
```

- `stream`: 파일 포인터 (`FILE*`)
- `format`: 출력 형식 문자열 (`printf()`와 동일)
- `...`: 가변 인자 (형식에 맞는 값들)
- 반환값: 출력한 문자 수, 실패 시 음수

#### 🧪 예제

```
FILE *fp = fopen("output.txt", "w");
if (fp) {
    fprintf(fp, "이름: %s, 나이: %d\n", "Alice", 30);
    fclose(fp);
}
```

📌 `printf()` → 표준 출력
 📌 `fprintf(fp, ...)` → 파일로 출력

### ✅ `fscanf()` – 파일에서 입력

#### 🔧 함수 원형

```
int fscanf(FILE *stream, const char *format, ...);
```

- `stream`: 읽을 파일 포인터
- `format`: 입력 형식 지정 문자열 (`scanf()`와 동일)
- `...`: 변수 주소 전달 (입력된 값을 저장할 공간)
- 반환값: 성공적으로 읽은 항목 수, 실패 시 `EOF`

#### 🧪 예제

```
FILE *fp = fopen("input.txt", "r");
char name[20];
int age;

if (fp) {
    fscanf(fp, "이름: %s, 나이: %d", name, &age);
    printf("이름: %s, 나이: %d\n", name, age);
    fclose(fp);
}
```

📌 파일에서 포맷과 일치하는 텍스트를 찾아서 변수에 저장
 📌 `%s`, `%d`, `%f` 등의 형식 지정자 사용 가능

### ✅ 사용 시 주의사항

| 항목                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| `fopen()` 이후 사용 | 반드시 파일이 `NULL`이 아닌지 확인해야 함                    |
| 포인터 전달         | `fscanf()`에서는 값을 저장할 변수의 **주소**를 전달해야 함 (`&`) |
| 파일 형식 일치      | `fscanf()`는 파일 내 포맷이 `format`과 정확히 일치해야 올바르게 읽힘 |
| 버퍼 오버런 주의    | `%s` 사용 시 **최대 입력 길이 지정** 필요 (`%19s` 등)        |

### ✅ 형식 지정자 요약

| 형식자 | 설명                 | 예                          |
| ------ | -------------------- | --------------------------- |
| `%d`   | 정수 (int)           | `fprintf(fp, "%d", 10);`    |
| `%f`   | 실수 (float, double) | `fprintf(fp, "%.2f", 3.14)` |
| `%s`   | 문자열 (char[])      | `fprintf(fp, "%s", "abc");` |
| `%c`   | 문자 (char)          | `fprintf(fp, "%c", 'A');`   |

### ✅ 실전 예: 구조체 저장/불러오기

```
struct Person {
    char name[20];
    int age;
};
```

#### 파일로 저장

```
struct Person p = {"Bob", 25};
FILE *fp = fopen("person.txt", "w");
fprintf(fp, "%s %d\n", p.name, p.age);
fclose(fp);
```

#### 파일에서 읽기

```
struct Person p;
FILE *fp = fopen("person.txt", "r");
fscanf(fp, "%s %d", p.name, &p.age);
fclose(fp);
```

### ✅ `fprintf()` vs `fwrite()`

| 항목      | `fprintf()`          | `fwrite()`                 |
| --------- | -------------------- | -------------------------- |
| 단위      | **문자열 포맷 기반** | **메모리 블록 기반 (raw)** |
| 사용 대상 | 텍스트 파일          | 바이너리 파일              |
| 가독성    | 사람이 읽기 쉬움     | 컴퓨터 처리에 효율적       |
| 포맷 지정 | `"%d %s %.2f"` 등    | 없음                       |

### ✅ 요약

| 함수      | 목적                    | 인자                            |
| --------- | ----------------------- | ------------------------------- |
| `fprintf` | 포맷 기반 **파일 출력** | `FILE*`, `format`, 값...        |
| `fscanf`  | 포맷 기반 **파일 입력** | `FILE*`, `format`, 변수 주소... |

### 🧠 결론

 `fprintf()`와 `fscanf()`는 C의 **텍스트 기반 파일 입출력의 핵심 도구**다.

- 사람이 읽고 쓰는 로그, 설정, 저장 파일 등에 적합하고
- 파일 입출력을 시스템 수준에서 제어하고 싶다면 **버퍼 관리까지 고려해 사용**해야 한다.
   📌 항상 `fopen()` → 처리 → `fclose()`의 **파일 생명주기 관리**를 철저히 지키는 것이 중요하다.

## fgets, fputs

C 언어에서 `fgets()`와 `fputs()`는 `<stdio.h>` 헤더에 정의된 함수로,
 **파일(또는 스트림)에서 문자열 단위로 읽고 쓸 수 있는 표준 입출력 함수**다.
 이들은 **텍스트 입출력에 특화**되어 있으며, `fscanf()`/`fprintf()`보다 더 **단순하고 줄 단위 처리**에 유리하다.

### ✅ `fgets()` – 파일로부터 한 줄 읽기

#### 🔧 함수 원형

```
char *fgets(char *str, int n, FILE *stream);
```

| 매개변수 | 설명                               |
| -------- | ---------------------------------- |
| `str`    | 문자열이 저장될 배열 (버퍼)        |
| `n`      | 읽을 최대 문자 수 (`n-1`개 + `\0`) |
| `stream` | 읽을 대상 파일 포인터              |

📌 **최대 `n-1`자까지 읽고 마지막에 `\0` 자동 추가**
 📌 줄 끝의 개행 문자(`\n`)도 포함되며, **파일 끝이나 오류 시 NULL 반환**

#### 🧪 예제

```
char line[100];
FILE *fp = fopen("data.txt", "r");

if (fp) {
    while (fgets(line, sizeof(line), fp) != NULL) {
        printf("읽은 줄: %s", line);  // 이미 줄 끝에 \n 포함됨
    }
    fclose(fp);
}
```

### ✅ `fputs()` – 문자열을 파일에 쓰기

#### 🔧 함수 원형

```
int fputs(const char *str, FILE *stream);
```

| 매개변수 | 설명                             |
| -------- | -------------------------------- |
| `str`    | 출력할 문자열 (`\0`로 끝나야 함) |
| `stream` | 출력할 대상 파일 포인터          |

📌 **문자열 전체를 그대로 출력**하되,
 📌 `\n`은 자동으로 붙지 않음 → 필요 시 명시적으로 추가해야 함

#### 🧪 예제

```
FILE *fp = fopen("log.txt", "w");

if (fp) {
    fputs("로그 기록 시작\n", fp);
    fputs("Hello, world!\n", fp);
    fclose(fp);
}
```

### ✅ `fgets()` vs `gets()` 차이점

| 함수      | 버퍼 크기 지정 | 버퍼 오버플로 방지 | 개행 문자 포함 | 보안성      |
| --------- | -------------- | ------------------ | -------------- | ----------- |
| `gets()`  | ❌ 없음         | ❌ 위험함           | ❌ (자동 제거)  | ❌ 사용 금지 |
| `fgets()` | ✅ 있음         | ✅ 안전함           | ✅ 포함됨       | ✅ 권장 사용 |

📌 C11부터는 `gets()`는 **표준에서 완전히 제거됨** → 반드시 `fgets()` 사용

### ✅ 실전 예제: 줄 단위 복사

```
FILE *src = fopen("input.txt", "r");
FILE *dst = fopen("output.txt", "w");

char buffer[256];

if (src && dst) {
    while (fgets(buffer, sizeof(buffer), src)) {
        fputs(buffer, dst);
    }
    fclose(src);
    fclose(dst);
}
```

📌 줄 단위로 읽어와 그대로 복사하는 안전한 텍스트 파일 복사 루틴

### ✅ 요약

| 함수    | 목적                        | 자동 개행 포함   | 반환값                      |
| ------- | --------------------------- | ---------------- | --------------------------- |
| `fgets` | 파일에서 문자열(한 줄) 읽기 | ✅ 포함           | 읽은 문자열 또는 NULL       |
| `fputs` | 문자열을 파일에 쓰기        | ❌ 수동 삽입 필요 | 성공 시 0 이상, 실패 시 EOF |

🧠 `fgets()`와 `fputs()`는 **텍스트 파일을 다룰 때 가장 직관적이고 안전한 도구**다.

- 줄 단위 읽기/쓰기
- 보안성 있는 문자열 처리
- 간단한 로그 처리 및 라인 기반 편집기 구현 등에 적합

📌 특히 사용자 입력을 받을 때나 로그 기록할 때는 `fgets()` + `fputs()` 조합이
 **버퍼 초과 위험 없이 안정적인 선택**이다.

# 7.3 바이너리 파일 입출력

## fread, fwrite

(이진 파일 입출력 함수)

C 언어에서 `fread()`와 `fwrite()`는 `<stdio.h>`에 정의된 **이진(binary) 파일 입출력 함수**이다.
 텍스트 기반의 `fgets()`나 `fprintf()`와 달리, **메모리 블록 단위로 파일을 직접 읽고 쓰는 저수준 함수**로,
 **구조체, 배열, 바이너리 데이터, 이미지 파일 등**을 처리할 때 매우 적합하다.

### ✅ 함수 원형

```
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
```

| 매개변수   | 설명                                                       |
| ---------- | ---------------------------------------------------------- |
| `ptr`      | 읽기/쓰기 대상 버퍼의 시작 주소 (`void*`)                  |
| `size`     | 각 항목의 크기 (단위: 바이트)                              |
| `nmemb`    | 항목의 개수 (몇 개의 단위를 읽고 쓸 것인지)                |
| `stream`   | 파일 포인터 (`FILE*`)                                      |
| **반환값** | 성공적으로 읽거나 쓴 **항목 수** (단위: 개수, 바이트 아님) |

📌 총 처리된 바이트 수 = `size × nmemb`

### 🧪 예제 1: 파일에서 이진 데이터 읽기 (`fread`)

```
FILE *fp = fopen("data.bin", "rb");
int numbers[5];

if (fp) {
    fread(numbers, sizeof(int), 5, fp);  // 5개의 int 읽기
    fclose(fp);
}
```

### 🧪 예제 2: 파일에 이진 데이터 쓰기 (`fwrite`)

```
FILE *fp = fopen("data.bin", "wb");
int values[5] = {10, 20, 30, 40, 50};

if (fp) {
    fwrite(values, sizeof(int), 5, fp);  // 5개의 int 쓰기
    fclose(fp);
}
```

### ✅ 구조체 저장/복원 예

```
typedef struct {
    char name[20];
    int age;
} Person;
```

#### 저장:

```
Person p = {"Alice", 30};
fwrite(&p, sizeof(Person), 1, fp);
```

#### 복원:

```
Person p;
fread(&p, sizeof(Person), 1, fp);
```

### ⚠️ 주의사항

| 항목                    | 설명                                                         |
| ----------------------- | ------------------------------------------------------------ |
| 포맷 지정 없음          | `fread`/`fwrite`는 형식을 지정하지 않음 → **완전히 메모리 복사 수준** |
| 구조체 패딩 주의        | 구조체에 있는 **padding(정렬된 여분 바이트)**도 함께 저장됨  |
| 크로스 플랫폼 문제      | 시스템 간 **엔디안, 구조체 크기 차이, 정렬 차이**로 복원 오류 가능 |
| 텍스트 ↔ 이진 호환 불가 | `fwrite`로 저장한 파일은 `fprintf`로 읽을 수 없음 (`fscanf`도 마찬가지) |

### ✅ 비교: `fwrite()` vs `fprintf()`

| 항목          | `fwrite()`                             | `fprintf()`                          |
| ------------- | -------------------------------------- | ------------------------------------ |
| 대상          | 바이너리 데이터, 구조체                | 텍스트 파일, 포맷 지정 가능한 문자열 |
| 포맷 지정     | ❌ 없음 (그대로 저장)                   | ✅ 있음 (`"%d %s"` 등)                |
| 복구 가능성   | 시스템 구조 의존 (엔디안 등 주의 필요) | 사람이 읽기 가능, 쉽게 복원 가능     |
| 전형적 사용처 | 로그 저장, 구조체 직렬화, 이미지 파일  | 설정 파일, 로그, 텍스트 레코드       |

### ✅ 읽기 종료 판단 (`fread`)

```
while (fread(&p, sizeof(Person), 1, fp) == 1) {
    // 읽기 성공한 경우만 실행
}
```

📌 `fread()`는 **읽은 항목 수를 반환**하므로 이를 통해 EOF 또는 오류 판단 가능

### ✅ 요약

| 함수     | 용도               | 모드      | 반환값                    |
| -------- | ------------------ | --------- | ------------------------- |
| `fread`  | 파일 → 메모리 읽기 | `"rb"` 등 | 읽은 항목 수 (`size × n`) |
| `fwrite` | 메모리 → 파일 쓰기 | `"wb"` 등 | 쓴 항목 수 (`size × n`)   |

### 🧠 결론

- `fread`/`fwrite`는 **텍스트가 아닌 메모리 자체를 저장하고 복원하는 가장 빠르고 직관적인 방법**
- 구조체 직렬화, 센서 로그 저장, 패킷 분석, 바이너리 전송 등에 필수
- 다만 구조체 padding, endianness, 플랫폼 차이 등은 **명확히 통제되어야**
   안정적인 저장과 복원이 가능하다.

# 7.4 파일 위치 제어

## ftell, fseek, rewind

### 📍 1. `ftell(FILE *stream)`

#### 🔹 기능

- 현재 파일 포인터의 **오프셋(offset)** 을 반환.
- 즉, `stream`이 가리키는 **파일 내 현재 위치(바이트 단위)** 를 알려줌.
- 반환값은 **파일의 시작부터 현재 위치까지의 바이트 수**.

#### 🔹 함수 원형

```
long ftell(FILE *stream);
```

#### 🔹 반환값

- 성공 시: 현재 위치를 **long 형식**으로 반환
- 실패 시: `-1L` 반환

#### 🔹 사용 예제

```
FILE *fp = fopen("example.txt", "r");
if (fp != NULL) {
    fseek(fp, 0, SEEK_END);      // 파일 끝으로 이동
    long size = ftell(fp);       // 파일 크기 얻기
    printf("파일 크기: %ld 바이트\n", size);
    fclose(fp);
}
```

### 📍 2. `fseek(FILE *stream, long offset, int origin)`

#### 🔹 기능

- 파일 포인터의 **위치를 지정한 기준점으로부터 offset만큼 이동**함.

#### 🔹 함수 원형

```
int fseek(FILE *stream, long offset, int origin);
```

#### 🔹 인자 설명

| 인자     | 설명                                              |
| -------- | ------------------------------------------------- |
| `stream` | 조작할 파일 포인터                                |
| `offset` | 이동할 바이트 수 (음수면 역방향)                  |
| `origin` | 기준점 설정값: `SEEK_SET`, `SEEK_CUR`, `SEEK_END` |

- `SEEK_SET`: 파일의 시작 위치
- `SEEK_CUR`: 현재 위치
- `SEEK_END`: 파일의 끝

#### 🔹 반환값

- 성공 시: 0
- 실패 시: `-1`

#### 🔹 사용 예제

```
FILE *fp = fopen("example.txt", "r");
if (fp != NULL) {
    fseek(fp, 10, SEEK_SET);  // 파일 시작에서 10바이트 앞으로 이동
    int ch = fgetc(fp);
    printf("10번째 바이트: %c\n", ch);
    fclose(fp);
}
```

### 📍 3. `rewind(FILE *stream)`

#### 🔹 기능

- 파일 포인터를 **파일의 맨 처음으로 이동**시킴.
- `fseek(stream, 0, SEEK_SET)`와 동일하지만 **에러 플래그도 초기화**함.

#### 🔹 함수 원형

```
void rewind(FILE *stream);
```

#### 🔹 반환값

- 반환값 없음 (void)

#### 🔹 사용 예제

```
FILE *fp = fopen("example.txt", "r");
if (fp != NULL) {
    fseek(fp, 100, SEEK_SET);  // 임의 위치로 이동
    rewind(fp);                // 다시 처음으로 이동
    char ch = fgetc(fp);
    printf("첫 번째 문자: %c\n", ch);
    fclose(fp);
}
```

### 🧠 심화 개념

#### 🔸 `ftell`과 `fseek`의 조합

파일 전체를 탐색하거나 특정 위치로 이동하여 편집 또는 분석할 때 필수적으로 사용돼.

#### 🔸 이진 파일 처리 시 유용성

텍스트 파일보단 바이너리(`"rb"` 모드)에서 위치 이동이 더 명확함. 줄바꿈 처리(`\n`, `\r\n`)가 OS마다 다르기 때문에, **텍스트 파일의 offset은 비직관적**일 수 있음.

### ⚠️ 주의 사항

| 상황                  | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| 텍스트 파일에서 fseek | 일부 플랫폼에서 `fseek`과 `ftell`이 정확하지 않을 수 있음 (줄바꿈 문제 등) |
| rewind vs fseek       | `rewind()`은 에러 상태 플래그를 함께 초기화하지만 `fseek(fp, 0, SEEK_SET)`은 그렇지 않음 |
| 파일 모드 주의        | `"r"`, `"w"`, `"rb"`, `"wb"` 모드에 따라 동작이 달라질 수 있음 |

