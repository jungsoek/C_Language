# 8. 동적 메모리 관리

# 8.1 동적 메모리 할당

## malloc, calloc

### 📌 `malloc` 함수

#### 🧾 개요

`malloc` 함수는 **지정한 바이트 수만큼 연속된 메모리 블록**을 **동적으로 할당**하고, 그 시작 주소를 반환한다.

> ⚠️ 단, **할당된 메모리는 초기화되지 않는다.** 따라서 사용 전 초기화가 필요하다.

#### 🧪 함수 원형

```
void *malloc(size_t size);
```

#### 📥 매개변수

| 매개변수 | 설명                              |
| -------- | --------------------------------- |
| `size`   | 할당할 메모리 크기 (단위: 바이트) |

예: `sizeof(int) * 10` 은 `int` 10개 크기만큼 메모리 확보

#### 📤 반환값

| 상황      | 반환값          |
| --------- | --------------- |
| 할당 성공 | void* 형 포인터 |
| 할당 실패 | `NULL`          |

#### 📌 사용 예시

```
#include <stdlib.h>

int *arr = (int *)malloc(sizeof(int) * 5);
if (arr == NULL) {
    // 메모리 부족 등의 이유로 할당 실패
}
```

#### ⚠️ 주의사항

- 반환값은 **void\***이므로, 필요 시 적절한 형변환을 해주어야 한다 (C++에서는 필수).
- `malloc`으로 할당된 메모리는 반드시 `free()`로 해제해야 한다. 그렇지 않으면 **메모리 누수**가 발생할 수 있다.

### 📌 `calloc` 함수

#### 🧾 개요

`calloc` 함수는 **요소 개수와 각 요소의 크기를 기반으로 메모리를 할당**하며,
 할당된 모든 메모리 공간을 **0으로 초기화**한다.

> ✅ 배열이나 구조체를 초기화된 상태로 할당할 때 유용하다.

#### 🧪 함수 원형

```
void *calloc(size_t num_elements, size_t element_size);
```

#### 📥 매개변수

| 매개변수       | 설명                  |
| -------------- | --------------------- |
| `num_elements` | 할당할 요소의 개수    |
| `element_size` | 각 요소의 바이트 크기 |

예: `calloc(5, sizeof(int))` → `int` 5개에 대한 0 초기화된 메모리 확보

#### 📤 반환값

| 상황      | 반환값          |
| --------- | --------------- |
| 할당 성공 | void* 형 포인터 |
| 할당 실패 | `NULL`          |

#### 📌 사용 예시

```
#include <stdlib.h>

int *arr = (int *)calloc(5, sizeof(int));
if (arr == NULL) {
    // 메모리 부족
}
```

### 🆚 `malloc` vs `calloc` 비교표

| 항목        | `malloc`                          | `calloc`                            |
| ----------- | --------------------------------- | ----------------------------------- |
| 초기화 여부 | ❌ 초기화되지 않음 (쓰레기값 존재) | ✅ 0으로 초기화됨                    |
| 인자 수     | 1개 (`전체 바이트 수`)            | 2개 (`요소 개수`, `요소 크기`)      |
| 속도        | 더 빠를 수 있음                   | 초기화로 인해 약간 느릴 수 있음     |
| 사용 용도   | 빠르게 메모리만 할당할 때         | 배열 또는 구조체 초기화가 필요할 때 |

### 🧠 심화 설명

#### ✅ 왜 `calloc`이 필요한가?

- `calloc`은 내부적으로 **`malloc` + `memset(0)`** 과 유사하게 동작함.
- 예를 들어, 포인터 배열이나 구조체의 멤버 변수를 **명시적으로 초기화하지 않아도** 되는 장점이 있음.

#### 🧪 예제: 차이점 확인

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *a = (int *)malloc(sizeof(int) * 5);
    int *b = (int *)calloc(5, sizeof(int));

    printf("malloc 결과:\n");
    for (int i = 0; i < 5; i++) printf("%d ", a[i]); // 초기화 안 됨
    printf("\n");

    printf("calloc 결과:\n");
    for (int i = 0; i < 5; i++) printf("%d ", b[i]); // 모두 0

    free(a);
    free(b);
    return 0;
}
```

#### 🧯 메모리 해제 필수

```
free(arr);  // malloc, calloc 공통 해제 방법
```

> 💡 할당 후 사용하지 않는 메모리는 반드시 해제해야 한다.
>  그렇지 않으면 시스템 자원을 지속적으로 소비하여 **메모리 누수(leak)** 로 이어질 수 있다.

## realloc에 의한 재할당

### 📌 `realloc` 함수

#### 🧾 개요

`realloc` 함수는 기존에 `malloc` 또는 `calloc` 등으로 동적으로 할당된 메모리 블록의 크기를 변경하고, 변경된 크기의 **새로운 메모리 블록의 시작 주소를 반환**한다.

- **확장 시**: 기존 데이터를 유지한 채 크기를 늘릴 수 있다.
- **축소 시**: 앞부분 데이터는 유지되며 뒤쪽은 잘려나간다.
- 새로 할당된 영역은 **초기화되지 않는다**.

#### 🧪 함수 원형

```
void *realloc(void *ptr, size_t new_size);
```

#### 📥 매개변수

| 매개변수   | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| `ptr`      | 기존에 할당된 메모리 블록의 포인터 (`malloc`, `calloc`, `realloc`로 얻은 것) |
| `new_size` | 변경하고자 하는 메모리의 **새로운 크기** (단위: 바이트)      |

#### 📤 반환값

| 상황 | 반환값                                                |
| ---- | ----------------------------------------------------- |
| 성공 | 새 크기로 재할당된 메모리 블록의 시작 주소 (void*)    |
| 실패 | `NULL` (원래 메모리는 그대로 유지되며, 손실되지 않음) |

#### 💡 사용 예시

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int *)malloc(sizeof(int) * 5);
    if (arr == NULL) return 1;

    for (int i = 0; i < 5; i++) arr[i] = i + 1;

    // 크기를 10개의 int로 확장
    int *new_arr = (int *)realloc(arr, sizeof(int) * 10);
    if (new_arr == NULL) {
        // 재할당 실패 → 원래 arr는 여전히 유효하므로 해제 필요
        free(arr);
        return 1;
    }

    // 새 메모리 사용
    for (int i = 5; i < 10; i++) new_arr[i] = (i + 1) * 10;

    for (int i = 0; i < 10; i++) printf("%d ", new_arr[i]);

    free(new_arr); // 해제
    return 0;
}
```

### 🔁 작동 원리 요약

| 동작 상황       | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| 확장 시         | 새로 확보된 영역은 초기화되지 않으며, 기존 데이터는 유지됨   |
| 축소 시         | 앞 부분 데이터만 유지되고, 나머지는 제거됨                   |
| 실패 시         | `NULL` 반환, 원래 메모리는 손상되지 않음                     |
| `ptr == NULL`   | `malloc(new_size)`과 동일하게 동작                           |
| `new_size == 0` | 구현에 따라 `NULL`을 반환하거나, `free(ptr)`과 동일하게 동작할 수 있음 (⚠️ 주의 필요) |

### 🔍 realloc vs malloc 비교표

| 항목         | `malloc`              | `realloc`                      |
| ------------ | --------------------- | ------------------------------ |
| 역할         | 새 메모리 블록을 할당 | 기존 메모리 블록 크기 조절     |
| 입력 포인터  | 없음 (`NULL`)         | 기존 블록의 포인터 필요        |
| 초기화 여부  | ❌ 초기화되지 않음     | ❌ 새 영역도 초기화되지 않음    |
| 실패 시 처리 | `NULL` 반환           | `NULL` 반환 + 기존 메모리 보존 |

### ⚠️ 주의사항

#### ❗ 반환값을 바로 덮어쓰지 말 것

```
arr = realloc(arr, new_size); // ❌ 위험
```

만약 실패하면 `arr`는 `NULL`이 되어 **기존 메모리를 잃고 메모리 누수 발생** 가능성이 있다.

**권장 방식:**

```
void *tmp = realloc(arr, new_size);
if (tmp != NULL) {
    arr = tmp;
} else {
    // 기존 arr는 여전히 유효 → free(arr);
}
```

### ✅ 활용 사례

1. 사용자가 입력한 데이터 개수에 따라 배열을 유연하게 확장해야 할 때
2. 구조체 배열, 문자열 버퍼, 리스트 등에서 **성능 최적화**를 위해 부분 할당하고 점진적으로 확장할 때
3. 메모리 사용량을 절감하기 위해 **사용량만큼만 재조정**할 때

### 🧯 메모리 해제

```
free(변수명);
```

`realloc`을 통해 변경된 주소를 **반드시 추적해서 해제**해야 한다.
 초기 포인터로 해제할 수 없는 경우가 있다.

### 🧠 정리 요약

| 함수      | 특징                                      |
| --------- | ----------------------------------------- |
| `malloc`  | 초기화되지 않은 메모리를 새로 할당        |
| `calloc`  | 0으로 초기화된 메모리를 새로 할당         |
| `realloc` | 기존 메모리의 크기를 조정하며 데이터 유지 |

## free에 의한 해제

### 📌 `realloc` 함수 – 메모리 재할당

#### 🧾 개요

`realloc` 함수는 기존에 `malloc`, `calloc`, 또는 이전 `realloc`에 의해 할당된 메모리 블록의 크기를 변경한다.
 재할당된 메모리 블록은 새 크기에 맞게 조정되며, 필요한 경우 다른 위치로 이동될 수 있다.

#### 🧪 함수 원형

```
void *realloc(void *ptr, size_t new_size);
```

#### 📥 매개변수

| 매개변수   | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| `ptr`      | 현재 메모리를 가리키는 포인터 (NULL일 경우 `malloc`처럼 동작) |
| `new_size` | 새롭게 요청할 메모리 크기 (바이트 단위)                      |

#### 📤 반환값

| 상황 | 반환값                                               |
| ---- | ---------------------------------------------------- |
| 성공 | 새로 할당된 메모리 블록의 시작 주소                  |
| 실패 | `NULL` 반환, 기존 메모리는 그대로 유지됨 (주의 필요) |

#### 💡 주요 특징

- 기존 데이터는 새로운 메모리 공간에 **자동으로 복사**됨.
- `ptr == NULL`인 경우 → `malloc(new_size)`와 동일한 효과.
- `new_size == 0`인 경우 → `free(ptr)`과 동일하며, NULL 반환.

#### 🧪 사용 예시

```
int *arr = (int *)malloc(sizeof(int) * 5);
if (arr == NULL) return 1;

// 더 큰 배열로 확장
int *temp = (int *)realloc(arr, sizeof(int) * 10);
if (temp == NULL) {
    // 재할당 실패 시 arr는 여전히 유효, 반드시 free(arr) 필요
    free(arr);
    return 1;
}
arr = temp;
```

#### ⚠️ 주의사항

| 항목               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 반환값 확인        | 실패 시 기존 메모리는 유지되므로 `temp`에 저장 후 `arr = temp` 방식 사용 권장 |
| 데이터 유실 가능성 | 재할당 중 주소 변경 발생 시 이전 메모리 블록은 더 이상 유효하지 않음 |
| 성능 고려          | 자주 크기를 변경하는 구조보단 **미리 충분히 할당**하는 것이 성능상 유리할 수 있음 |

### 📌 `free` 함수 – 메모리 해제

#### 🧾 개요

`free` 함수는 `malloc`, `calloc`, 또는 `realloc`에 의해 동적으로 할당된 메모리 블록을 해제하여 시스템에 반환한다.

> ⚠️ 한 번 해제한 메모리는 다시 접근하면 **정의되지 않은 동작(UB)** 을 일으킨다.

#### 🧪 함수 원형

```
void free(void *ptr);
```

#### 📥 매개변수

| 매개변수 | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| `ptr`    | 해제할 메모리를 가리키는 포인터. NULL일 경우 아무 작업도 하지 않음. |

#### 📌 사용 예시

```
int *data = (int *)malloc(sizeof(int) * 10);
if (data != NULL) {
    // 메모리 사용
    free(data);  // 반드시 해제
}
```

#### ⚠️ 주의사항

| 항목          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| NULL 포인터   | `free(NULL)`은 아무 작업도 하지 않으며 안전함                |
| 이중 해제     | 동일한 포인터를 두 번 이상 `free()`하면 프로그램이 충돌하거나 오류 발생 |
| 해제 후 접근  | `free()` 이후 해당 메모리 접근 시 **미정의 동작(UB)** 발생 가능 |
| 포인터 초기화 | `free(ptr)` 후 `ptr = NULL`로 초기화하는 습관이 메모리 오류 방지에 도움 됨 |

#### ✅ 안전한 해제 예시

```
char *buffer = (char *)malloc(100);
if (buffer) {
    // 사용
    free(buffer);
    buffer = NULL;  // 이중 해제 방지
}
```

### 📊 `realloc` vs `free` 비교 요약

| 항목         | `realloc`                                | `free`                      |
| ------------ | ---------------------------------------- | --------------------------- |
| 목적         | 메모리 블록 크기 재조정                  | 동적 메모리 해제            |
| 인자         | 기존 포인터와 새 크기                    | 기존 포인터                 |
| 반환값       | 새 메모리 주소 (성공 시), NULL (실패 시) | 없음 (void 함수)            |
| 실패 시 동작 | 기존 메모리 유지                         | 작업 없음 (NULL이면 안전함) |
| 위험 요소    | 실패 후 포인터 갱신 누락, 메모리 누수    | 이중 해제, 해제 후 접근     |

# 8.2 메모리 누수 방지 및 포인터 초기화

## NULL 포인터

### 📌 `NULL 포인터` (Null Pointer)

#### 🧾 개요

C 언어에서 `NULL 포인터`란, **어떤 객체도 가리키지 않는 포인터**를 의미한다.
 이는 포인터가 아직 **어떤 유효한 메모리 주소도 할당받지 않은 상태**를 명시적으로 나타낼 때 사용된다.

#### 🧪 선언 방법

```
#include <stddef.h>

int *ptr = NULL;  // 또는
int *ptr = 0;     // (C에서 허용되지만 권장되지 않음)
```

> 📌 C99 이후로는 `NULL`은 `((void*)0)`로 정의되어 있다.

#### 🧠 사용 목적

| 용도      | 설명                                           |
| --------- | ---------------------------------------------- |
| 초기화    | 포인터 선언 시 명확한 초기값 부여              |
| 상태 확인 | 동적 메모리 할당 실패 여부 검사                |
| 예외 처리 | 조건 분기 시 유효 포인터 여부 확인             |
| 안전 해제 | `free()` 이후 포인터 초기화하여 이중 해제 방지 |

#### ✅ 사용 예시

```
int *data = (int *)malloc(sizeof(int) * 10);
if (data == NULL) {
    // 메모리 할당 실패 시 처리
}
...
free(data);
data = NULL;  // 안전하게 포인터 초기화
```

#### ⚠️ 주의사항

| 항목        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| 잘못된 접근 | `*ptr` 처럼 NULL을 역참조하면 **Segmentation Fault** 발생    |
| 비교 연산   | 반드시 `if (ptr == NULL)` 또는 `if (!ptr)` 등으로 확인       |
| NULL ≠ 0    | C에서는 NULL이 0으로 정의되지만, 포인터와 정수는 의미적으로 다르므로 **`NULL` 사용을 권장** |

#### 💣 잘못된 사용 예

```
int *ptr = NULL;
*ptr = 100;     // ❌ → 런타임 에러 (Segmentation Fault)
```

### 🔍 NULL 포인터를 활용한 안전한 메모리 관리

#### ⛑️ 동적 메모리 패턴 예시

```
int *buffer = (int *)malloc(100 * sizeof(int));
if (buffer == NULL) {
    // 메모리 할당 실패
    return;
}

// 사용 후
free(buffer);
buffer = NULL;  // 이중 해제 방지
```

### 📊 NULL 포인터 요약 표

| 항목        | 내용                                           |
| ----------- | ---------------------------------------------- |
| 정의        | 아무 것도 가리키지 않는 포인터                 |
| 값          | `((void*)0)` 또는 `0` (C에서 허용)             |
| 주 용도     | 초기화, 비교, 오류 처리, 안전한 해제 등        |
| 역참조 위험 | ❌ `*ptr` 금지 → 세그멘테이션 오류 발생         |
| 권장 방식   | 항상 `ptr == NULL` 또는 `ptr != NULL`으로 검사 |

### 🧠 심화 개념

#### 🔸 NULL vs 0 vs '\0'

| 표현   | 의미                                       |
| ------ | ------------------------------------------ |
| `NULL` | 포인터 상의 "없음" 의미                    |
| `0`    | 정수 0                                     |
| `'\0'` | 문자형 null, 즉 ASCII 0 (문자열 종료 문자) |

> 👆 각각은 타입과 의미가 다르며, 적절한 문맥에서 사용해야 한다.

## 해제 후 사용 방지

### 📌 해제 후 사용 방지 (`Use After Free`)

#### 🧾 개요

`Use After Free`란, **이미 `free()` 함수를 통해 해제된 메모리 영역에 다시 접근하거나 사용하는 행위**를 말한다.
 이는 정의되지 않은 동작(Undefined Behavior)을 유발하며, 프로그램이 예기치 않게 **오류, 데이터 손상, 보안 취약점** 등을 일으킬 수 있다.

### 🔥 대표적인 잘못된 예시

```
int *data = (int *)malloc(sizeof(int) * 5);
free(data);

data[0] = 10;    // ❌ 해제된 메모리에 접근 → Use After Free 오류
```

> ⚠️ 이 코드는 **세그멘테이션 폴트(Segmentation Fault)** 또는 **무의미한 결과**를 일으킬 수 있다.

### ✅ 안전한 메모리 해제 패턴

```
int *data = (int *)malloc(sizeof(int) * 5);
if (data == NULL) return;

// 메모리 사용
free(data);
data = NULL;  // ✅ 안전한 초기화
```

> 💡 `free()` 후 반드시 포인터를 `NULL`로 설정하면, **이중 해제**와 **해제 후 사용** 모두 방지할 수 있다.

### 📊 해제 후 사용 vs 안전한 사용 비교

| 항목             | 잘못된 코드                | 안전한 코드                    |
| ---------------- | -------------------------- | ------------------------------ |
| 해제 후 접근     | `free(ptr); ptr[0] = ...;` | `free(ptr); ptr = NULL;`       |
| 해제 후 출력     | `printf("%d", *ptr);`      | `if (ptr) printf("%d", *ptr);` |
| 이중 해제 가능성 | `free(ptr); free(ptr);`    | `free(ptr); ptr = NULL;`       |

### ⚠️ 해제 후 사용의 위험

| 위험 요소     | 설명                                                   |
| ------------- | ------------------------------------------------------ |
| 프로그램 충돌 | 접근 중 Segmentation Fault 발생 가능                   |
| 데이터 훼손   | 다른 할당 요청에 의해 메모리 영역이 재사용될 수 있음   |
| 보안 취약점   | 해커가 고의로 조작된 데이터를 삽입 가능 (Heap Exploit) |

### 🧠 심화: `Use After Free` 발생 원인

- **포인터를 여러 개 복사해서 사용한 경우**

  ```
  int *a = malloc(4);  
  int *b = a;  
  free(a);  
  *b = 10;   // b는 여전히 해제된 영역을 가리킴
  ```

- **`realloc()` 사용 시 실패했는데 원래 포인터를 그대로 사용한 경우**

  ```
  int *arr = malloc(10);
  int *tmp = realloc(arr, 1000000000);  // 실패 가능
  if (tmp == NULL) {
      *arr = 100;  // 위험: arr이 이미 해제됐을 수도 있음
  }
  ```

### 🛡️ 방지 전략

| 전략                      | 설명                                                      |
| ------------------------- | --------------------------------------------------------- |
| `free()` 후 NULL로 초기화 | 가장 기본적이면서 강력한 보호 방법                        |
| 포인터 공유 지양          | 동일한 메모리 주소를 여러 포인터가 공유하지 않도록 설계   |
| 동적 영역 생명 주기 관리  | 포인터가 가리키는 메모리의 소유권과 수명을 명확히 정의    |
| 도구 활용                 | `Valgrind`, `AddressSanitizer` 등을 통해 실시간 감지 가능 |

### 🧪 Valgrind 예시

```
valgrind --leak-check=full ./your_program
```

> ✅ `Use After Free`, 메모리 누수, 이중 해제 등 다양한 오류를 탐지할 수 있음

### 🔍 코드 예: 안전한 메모리 해제 구조

```
void safe_free(int **ptr) {
    if (*ptr != NULL) {
        free(*ptr);
        *ptr = NULL;
    }
}

int main() {
    int *data = malloc(100);
    // 사용
    safe_free(&data);  // 포인터 자체를 NULL로 설정
}
```

### 🧠 요약 정리

| 핵심 포인트       | 설명                                                   |
| ----------------- | ------------------------------------------------------ |
| 해제 후 접근 금지 | `free()` 이후 메모리는 유효하지 않음                   |
| NULL 초기화 습관  | `ptr = NULL;` 반드시 적용                              |
| 디버깅 도구 활용  | `Valgrind`, `ASAN`으로 동적 검사 가능                  |
| 포인터 복사 주의  | 여러 포인터가 동일 메모리를 가리킬 경우 구조 설계 필요 |

# 8.3 동적 배열 및 구조체의 활용

### 🧾 개요

동적 메모리를 사용하면, **배열의 크기를 컴파일 타임이 아닌 런타임에 결정할 수 있으며**,
 구조체를 포함한 복합 자료형에 대해서도 유연하게 메모리를 관리할 수 있다.
 이는 **데이터 크기를 예측하기 어려운 경우**, 예를 들어 파일 입력, 사용자 입력 등에 특히 유용하다.

### 📚 1. 동적 배열의 활용

#### 🔹 기본 구조

```
int *arr = (int *)malloc(sizeof(int) * n);
```

여기서 `n`은 런타임에 결정되는 배열 크기이며, 메모리는 `heap` 영역에 동적으로 할당된다.

#### 📌 예제: 사용자 입력에 따른 정수 배열

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("배열 크기 입력: ");
    scanf("%d", &n);

    int *arr = (int *)malloc(sizeof(int) * n);
    if (arr == NULL) {
        perror("메모리 할당 실패");
        return 1;
    }

    for (int i = 0; i < n; i++) {
        arr[i] = i * 10;
        printf("arr[%d] = %d\n", i, arr[i]);
    }

    free(arr);
    return 0;
}
```

### 📚 2. 구조체 배열의 동적 할당

#### 🔹 구조체 정의

```
typedef struct {
    char name[20];
    int age;
} Person;
```

#### 🔹 동적 배열 할당

```
Person *group = (Person *)malloc(sizeof(Person) * count);
```

#### 📌 예제: 구조체 배열 사용

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[20];
    int age;
} Person;

int main() {
    int count;
    printf("사람 수 입력: ");
    scanf("%d", &count);

    Person *people = (Person *)calloc(count, sizeof(Person));
    if (people == NULL) {
        perror("메모리 할당 실패");
        return 1;
    }

    for (int i = 0; i < count; i++) {
        printf("이름 입력: ");
        scanf("%s", people[i].name);
        printf("나이 입력: ");
        scanf("%d", &people[i].age);
    }

    printf("\n== 저장된 인원 ==\n");
    for (int i = 0; i < count; i++) {
        printf("이름: %s, 나이: %d\n", people[i].name, people[i].age);
    }

    free(people);
    return 0;
}
```

### 📚 3. 구조체 내 포인터 필드의 동적 할당

#### 🔹 구조체 정의 예시

```
typedef struct {
    char *name;
    int *scores;
    int num_scores;
} Student;
```

#### 📌 예제: 구조체 내부 포인터 활용

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char *name;
    int *scores;
    int num_scores;
} Student;

int main() {
    Student s;

    s.name = (char *)malloc(30);
    s.num_scores = 3;
    s.scores = (int *)malloc(sizeof(int) * s.num_scores);

    strcpy(s.name, "Alice");
    s.scores[0] = 90;
    s.scores[1] = 85;
    s.scores[2] = 88;

    printf("이름: %s\n", s.name);
    for (int i = 0; i < s.num_scores; i++) {
        printf("점수[%d]: %d\n", i, s.scores[i]);
    }

    free(s.name);
    free(s.scores);
    return 0;
}
```

### ⚠️ 주의사항 정리

| 항목                     | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| 할당 실패 검사           | `malloc` 또는 `calloc` 사용 후 반드시 `NULL` 검사            |
| 구조체 내 포인터 해제    | 구조체에 동적 포인터 필드가 있을 경우 각각 `free()` 필요     |
| 이중 포인터 활용 시 주의 | 다차원 배열처럼 사용할 경우 각 행에 대해서도 `malloc`/`free` 필요 |
| `realloc` 사용 시 주의   | 실패 시 원래 포인터 유효하므로 별도 포인터로 임시 보관 권장  |

### 📊 요약 비교

| 항목                  | 설명                              |
| --------------------- | --------------------------------- |
| 정적 배열             | 크기가 고정됨, 스택 영역 사용     |
| 동적 배열             | 크기 유동적, 힙 영역 사용         |
| 구조체 배열 동적 할당 | `sizeof(구조체) * n` 활용         |
| 구조체 내 포인터 사용 | 내부 멤버별로 별도 동적 할당 필요 |

