# 9. 전처리기

# 9.1 매크로

## \#define 매크로

### 🧾 개요

`#define`은 C 언어의 전처리 지시문 중 하나로, **식별자(identifier)** 또는 **매크로 함수**에 대해 **텍스트 치환(text substitution)**을 수행한다.
 컴파일러가 **코드를 컴파일하기 전에 전처리기가 모든 매크로를 정의된 값으로 치환**한다.

### 🔹 기본 문법

```
#define 식별자 치환값
```

또는

```
#define 식별자(매개변수들) 치환식   // 함수형 매크로
```

> `#define`은 **세미콜론 없이** 작성한다. 컴파일러가 아니라 **전처리기 단계**에서 작동한다.

### 📚 예시

#### 📄 간단한 상수 정의

```
#define PI 3.141592
#define MAX 100
#define MSG "Hello, World!"
```

#### 🧮 함수형 매크로

```
#define SQUARE(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

> 함수형 매크로는 괄호 사용이 **매우 중요**하다.
>  예를 들어 `SQUARE(x + 1)` → `((x + 1) * (x + 1))` 처럼 의도대로 계산되게 해야 함.

### 📊 `#define` vs `const` 비교

| 항목             | `#define`                 | `const`                       |
| ---------------- | ------------------------- | ----------------------------- |
| 처리 시점        | 전처리기 단계             | 컴파일러 단계                 |
| 자료형           | 없음 (단순 텍스트 치환)   | 명확한 자료형 지정 가능       |
| 디버깅           | 디버거에서 이름 확인 불가 | 디버깅 시 식별 가능           |
| 범위 제한        | 전역                      | 블록 범위 또는 파일 범위 가능 |
| 함수형 확장 가능 | 가능 (매크로 함수)        | 불가능                        |

### 💡 좋은 매크로 작성 팁

| 항목      | 설명                                               |
| --------- | -------------------------------------------------- |
| 괄호 사용 | 모든 매개변수와 전체 수식에 괄호를 철저히 둘 것    |
| 네이밍    | 전통적으로 대문자+언더스코어 (`PI`, `BUFFER_SIZE`) |
| 오용 방지 | 함수형 매크로보다는 **인라인 함수**를 고려할 것    |

### ❌ 잘못된 매크로 예

```
#define SQUARE x * x      // ❌ 괄호 없음 → SQUARE(1+2) = 1 + 2 * 1 + 2 = 7
```

✅ 수정 버전:

```
#define SQUARE(x) ((x) * (x))
```

### 🔍 조건부 컴파일과 함께 사용

```
#define DEBUG

#ifdef DEBUG
    printf("디버깅 모드입니다\n");
#endif
```

### 🔄 매크로 해제

```
#undef PI
```

> 💡 `#undef`를 통해 매크로 정의를 중단할 수 있음.

### 🧠 심화: 다중 줄 매크로

#### 🔹 `\` 백슬래시를 이용한 줄바꿈

```
#define LOG(msg)         \
    do {                 \
        printf("LOG: "); \
        printf(msg);     \
        printf("\n");    \
    } while (0)
```

> `do { ... } while (0)` 구조는 매크로 블록을 **안전하게 처리**하기 위한 전형적인 패턴이다.

### 🧠 심화: 문자열화 및 토큰 붙이기

| 매크로 기법 | 설명                 | 예시                                                   |
| ----------- | -------------------- | ------------------------------------------------------ |
| `#`         | 인자를 문자열로 만듦 | `#define TO_STRING(x) #x` → `TO_STRING(123)` → `"123"` |
| `##`        | 인자들을 연결        | `#define JOIN(a, b) a##b` → `JOIN(var, 1)` → `var1`    |

### ✅ 결론 요약

| 핵심 포인트                    | 설명                                               |
| ------------------------------ | -------------------------------------------------- |
| `#define`은 전처리 지시문이다  | 컴파일 이전 텍스트 치환 발생                       |
| 함수형 매크로는 괄호 필수      | 매개변수, 전체 수식 모두 괄호 처리                 |
| `const`와는 용도가 다르다      | `#define`은 자료형 없음, const는 타입 명확         |
| 인라인 함수와 대체 가능성 고려 | 복잡한 매크로는 디버깅 어려움으로 함수로 대체 권장 |

## 매개변수 매크로

### 🧾 개요

매개변수 매크로란, **전처리기 수준에서 간단한 함수처럼 동작**하는 `#define` 매크로의 한 형태로,
 인자를 받아 텍스트 치환을 수행한다.

> 매개변수 매크로는 성능상 빠르며, 간단한 계산이나 표현식 치환 등에 자주 사용된다.

### 🔹 기본 문법

```
#define 매크로이름(매개변수들) 치환식
```

> 괄호를 반드시 포함해야 하며, **모든 인자와 전체 수식에 괄호**를 사용하는 것이 매우 중요하다.

### 📄 예시

#### 1. 제곱 계산

```
#define SQUARE(x) ((x) * (x))
```

→ `SQUARE(3 + 1)` → `((3 + 1) * (3 + 1))` → `16`

#### 2. 최댓값 계산

```
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

→ `MAX(5, 10)` → `((5) > (10) ? (5) : (10))` → `10`

### ⚠️ 반드시 괄호를 넣어야 하는 이유

#### ❌ 잘못된 예

```
#define SQUARE(x) x * x
SQUARE(3 + 1)   // → 3 + 1 * 3 + 1 → 7 (의도와 다름)
```

#### ✅ 올바른 예

```
#define SQUARE(x) ((x) * (x))
SQUARE(3 + 1)   // → ((3 + 1) * (3 + 1)) → 16
```

### 📊 매개변수 매크로 vs 함수 비교

| 항목      | 매개변수 매크로                | 함수 (`inline` 포함)             |
| --------- | ------------------------------ | -------------------------------- |
| 처리 시점 | 컴파일 이전 (전처리 단계)      | 컴파일 단계                      |
| 성능      | 함수 호출 오버헤드 없음 (빠름) | 최적화 시 성능 유사하거나 우수   |
| 타입 검사 | ❌ 없음                         | ✅ 컴파일러에 의한 타입 검사 가능 |
| 디버깅    | 어려움                         | 디버거에서 추적 가능             |
| 사용 용도 | 간단한 연산, 조건문 등에 적합  | 복잡한 로직, 디버깅 필요 시 적합 |

### 💡 고급 활용: 문자열화와 토큰 붙이기

#### 🔹 문자열화 (`#`)

```
#define TO_STRING(x) #x
TO_STRING(123)  // → "123"
```

#### 🔹 토큰 결합 (`##`)

```
#define JOIN(a, b) a##b
JOIN(var, 1)    // → var1
```

### 🔍 실전 예제: 디버깅용 로깅 매크로

```
#include <stdio.h>

#define LOG_INT(x) printf("[" #x "] = %d\n", x)

int main() {
    int score = 85;
    LOG_INT(score);  // 출력: [score] = 85
    return 0;
}
```

> 여기서 `#x`는 매개변수 `x`를 **문자열로 변환**한다.

### 🧠 매크로 vs 인라인 함수

| 고려 요소        | 매크로                 | 인라인 함수 (`static inline`)  |
| ---------------- | ---------------------- | ------------------------------ |
| 간단한 수식 처리 | ✅ 적합                 | ✅ 적합                         |
| 타입 안정성      | ❌ 없음                 | ✅ 강제                         |
| 디버깅 용이성    | ❌ 전처리로 인해 어려움 | ✅ 함수명 그대로 추적 가능      |
| 스코프 제한      | ❌ 전역                 | ✅ 함수 단위, 블록 내 정의 가능 |

### ✅ 결론 요약

| 핵심 항목       | 설명                                                  |
| --------------- | ----------------------------------------------------- |
| 괄호 사용       | 모든 매개변수와 전체 수식에 괄호를 철저히 사용해야 함 |
| 문자열화 기법   | `#x` 형태로 매크로 인자를 문자열로 변환 가능          |
| 토큰 결합 기법  | `a##b`로 인자를 하나의 토큰으로 결합 가능             |
| 디버깅/유지보수 | 복잡하거나 상태 있는 로직은 함수로 대체하는 것이 좋음 |

## #undef

### 🧾 개요

`#undef`는 이미 `#define`으로 정의된 **매크로를 무효화**(undefine)하기 위한 전처리기 지시문이다.

> 즉, **이름만 제거**하며 메모리 해제와는 관계가 없다.

### 🔹 기본 문법

```
#undef 매크로이름
```

이 명령은 해당 매크로를 정의 목록에서 제거한다. 이후 동일 매크로를 다시 정의할 수 있고,
 정의되어 있지 않은 것으로 간주된다.

### 📚 사용 예시

#### 🔸 기본 예제

```
#define PI 3.14
#undef PI

#define PI 3.141592   // 다시 정의 가능
```

#### 🔸 조건부 컴파일과 함께 사용

```
#define FEATURE_ENABLED

#ifdef FEATURE_ENABLED
    #undef FEATURE_ENABLED
#endif

#ifndef FEATURE_ENABLED
    printf("기능이 비활성화되었습니다.\n");
#endif
```

> 💡 어떤 매크로가 정의되어 있을 경우 `#undef`를 통해 **조건 분기 흐름을 제어**할 수 있다.

### 📊 `#define` vs `#undef`

| 항목      | `#define`                      | `#undef`                  |
| --------- | ------------------------------ | ------------------------- |
| 목적      | 매크로 정의                    | 매크로 제거               |
| 적용 대상 | 상수 정의, 매개변수 매크로 등  | 기존에 정의된 매크로 이름 |
| 사용 시점 | 전처리기 단계                  | 전처리기 단계             |
| 중복 정의 | 기존 정의된 매크로 재정의 불가 | `#undef` 후 재정의 가능   |

### 💡 주의사항

| 항목                                    | 설명                                                      |
| --------------------------------------- | --------------------------------------------------------- |
| 매크로가 정의되어 있지 않아도 오류 없음 | `#undef NON_EXISTENT_MACRO`는 무해하다                    |
| 조건부 컴파일과 자주 사용됨             | `#ifdef`, `#ifndef`, `#undef`의 조합은 구성 제어에 유용   |
| 코드 가독성 고려                        | 너무 잦은 `#undef` 사용은 코드 추적을 어렵게 만들 수 있음 |

### 🔍 실전 예시: 매크로 재정의 방지

```
#define VERSION 1.0

#ifdef VERSION
    #undef VERSION
#endif

#define VERSION 2.0
```

> 이처럼 `#undef`는 **매크로 중복 정의 오류를 방지**하는 데도 자주 사용된다.

### 🧠 고급 활용: 헤더 파일 보호와 결합

```
// math_utils.h
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

#define SQUARE(x) ((x) * (x))

#endif

// main.c
#include "math_utils.h"
#undef SQUARE  // 필요 없으면 해제
```

### ✅ 요약 정리

| 항목      | 설명                                   |
| --------- | -------------------------------------- |
| 기능      | 매크로 정의 해제                       |
| 실행 시점 | 전처리기 단계                          |
| 주요 활용 | 중복 정의 방지, 조건부 컴파일 제어     |
| 주의사항  | 해제된 매크로는 더 이상 사용할 수 없음 |
| 대안/보완 | `#ifdef`, `#ifndef`와 조합하여 사용    |

# 9.2 조건부 컴파일

## \#if, #ifdef, #ifndef, #elif, #else, #endif

### 📌 조건부 컴파일 지시문

### 🧾 개요

C 전처리기는 `#define`된 매크로 값을 기준으로 **특정 코드 블록의 컴파일 포함 여부를 제어**할 수 있다.
 이때 사용되는 지시문들이 바로 `#if`, `#ifdef`, `#ifndef`, `#elif`, `#else`, `#endif`이다.

이들은 일반적으로 다음과 같은 경우에 사용된다:

- **플랫폼에 따른 분기 처리**
- **디버그 vs 릴리즈 모드 전환**
- **중복 포함 방지 (헤더가드)**
- **선택적 기능 켜기/끄기**

### 🔹 1. `#if`

#### 🔸 기본 문법

```
#if 표현식
    // 조건이 참일 때 포함
#endif
```

- `표현식`은 **정수 상수 표현식**이어야 하며, 전처리기에서 계산됨.
- `#define`된 심볼만 사용할 수 있음.

```
#define LEVEL 2

#if LEVEL >= 2
    printf("고급 모드입니다.\n");
#endif
```

### 🔹 2. `#ifdef`

#### 🔸 기본 문법

```
#ifdef 매크로이름
    // 매크로가 정의되어 있으면 포함
#endif
```

```
#define DEBUG

#ifdef DEBUG
    printf("디버그 모드 켜짐\n");
#endif
```

### 🔹 3. `#ifndef`

#### 🔸 기본 문법

```
#ifndef 매크로이름
    // 매크로가 정의되지 않았으면 포함
#endif
```

```
#ifndef VERSION
    #define VERSION 3.0
#endif
```

### 🔹 4. `#elif`

#### 🔸 기본 문법

```
#if 조건1
    // 조건1 참
#elif 조건2
    // 조건2 참
#else
    // 둘 다 거짓
#endif
```

```
#define OS 2

#if OS == 1
    printf("Linux\n");
#elif OS == 2
    printf("Windows\n");
#else
    printf("Unknown OS\n");
#endif
```

### 🔹 5. `#else` 및 `#endif`

- `#else`: 상위 조건들이 모두 거짓일 때 실행될 코드
- `#endif`: 조건부 컴파일 블록의 종료 표시

```
#define DEBUG

#ifdef DEBUG
    printf("디버그 빌드\n");
#else
    printf("릴리즈 빌드\n");
#endif
```

### 📊 비교 요약표

| 지시문    | 조건                                 | 포함 여부           |
| --------- | ------------------------------------ | ------------------- |
| `#if`     | 표현식이 참일 경우                   | 포함                |
| `#ifdef`  | 매크로가 **정의되어 있으면**         | 포함                |
| `#ifndef` | 매크로가 **정의되어 있지 않으면**    | 포함                |
| `#elif`   | 상위 조건이 거짓이고, 현재 조건이 참 | 포함                |
| `#else`   | 위 모든 조건이 거짓일 경우           | 포함                |
| `#endif`  | 조건부 블록의 종료                   | 조건부 블록 끝 표시 |

### ⚠️ 주의사항

| 항목                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| 중첩 사용            | 조건부 블록은 **중첩 가능**하지만, `#endif`를 정확히 맞춰야 한다. |
| 정의 여부만 검사     | `#ifdef`, `#ifndef`은 값이 아닌 **존재 여부만 판단**한다.    |
| 표현식은 상수만 가능 | `#if`에서 사용하는 표현식은 **상수로 평가**되어야 하며, 변수나 함수는 사용 불가 |

### 💡 실전 예제: 헤더 가드 (Header Guard)

```
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 헤더 내용
void do_something();

#endif
```

> 이 방식은 **헤더 파일이 중복 포함되어 발생하는 문제를 방지**한다.

### 💡 실전 예제: 플랫폼 분기 처리

```
#define OS_LINUX

#ifdef OS_LINUX
    #include <unistd.h>
#elif defined(OS_WINDOWS)
    #include <windows.h>
#else
    #error "지원되지 않는 운영체제입니다."
#endif
```

### 🧠 고급 팁: 매크로와 조건부 컴파일 결합

```
#define DEBUG 1

#if DEBUG
    #define LOG(x) printf("[DEBUG] %s\n", x)
#else
    #define LOG(x)
#endif
```

> 이렇게 하면 디버깅 로깅 기능을 손쉽게 켜고 끌 수 있다.

### ✅ 정리 요약

| 키워드    | 역할 요약                               |
| --------- | --------------------------------------- |
| `#if`     | 정수 상수 표현식이 참이면 포함          |
| `#ifdef`  | 매크로가 정의돼 있으면 포함             |
| `#ifndef` | 매크로가 정의돼 있지 않으면 포함        |
| `#elif`   | 상위 조건 거짓 + 현재 조건 참일 때 포함 |
| `#else`   | 어떤 조건도 만족하지 않을 때 포함       |
| `#endif`  | 조건부 블록 종료 지시                   |

# 9.3 파일 포함

## \#include <헤더>

### 📌 `#include <헤더>` — 헤더 파일 포함 지시문

#### 🧾 개요

`#include`는 C 전처리기 지시문으로, **다른 파일의 내용을 현재 소스 파일에 삽입**하는 역할을 한다.
 일반적으로 헤더 파일의 선언(함수, 상수, 자료형 등)을 가져올 때 사용된다.

#### 🔹 기본 문법

```
#include <header_file>
#include "header_file"
```

### 📚 사용법 구분

| 구문 형식         | 용도 및 검색 경로                                            |
| ----------------- | ------------------------------------------------------------ |
| `#include <파일>` | **표준 라이브러리** 또는 시스템 헤더 포함   (예: `stdio.h`, `math.h`) |
| `#include "파일"` | **사용자 정의 헤더** 포함   현재 디렉터리 → 표준 경로 순으로 탐색 |

### 🔍 예시

#### 🔸 표준 라이브러리 포함

```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
```

#### 🔸 사용자 정의 헤더 포함

```
#include "utils.h"
#include "my_structs.h"
```

> 이 경우, 해당 파일이 **현재 디렉터리 또는 지정된 include 경로에 존재**해야 함.

### 📊 `<...>` vs `"..."` 비교 요약

| 구문             | 검색 순서                                | 주 용도          |
| ---------------- | ---------------------------------------- | ---------------- |
| `#include <...>` | 시스템 디렉터리 (`/usr/include` 등) 우선 | 표준/시스템 헤더 |
| `#include "..."` | 현재 디렉터리 → 시스템 디렉터리 순서     | 사용자 정의 헤더 |

### ⚠️ 주의사항

| 항목               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 중복 포함 주의     | 동일 헤더가 여러 번 포함되면 **재정의 오류** 발생 가능       |
| 반드시 확장자 명시 | 대부분 `.h` 확장자를 명시해야 인식 가능                      |
| 절대경로 사용 지양 | 휴대성과 가독성 문제로 비추천                                |
| 헤더가드 필수 적용 | `#ifndef ... #define ... #endif` 또는 `#pragma once` 사용 권장 |

### 💡 헤더가드 예시

```
// 파일명: mylib.h

#ifndef MYLIB_H
#define MYLIB_H

void do_something(void);

#endif
```

또는 간단하게:

```
#pragma once
```

### 🧠 심화: `#include`와 전처리기 동작

- `#include`는 전처리기 단계에서 작동하며,
- 해당 파일의 **모든 텍스트를 현재 위치에 복사**한다.
- 따라서 디버깅 시 함수 정의의 실제 위치가 아닌 **헤더 내부로 추적**될 수 있음.

### ✅ 예제: 헤더 파일 포함과 함수 선언/정의

```
// math_utils.h
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);

#endif

// math_utils.c
#include "math_utils.h"

int add(int a, int b) {
    return a + b;
}

// main.c
#include <stdio.h>
#include "math_utils.h"

int main() {
    printf("3 + 5 = %d\n", add(3, 5));
    return 0;
}
```

> 이렇게 구조화하면 **함수 선언과 구현을 분리**할 수 있고, **재사용성과 유지보수성**이 향상된다.

### 🧠 `#include`와 `Makefile`의 관계

- 헤더 파일이 변경되면, 해당 헤더를 포함하는 `.c` 파일도 **다시 컴파일**되어야 한다.
- Makefile에서는 `gcc -M` 또는 `-MM` 옵션을 통해 **헤더 의존성 자동 추적** 가능.

### ✅ 요약 정리

| 항목           | 설명                                         |
| -------------- | -------------------------------------------- |
| 기능           | 다른 파일의 내용을 현재 소스에 포함          |
| 주요 구문      | `#include <파일>`, `#include "파일"`         |
| 표준 vs 사용자 | `<...>`는 시스템 헤더, `"..."`는 사용자 헤더 |
| 헤더 보호 필요 | 중복 포함 방지를 위한 헤더가드 필수          |
| 전처리 시 동작 | 컴파일 전, 전체 텍스트를 삽입                |

## \#include "사용자 정의 헤더"

### 🧾 개요

`#include "파일명"` 구문은 **사용자 정의 헤더 파일**을 현재 소스 파일에 포함시키기 위한 전처리 지시문이다.
 해당 지시문은 **현재 디렉터리부터** 탐색을 시작하여, 파일을 찾으면 내용을 삽입한다.

### 🔹 기본 문법

```
#include "파일이름.h"
```

> 확장자는 보통 `.h`를 사용하며, 선언(함수, 상수, 구조체 등)을 모아놓는 파일이다.

### 📚 사용 예시

#### 🔸 헤더 파일 (`math_utils.h`)

```
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

int add(int a, int b);
int mul(int a, int b);

#endif
```

#### 🔸 소스 파일 (`main.c`)

```
#include <stdio.h>
#include "math_utils.h"

int main() {
    printf("%d\n", add(2, 3));
    return 0;
}
```

#### 🔸 구현 파일 (`math_utils.c`)

```
#include "math_utils.h"

int add(int a, int b) { return a + b; }
int mul(int a, int b) { return a * b; }
```

### 📊 `"..."` vs `<...>` 비교 요약

| 항목           | `#include "..."`                          | `#include <...>`                    |
| -------------- | ----------------------------------------- | ----------------------------------- |
| 검색 우선 순위 | 현재 소스 파일 디렉터리 → 시스템 디렉터리 | 시스템 디렉터리 우선 검색           |
| 사용 목적      | 사용자 정의 헤더 포함                     | 표준 라이브러리 및 시스템 헤더 포함 |
| 활용 예시      | `"utils.h"`                               | `<stdio.h>`, `<stdlib.h>`           |

### ⚠️ 주의사항

| 항목             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| 경로 지정        | 하위 디렉터리 포함 시 `"subdir/header.h"`처럼 경로를 명시해야 함 |
| 중복 포함 방지   | 반드시 **헤더 가드** 또는 `#pragma once`로 보호할 것         |
| 상대 경로만 사용 | `"..."` 구문에서는 절대 경로 사용을 피하고 상대 경로를 유지해야 이식성 보장 |

### 💡 헤더 가드 예시 (중복 포함 방지용)

```
#ifndef MY_HEADER_H
#define MY_HEADER_H

// 함수 선언, 구조체 정의 등

#endif
```

또는 간단하게:

```
#pragma once
```

### 🔍 사용자 헤더의 일반적인 사용 목적

| 용도             | 설명                                                |
| ---------------- | --------------------------------------------------- |
| 함수 선언 분리   | 함수 정의는 `.c`, 선언은 `.h`에 작성하여 **모듈화** |
| 자료형 정의 공유 | 구조체, enum, typedef 등을 여러 파일에서 함께 사용  |
| 매크로 상수 정의 | `#define MAX_BUFFER_SIZE 1024` 등 상수 정의 통합    |
| 선언 재사용      | 여러 `.c` 파일에서 동일한 헤더 포함 가능            |

### 🧠 컴파일 시 참고 사항

- 컴파일 명령 예시:

```
gcc main.c math_utils.c -o program
```

- Makefile 작성 시, 헤더 파일 변경도 의존성으로 고려:

```
main.o: main.c math_utils.h
```

### ✅ 요약 정리

| 항목          | 설명                                 |
| ------------- | ------------------------------------ |
| 사용 목적     | 사용자 정의 헤더 파일 포함           |
| 검색 경로     | 현재 디렉터리 우선 탐색              |
| 주의사항      | 헤더 가드 필수, 경로 정확히 지정     |
| 전처리 동작   | 헤더 파일의 내용을 삽입              |
| 일반적인 구성 | 선언은 `.h`, 구현은 `.c` 파일에 분리 |

